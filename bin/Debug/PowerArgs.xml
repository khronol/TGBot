<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PowerArgs</name>
    </assembly>
    <members>
        <member name="T:PowerArgs.CommandLineAction">
            <summary>
            A class that represents command line actions that users can specify on the command line.  This is useful for programs like git
            where users first specify an action like 'push' and then the remaining arguments are either global or specific to 'push'.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.Aliases">
            <summary>
            The values that the user can specify on the command line to specify this action.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.Arguments">
            <summary>
            The action specific arguments that are applicable to the end user should they specify this action.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.UsageArguments">
            <summary>
            Gets the list of arguments, filtering out those that have the ArgHiddenFromUsage attribute
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.UsageSummary">
            <summary>
            Creates a usage summary string that is specific to this action and accounts for positional argument, etc.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.UsageSummaryHTMLEncoded">
            <summary>
            Creates a usage summary string that is specific to this action and accounts for positional argument, etc. where the
            brackets are html encoded
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.Description">
            <summary>
            The description that will be shown in the auto generated usage.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.Source">
            <summary>
            The method or property that was used to define this action.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.IsSpecifiedAction">
            <summary>
            This will be set by the parser if the parse was successful and this was the action the user specified.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.IgnoreCase">
            <summary>
            Indicates whether or not the parser should ignore case when matching a user string with this action.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.OmitFromUsage">
            <summary>
            Specifies whether this action should be omitted from usage documentation
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.DefaultAlias">
            <summary>
            The first alias or null if there are no aliases.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.Metadata">
            <summary>
            The list of metadata that can be used to inject behavior into the action
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.ActionMethod">
            <summary>
            The implementation of the action that can be invoked by the parser if the user specifies this action.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.HasExamples">
            <summary>
            Returns true if there is at least 1 ArgExample metadata on this action
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.HasArguments">
            <summary>
            Returns true if this action has at least 1 action specific argument
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.HasUsageArguments">
            <summary>
            Returns true if there is at least 1 global argument that should be visible in usage, false otherwise
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.Examples">
            <summary>
            Examples that show users how to use this action.
            </summary>
        </member>
        <member name="M:PowerArgs.CommandLineAction.#ctor(System.Action{PowerArgs.CommandLineArgumentsDefinition})">
            <summary>
            Creates a new command line action given an implementation.
            </summary>
            <param name="actionHandler">The implementation of the action.</param>
        </member>
        <member name="M:PowerArgs.CommandLineAction.ToString">
            <summary>
            Gets a string representation of this action.
            </summary>
            <returns>a string representation of this action</returns>
        </member>
        <member name="M:PowerArgs.CommandLineAction.Equals(System.Object)">
            <summary>
            Determines if 2 actions are the same based on their source.  
            </summary>
            <param name="obj">The other action</param>
            <returns>True if equal, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.CommandLineAction.FindMatchingArgument(System.String,System.Boolean)">
            <summary>
            Finds the first CommandLineArgument that matches the given key.
            </summary>
            <param name="key">The key as if it was typed in on the command line.  This can also be an alias. </param>
            <param name="throwIfMoreThanOneMatch">If set to true then this method will throw and InvalidArgDeginitionException if more than 1 match is found</param>
            <returns>The first argument that matches the key.</returns>
        </member>
        <member name="T:PowerArgs.CommandLineArgument">
            <summary>
            Instances of this class represent a single command line argument that users can specify on the command line.
            Supported syntaxes include:
                -argumentName argumentValue
                /argumentName:argumentValue
                -argumentName                   - If the argument is a boolean it will be true in this case.
                --argumentName=argumentValue    - Only works if you have added an alias that starts with --.
                argumentValue                   - Only works if this argument defines the Position property as >= 0
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.Aliases">
            <summary>
            The values that can be used as specifiers for this argument on the command line
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.Metadata">
            <summary>
            Metadata that has been injected into this Argument
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.FriendlyTypeName">
            <summary>
            Gets a friendly type name for this argument.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.MustBeRevivable">
            <summary>
            Gets or sets a flag indicating that this argument must be revivable from a string.  If false, the argument can only be populated
            programatically and if specified on the command line without a reviver the program will throw an InvalidArgDefinitionException.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.ArgumentType">
            <summary>
            The CLR type of this argument.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.IgnoreCase">
            <summary>
            Specifies whether or not the parser should ignore case when trying to find a match for this argument on the command line.  Defaults to true.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.IsEnum">
            <summary>
            Returns true if the argument is an enum or a nullable where the value type is an enum
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.OmitFromUsage">
            <summary>
            Specifies whether this argument should be omitted from usage documentation
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.IncludeInUsage">
            <summary>
            True if this argument should be included in usage documentation
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.Position">
            <summary>
            If this is a positional argument then set this value >= 0 and users can specify a value without specifying an argument alias.  Defaults to -1.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.HasDefaultValue">
            <summary>
            Returns true if a default value has been explicitly registered for this argument
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.DefaultValue">
            <summary>
            The default value for this argument in the event it is optional and the user did not specify it.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.EnumValuesAndDescriptions">
            <summary>
            Only works if the ArgumentType is an enum or a nullable where the value type is an enum.  Returns a list where each element is a string containing an
            enum value and optionally its description.  Each enum value is represented in the list.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.Description">
            <summary>
            The description for this argument that appears in the auto generated usage.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.IsRequired">
            <summary>
            Gets or sets whether or not this argument is required.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.Source">
            <summary>
            If this argument was inferred from a type then the source is either a PropertyInfo or a ParameterInfo.  If this argument
            was created manually then this value will be null.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.RevivedValue">
            <summary>
            This property will contain the parsed value of the command line argument if parsing completed successfully.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.RevivedValueOverride">
            <summary>
            When set, the given value will be used to revive this argument rather than performing validation and revival.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.DefaultAlias">
            <summary>
            The first alias of this argument or null if no aliases are defined.
            </summary>
        </member>
        <member name="M:PowerArgs.CommandLineArgument.#ctor(System.Type,System.String,System.Boolean)">
            <summary>
            Creates a command line argument of the given type and sets the first default alias.
            </summary>
            <param name="t">The CLR type of the argument</param>
            <param name="defaultAlias">The default name that users will use to specify this argument</param>
            <param name="ignoreCase">If true, the parser will match this argument even if the specifier doesn't match case.  True by default.</param>
        </member>
        <member name="M:PowerArgs.CommandLineArgument.TestIsValidAndRevivable(System.String)">
            <summary>
            Tests to see if the given value would pass validation and revival.  
            </summary>
            <param name="value">the value to test</param>
            <returns>true if the value passes validation and is successfully revived, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.CommandLineArgument.ToString">
            <summary>
            Gets the string representation of this argument.
            </summary>
            <returns>the string representation of this argument.</returns>
        </member>
        <member name="T:PowerArgs.CommandLineArgumentsDefinition">
            <summary>
            This is the root class used to define a program's command line arguments.  You can start with an empty definition and 
            programatically add arguments or you can start from a Type that you have defined and have the definition inferred from it.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.ExeName">
            <summary>
            Gets or sets the ExeName for this command line argument definition's program.  If not specified the entry assembly's file name
            is used, without the file extension.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.Copyright">
            <summary>
            An optional copyright field
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.ProductName">
            <summary>
            An optional product name field
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.ProductVersion">
            <summary>
            An optional product version field
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.Description">
            <summary>
            Gets the description from ArgDescriptionMetadata if it exists, or empty string if it does not.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.HasDescription">
            <summary>
            Gets whether or not this program has a description
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.HasCopyright">
            <summary>
            Gets whether or not this program has the Copyright field set
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.HasProductName">
            <summary>
            Gets whether or not this program has a product name set
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.HasProductVersion">
            <summary>
            Gets whether or not this program has a product name set
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.HasGlobalArguments">
            <summary>
            Returns true if there is at least 1 global argument, false otherwise
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.HasGlobalUsageArguments">
            <summary>
            Returns true if there is at least 1 global argument that should be visible in usage, false otherwise
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.HasActions">
            <summary>
            Returns true if there is at least 1 action, false otherwise
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.HasUsageActions">
            <summary>
            Returns true if there is at least one action that should be visible in the usage, false otherwise.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.UsageSummary">
            <summary>
            Creates a usage summary string that takes into account actions, positional argument, etc.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.UsageSummaryHTMLEncoded">
            <summary>
            Creates a usage summary string that takes into account actions, positional argument, etc. where the
            brackets are html encoded
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.IsNonInteractive">
            <summary>
            When set to true, TabCompletion is completely disabled and required fields will ignore the PromptIfMissing flag.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.ArgumentScaffoldType">
            <summary>
            The type that was used to generate this definition.  This will only be populated if you use the constructor that takes in a type and the definition is inferred.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.Arguments">
            <summary>
            The command line arguments that are global to this definition.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.UsageArguments">
            <summary>
            Gets the list of arguments, filtering out those that have the ArgHiddenFromUsage attribute
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.AllGlobalAndActionArguments">
            <summary>
            Gets all global command line arguments as well as all arguments of any actions in this definition
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.Hooks">
            <summary>
            Global hooks that can execute all hook override methods except those that target a particular argument.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.Actions">
            <summary>
            Actions that are defined for this definition.  If you have at least one action then the end user must specify the action as the first argument to your program.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.Metadata">
            <summary>
            Arbitrary metadata that has been added to the definition
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.HasExamples">
            <summary>
            Returns true if there is at least 1 example registered for this definition
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.Examples">
            <summary>
            Examples that show users how to use your program.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.ExceptionBehavior">
            <summary>
            Determines how end user errors should be handled by the parser.  By default all exceptions flow through to your program.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.SpecifiedAction">
            <summary>
            If your definition declares actions and has been successfully parsed then this property will be populated
            with the action that the end user specified.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.HasSpecifiedAction">
            <summary>
            Returns true if this definition has been processed and an action was specified
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.UnexpectedExplicitArguments">
            <summary>
            Gets any named arguments that were present on the command line, but did not match any arguments defined
            by the definition.  This is only valid if the AllowUnexpectedArgs metadata is present.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.UnexpectedImplicitArguments">
            <summary>
            Gets any positional arguments that were present on the command line, but did not match any arguments defined
            by the definition.  This is only valid if the AllowUnexpectedArgs metadata is present.
            </summary>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinition.#ctor">
            <summary>
            Creates an empty command line arguments definition.
            </summary>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinition.#ctor(System.Type)">
            <summary>
            Creates a command line arguments definition and infers things like Arguments, Actions, etc. from the type's metadata.
            </summary>
            <param name="t">The argument scaffold type used to infer the definition</param>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinition.FindMatchingArgument(System.String,System.Boolean)">
            <summary>
            Finds the first CommandLineArgument that matches the given key.
            </summary>
            <param name="key">The key as if it was typed in on the command line.  This can also be an alias. </param>
            <param name="throwIfMoreThanOneMatch">If set to true then this method will throw and InvalidArgDeginitionException if more than 1 match is found</param>
            <returns>The first argument that matches the key.</returns>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinition.FindMatchingAction(System.String,System.Boolean)">
            <summary>
            Finds the first CommandLineAction that matches the given key
            </summary>
            <param name="key">The key as if it was typed in on the command line.  This can also be an alias. </param>
            <param name="throwIfMoreThanOneMatch">If set to true then this method will throw and InvalidArgDeginitionException if more than 1 match is found</param>
            <returns>The first action that matches the key.</returns>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinition.CreateVariableResolver">
            <summary>
            Gives you an object that you can use to tell if a particular argument was specified on the command line.
            </summary>
            <returns>object that you can use to tell if a particular argument was specified on the command line</returns>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinition.FindArgumentByPosition(System.Int32,System.String)">
            <summary>
            Finds the command line argument that is allowed to be specified in the given position (zero based). You can also
            pass an action name if you know the context of a targeted action.
            </summary>
            <param name="position">the position of the argument</param>
            <param name="action">optionally specify the name of an action which may also have positional arguments defined</param>
            <returns>a matching CommandLineArgument or none if there was no match</returns>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinition.ToString">
            <summary>
            Gets a basic string representation of the definition.
            </summary>
            <returns>a basic string representation of the definition</returns>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinition.Clean">
            <summary>
            Resets all portions of the model that may have side effects from being run through the 
            argument processor.  
            </summary>
        </member>
        <member name="T:PowerArgs.IArgMetadata">
            <summary>
            Any attribute that's purpose is to add information about a command line arguments definiton should
            derive from this type.  
            </summary>
        </member>
        <member name="T:PowerArgs.ICommandLineArgumentMetadata">
            <summary>
            Represents IArgMetadata that is valid for CommandLineArguments
            </summary>
        </member>
        <member name="T:PowerArgs.ICommandLineActionMetadata">
            <summary>
            Represents IArgMetadata that is valid for CommandLineActions
            </summary>
        </member>
        <member name="T:PowerArgs.ICommandLineArgumentsDefinitionMetadata">
            <summary>
            Represents IArgMetadata that is valid for CommandLineArgumentsDefinition instances
            </summary>
        </member>
        <member name="T:PowerArgs.IArgumentOrActionMetadata">
            <summary>
            Represents IArgMetadata that is valid for CommandLineArguments or CommandLineActions
            </summary>
        </member>
        <member name="T:PowerArgs.IGlobalArgMetadata">
            <summary>
            Represents IArgMetadata that is valid for CommandLineArguments, CommandLineActions, and CommandLineArgumentsDefinition instances
            </summary>
        </member>
        <member name="T:PowerArgs.ICommandLineArgumentsDefinitionFactory">
            <summary>
            An interface that defines a contract for creating command line argument definitions
            </summary>
        </member>
        <member name="M:PowerArgs.ICommandLineArgumentsDefinitionFactory.MakeDefinition(PowerArgs.CommandLineArgumentsDefinition)">
            <summary>
            Creates a definition given a base definition
            </summary>
            <param name="other">the base definition</param>
            <returns>the definition instance</returns>
        </member>
        <member name="M:PowerArgs.ICommandLineArgumentsDefinitionFactory.MakeDefinition">
            <summary>
            Creates a definition instance
            </summary>
            <returns>the definition instance</returns>
        </member>
        <member name="T:PowerArgs.CommandLineArgumentsDefinitionFactory">
            <summary>
            A helper class that lets you create definition factories from Funcs
            </summary>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinitionFactory.Create(System.Func{PowerArgs.CommandLineArgumentsDefinition,PowerArgs.CommandLineArgumentsDefinition})">
            <summary>
            Creates a factory that can create a definition from a base definition
            </summary>
            <param name="fromOtherImpl">An implementation that can create one definition from another</param>
            <returns>the factory</returns>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinitionFactory.Create(System.Func{PowerArgs.CommandLineArgumentsDefinition})">
            <summary>
            Creates a factory that can create a definition
            </summary>
            <param name="fromNothingImpl">An implementation that can create a defunutuin</param>
            <returns>the factory</returns>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinitionFactory.Create(System.Func{PowerArgs.CommandLineArgumentsDefinition,PowerArgs.CommandLineArgumentsDefinition},System.Func{PowerArgs.CommandLineArgumentsDefinition})">
            <summary>
            Creates a factory that can create a definition from a base definition or from nothing
            </summary>
            <param name="fromOtherImpl">An implementation that can create one definition from another</param>
            <param name="fromNothingImpl">An implementation that can create a defunutuin</param>
            <returns>the factory</returns>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinitionFactory.MakeDefinition(PowerArgs.CommandLineArgumentsDefinition)">
            <summary>
            Creates a definition from a base using the provided Func
            </summary>
            <param name="other">the base definition</param>
            <returns>a definition</returns>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinitionFactory.MakeDefinition">
            <summary>
            Creates a definition using the provided Func
            </summary>
            <returns>a definition</returns>
        </member>
        <member name="T:PowerArgs.Args">
            <summary>
            The main entry point for PowerArgs that includes the public parsing functions such as Parse, ParseAction, and InvokeAction.
            </summary>
        </member>
        <member name="M:PowerArgs.Args.GetAmbientDefinition">
            <summary>
            Gets the last definition parsed on the current thread or null if none was parsed.
            </summary>
            <returns>last definition parsed on the current thread or null if none was parsed</returns>
        </member>
        <member name="M:PowerArgs.Args.RegisterFactory(System.Type,System.Func{System.Object})">
            <summary>
            Registers a factory method the PowerArgs will use whenever it creates an object of the given type
            </summary>
            <param name="t">The type of the object created by the factory</param>
            <param name="factoryMethod">the factory method implementation</param>
        </member>
        <member name="M:PowerArgs.Args.UnRegisterFactory(System.Type)">
            <summary>
            Unregisters a factory method that PowerArgs is using to creates an object of the given type
            </summary>
            <param name="t">The type to unregister</param>
        </member>
        <member name="M:PowerArgs.Args.SearchAssemblyForRevivers(System.Reflection.Assembly)">
            <summary>
            PowerArgs will manually search the assembly you provide for any custom type revivers.  If you don't specify an
            assembly then the assembly that calls this function will automatically be searched.
            </summary>
            <param name="a">The assembly to search or null if you want PowerArgs to search the assembly that's calling into this function.</param>
        </member>
        <member name="M:PowerArgs.Args.Convert(System.String)">
            <summary>
            Converts a single string that represents a command line to be executed into a string[], 
            accounting for quoted arguments that may or may not contain spaces.
            </summary>
            <param name="commandLine">The raw arguments as a single string</param>
            <returns>a converted string array with the arguments properly broken up</returns>
        </member>
        <member name="M:PowerArgs.Args.GetAmbientArgs``1">
            <summary>
            Gets the last instance of this type of argument that was parsed on the current thread
            or null if PowerArgs did not parse an object of this type.
            </summary>
            <typeparam name="T">The scaffold type for your arguments</typeparam>
            <returns>the last instance of this type of argument that was parsed on the current thread</returns>
        </member>
        <member name="M:PowerArgs.Args.GetAmbientArgs(System.Type)">
            <summary>
            Gets the last instance of this type of argument that was parsed on the current thread
            or null if PowerArgs did not parse an object of this type.
            </summary>
            <param name="t">The scaffold type for your arguments</param>
            <returns>the last instance of this type of argument that was parsed on the current thread</returns>
        </member>
        <member name="M:PowerArgs.Args.InitializeDefaults(System.Object)">
            <summary>
            If properties on the given object contain default value attributes then this method will initalize those properties with
            the right defaults
            </summary>
            <param name="o">the object to initialize</param>
        </member>
        <member name="M:PowerArgs.Args.ParseAction(PowerArgs.CommandLineArgumentsDefinition,System.String[])">
            <summary>
            Parses the given arguments using a command line arguments definition.  
            </summary>
            <param name="definition">The definition that defines a set of command line arguments and/or actions.</param>
            <param name="args">The command line arguments to parse</param>
            <returns>An object containing parser metadata</returns>
        </member>
        <member name="M:PowerArgs.Args.ParseActionAsync(PowerArgs.CommandLineArgumentsDefinition,System.String[])">
            <summary>
            Asynchronously parses the given arguments using a command line arguments definition.  
            </summary>
            <param name="definition">The definition that defines a set of command line arguments and/or actions.</param>
            <param name="args">The command line arguments to parse</param>
            <returns>An object containing parser metadata</returns>
        </member>
        <member name="M:PowerArgs.Args.InvokeMain(PowerArgs.CommandLineArgumentsDefinition,System.String[])">
            <summary>
            Parses the args for the given definition and then calls the Main() method defined by the type.
            </summary>
            <param name="definition">The command line definition to parse</param>
            <param name="args">the command line values</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.Args.InvokeMainAsync(PowerArgs.CommandLineArgumentsDefinition,System.String[])">
            <summary>
            Asynchronously parses the args for the given definition and then calls the Main() method defined by the type.
            </summary>
            <param name="definition">The command line definition to parse</param>
            <param name="args">the command line values</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.Args.InvokeAction(PowerArgs.CommandLineArgumentsDefinition,System.String[])">
            <summary>
            Parses the given arguments using a command line arguments definition.  Then, invokes the action
            that was specified.  
            </summary>
            <param name="definition">The definition that defines a set of command line arguments and actions.</param>
            <param name="args">the command line values</param>
            <returns>The raw result of the parse with metadata about the specified action.  The action is executed before returning.</returns>
        </member>
        <member name="M:PowerArgs.Args.InvokeActionAsync(PowerArgs.CommandLineArgumentsDefinition,System.String[])">
            <summary>
            Asynchronously parses the given arguments using a command line arguments definition.  Then, invokes the action
            that was specified. 
            </summary>
            <param name="definition">The definition that defines a set of command line arguments and actions.</param>
            <param name="args">the command line values</param>
            <returns>The raw result of the parse with metadata about the specified action.  The action is executed before returning.</returns>
        </member>
        <member name="M:PowerArgs.Args.Parse(System.Type,System.String[])">
            <summary>
            Creates a new instance of the given type and populates it's properties based on the given arguments.
            </summary>
            <param name="t">The argument scaffold type</param>
            <param name="args">The command line arguments to parse</param>
            <returns>A new instance of the given type with all of the properties correctly populated</returns>
        </member>
        <member name="M:PowerArgs.Args.ParseAsync(System.Type,System.String[])">
            <summary>
            Asynchronously creates a new instance of the given type and populates it's properties based on the given arguments.
            </summary>
            <param name="t">The argument scaffold type</param>
            <param name="args">The command line arguments to parse</param>
            <returns>A new instance of the given type with all of the properties correctly populated</returns>
        </member>
        <member name="M:PowerArgs.Args.Parse``1(System.String[])">
            <summary>
            Creates a new instance of T and populates it's properties based on the given arguments.
            </summary>
            <typeparam name="T">The argument scaffold type.</typeparam>
            <param name="args">The command line arguments to parse</param>
            <returns>A new instance of T with all of the properties correctly populated</returns>
        </member>
        <member name="M:PowerArgs.Args.ParseAsync``1(System.String[])">
            <summary>
            Asynchronously creates a new instance of T and populates it's properties based on the given arguments.
            </summary>
            <typeparam name="T">The argument scaffold type.</typeparam>
            <param name="args">The command line arguments to parse</param>
            <returns>A new instance of T with all of the properties correctly populated</returns>
        </member>
        <member name="M:PowerArgs.Args.ParseAction``1(System.String[])">
            <summary>
            Creates a new instance of T and populates it's properties based on the given arguments.
            If T correctly implements the heuristics for Actions (or sub commands) then the complex property
            that represents the options of a sub command are also populated.
            </summary>
            <typeparam name="T">The argument scaffold type.</typeparam>
            <param name="args">The command line arguments to parse</param>
            <returns>The raw result of the parse with metadata about the specified action.</returns>
        </member>
        <member name="M:PowerArgs.Args.ParseActionAsync``1(System.String[])">
            <summary>
            Asynchronously creates a new instance of T and populates it's properties based on the given arguments.
            If T correctly implements the heuristics for Actions (or sub commands) then the complex property
            that represents the options of a sub command are also populated.
            </summary>
            <typeparam name="T">The argument scaffold type.</typeparam>
            <param name="args">The command line arguments to parse</param>
            <returns>The raw result of the parse with metadata about the specified action.</returns>
        </member>
        <member name="M:PowerArgs.Args.ParseAction(System.Type,System.String[])">
            <summary>
            Creates a new instance of the given type and populates it's properties based on the given arguments.
            If the type correctly implements the heuristics for Actions (or sub commands) then the complex property
            that represents the options of a sub command are also populated.
            </summary>
            <param name="t">The argument scaffold type.</param>
            <param name="args">The command line arguments to parse</param>
            <returns>The raw result of the parse with metadata about the specified action.</returns>
        </member>
        <member name="M:PowerArgs.Args.ParseActionAsync(System.Type,System.String[])">
            <summary>
            Asynchronously creates a new instance of the given type and populates it's properties based on the given arguments.
            If the type correctly implements the heuristics for Actions (or sub commands) then the complex property
            that represents the options of a sub command are also populated.
            </summary>
            <param name="t">The argument scaffold type.</param>
            <param name="args">The command line arguments to parse</param>
            <returns>The raw result of the parse with metadata about the specified action.</returns>
        </member>
        <member name="M:PowerArgs.Args.InvokeMain(System.Type,System.String[])">
            <summary>
            Parses the args for the given scaffold type and then calls the Main() method defined by the type.
            </summary>
            <param name="t">The argument scaffold type.</param>
            <param name="args">The command line arguments to parse</param>
            <returns>The raw result of the parse with metadata about the specified action.</returns>
        </member>
        <member name="M:PowerArgs.Args.InvokeMainAsync(System.Type,System.String[])">
            <summary>
            Parses the args for the given scaffold type and then calls the Main() method defined by the type.
            </summary>
            <param name="t">The argument scaffold type.</param>
            <param name="args">The command line arguments to parse</param>
            <returns>The raw result of the parse with metadata about the specified action.</returns>
        </member>
        <member name="M:PowerArgs.Args.InvokeMain``1(System.String[])">
            <summary>
            Parses the args for the given scaffold type and then calls the Main() method defined by the type.
            </summary>
            <typeparam name="T">The argument scaffold type.</typeparam>
            <param name="args">The command line arguments to parse</param>
            <returns>The raw result of the parse with metadata about the specified action.</returns>
        </member>
        <member name="M:PowerArgs.Args.InvokeMainAsync``1(System.String[])">
            <summary>
            Parses the args for the given scaffold type and then calls the Main() method defined by the type.
            </summary>
            <typeparam name="T">The argument scaffold type.</typeparam>
            <param name="args">The command line arguments to parse</param>
            <returns>The raw result of the parse with metadata about the specified action.</returns>
        </member>
        <member name="M:PowerArgs.Args.InvokeAction``1(System.String[])">
            <summary>
            Creates a new instance of T and populates it's properties based on the given arguments. T must correctly
            implement the heuristics for Actions (or sub commands) because this method will not only detect the action
            specified on the command line, but will also find and execute the method that implements the action.
            </summary>
            <typeparam name="T">The argument scaffold type that must properly implement at least one action.</typeparam>
            <param name="args">The command line arguments to parse</param>
            <returns>The raw result of the parse with metadata about the specified action.  The action is executed before returning.</returns>
        </member>
        <member name="M:PowerArgs.Args.InvokeActionAsync``1(System.String[])">
            <summary>
            Asynchronously creates a new instance of T and populates it's properties based on the given arguments. T must correctly
            implement the heuristics for Actions (or sub commands) because this method will not only detect the action
            specified on the command line, but will also find and execute the method that implements the action.
            </summary>
            <typeparam name="T">The argument scaffold type that must properly implement at least one action.</typeparam>
            <param name="args">The command line arguments to parse</param>
            <returns>The raw result of the parse with metadata about the specified action.  The action is executed before returning.</returns>
        </member>
        <member name="M:PowerArgs.Args.Parse(PowerArgs.CommandLineArgumentsDefinition,System.String[])">
            <summary>
            Parses the given arguments using a command line arguments definition. The values will be populated within
            the definition.
            </summary>
            <param name="definition">The definition that defines a set of command line arguments and/or actions.</param>
            <param name="args">The command line arguments to parse</param>
        </member>
        <member name="M:PowerArgs.Args.ParseAsync(PowerArgs.CommandLineArgumentsDefinition,System.String[])">
            <summary>
            Parses the given arguments using a command line arguments definition. The values will be populated within
            the definition.
            </summary>
            <param name="definition">The definition that defines a set of command line arguments and/or actions.</param>
            <param name="args">The command line arguments to parse</param>
        </member>
        <member name="T:PowerArgs.ArgUsage">
            <summary>
            A helper class that generates usage documentation for your command line arguments given a custom argument
            scaffolding type.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgUsage.GenerateUsageFromTemplate``1(System.String)">
            <summary>
            Generates a usage document given a template
            </summary>
            <typeparam name="T">The command line argument definition scaffold type</typeparam>
            <param name="template">The template to use or null to use the default template that's built into PowerArgs</param>
            <returns>The usage document</returns>
        </member>
        <member name="M:PowerArgs.ArgUsage.GenerateUsageFromTemplate(System.Type,System.String)">
            <summary>
            Generates a usage document given a template
            </summary>
            <param name="t">The command line argument definition scaffold type</param>
            <param name="template">The template to use or null to use the default template that's built into PowerArgs</param>
            <returns>The usage document</returns>
        </member>
        <member name="M:PowerArgs.ArgUsage.GenerateUsageFromTemplate(PowerArgs.CommandLineArgumentsDefinition,System.String,System.String)">
            <summary>
            Generates a usage document given a template
            </summary>
            <param name="def">The object that describes your program</param>
            <param name="template">The template to use or null to use the default template that's built into PowerArgs</param>
            <param name="templateSourceLocation">The source of the template, usually a file name</param>
            <returns>The usage document</returns>
        </member>
        <member name="M:PowerArgs.ArgUsage.ShowUsageInBrowser``1(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Generates web browser friendly usage documentation for your program and opens it using the local machine's default browser.
            </summary>
            <typeparam name="T">The command line argument definition scaffold type</typeparam>
            <param name="template">The template to use or null to use the default browser friendly template that's built into PowerArgs</param>
            <param name="outputFileName">Where to save the output (the browser will open the file from here)</param>
            <param name="deleteFileAfterBrowse">True if the file should be deleted after browsing</param>
            <param name="waitForBrowserExit">True if you'd like this method to block until the browser is closed.  This only works for browsers that start a new process when opened with a document.</param>
            <returns>The usage document as a string</returns>
        </member>
        <member name="M:PowerArgs.ArgUsage.ShowUsageInBrowser(PowerArgs.CommandLineArgumentsDefinition,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Generates web browser friendly usage documentation for your program and opens it using the local machine's default browser.
            </summary>
            <param name="def">The object that describes your program</param>
            <param name="template">The template to use or null to use the default browser friendly template that's built into PowerArgs</param>
            <param name="outputFileName">Where to save the output (the browser will open the file from here)</param>
            <param name="deleteFileAfterBrowse">True if the file should be deleted after browsing</param>
            <param name="waitForBrowserExit">True if you'd like this method to block until the browser is closed.  This only works for browsers that start a new process when opened with a document.</param>
            <returns>The usage document as a string</returns>
        </member>
        <member name="T:PowerArgs.Cli.CliHelper">
            <summary>
            A class that provides a framework for building interactive command line interfaces.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.CliHelper.Reader">
            <summary>
            Gets or sets the reader to use when reading input from the console
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.CliHelper.#ctor">
            <summary>
            Creates a new CLI object.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.CliHelper.Prompt(System.String,System.String[])">
            <summary>
            Prompts the user to select a value from a set of options.
            </summary>
            <param name="message">the prompt message</param>
            <param name="options">the options to choose from</param>
            <returns>The selected value</returns>
        </member>
        <member name="M:PowerArgs.Cli.CliHelper.Prompt(PowerArgs.ConsoleString,System.String[])">
            <summary>
            Prompts the user to select a value from a set of options.
            </summary>
            <param name="message">the prompt message</param>
            <param name="options">the options to choose from</param>
            <returns>The selected value</returns>
        </member>
        <member name="M:PowerArgs.Cli.CliHelper.IsUserSure(System.String)">
            <summary>
            Asks the user if they are sure about performing some operation and returns true if they indicate yes and
            false if they indicate no.
            </summary>
            <param name="about">The message to display.  'Are you sure?' will be apended.</param>
            <returns>true if they indicate yes and false if they indicate no.</returns>
        </member>
        <member name="M:PowerArgs.Cli.CliHelper.IsUserSure(PowerArgs.ConsoleString)">
            <summary>
            Asks the user if they are sure about performing some operation and returns true if they indicate yes and
            false if they indicate no.
            </summary>
            <param name="about">The message to display.  'Are you sure?' will be apended.</param>
            <returns>true if they indicate yes and false if they indicate no.</returns>
        </member>
        <member name="M:PowerArgs.Cli.CliHelper.PromptForLine(System.String)">
            <summary>
            Prompts the user for a line of input with the given message
            </summary>
            <param name="message">the prompt message</param>
            <returns>the input that the user entered</returns>
        </member>
        <member name="T:PowerArgs.Cli.PumpExceptionArgs">
            <summary>
            A class that defines the exception handling contract for a ConsoleApp
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.PumpExceptionArgs.Exception">
            <summary>
            Gets the exception that a handler may handle
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.PumpExceptionArgs.Handled">
            <summary>
            Gets or sets whether or not this exception has been handled by a handler.  Your event handler should set this to true
            if you want the pump to continue processing messages.  If no handler sets this to true then the pump thread will throw
            and the process will crash.
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.PumpMessage">
            <summary>
            A class that defines a message that can be executed by the message pump
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.PumpMessage.Description">
            <summary>
            A description for this message, used for debugging
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.PumpMessage.#ctor(System.Action,System.String)">
            <summary>
            Creates a pump message with the given action and idempotency id.  
            </summary>
            <param name="a">The action to execute when this message is dequeued by a message pump</param>
            <param name="description">A description of this message that can be used for debugging purposes</param>
        </member>
        <member name="M:PowerArgs.Cli.PumpMessage.Execute">
            <summary>
            Executes the action associated with this message
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.PaintMessage">
            <summary>
            A message that indicates a paint request that gets processed differently from other message types to reduce
            the number of times the message pump processes paint requests for a console app
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.CliMessagePump">
            <summary>
            A class that is used to manage a CLI thread in a similar way that other platforms synchronize work
            on a UI thread
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.CliMessagePump.PumpException">
            <summary>
            An event that fires when a pump message throws an exception while executing.  Handlers can mark the exception as handled
            if they want to keep the pump running.  If no handler is registered or no handler marks the exception as handled then the
            pump thread will throw and the process will crash.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.CliMessagePump.WindowResized">
            <summary>
            An event that fires when the console window has been resized by the user
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.CliMessagePump.IsRunning">
            <summary>
            A boolean that can be checked to see if the pump is currently running
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.CliMessagePump.TotalCycles">
            <summary>
            Gets the total number of event loop cycles that have run
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.CliMessagePump.CyclesPerSecond">
            <summary>
            Gets the current frame rate for the app
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.CliMessagePump.PaintRequestsProcessedPerSecond">
            <summary>
            Gets the current paint rate for the app
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.CliMessagePump.#ctor(PowerArgs.IConsoleProvider)">
            <summary>
            Creates a new message pump given a console to use for keyboard input
            </summary>
            <param name="console">the console to use for keyboard input</param>
        </member>
        <member name="M:PowerArgs.Cli.CliMessagePump.HandleKeyInput(System.ConsoleKeyInfo)">
            <summary>
            Handles key input for the message pump
            </summary>
            <param name="info"></param>
        </member>
        <member name="M:PowerArgs.Cli.CliMessagePump.QueueAction(System.Action)">
            <summary>
            Queues the given action for processing on the pump thread
            </summary>
            <param name="a">the action that will be processed in order on the pump thread</param>
        </member>
        <member name="M:PowerArgs.Cli.CliMessagePump.QueueActionAsync(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Schedules the given async action for work on the UI thread.
            </summary>
            <param name="asyncAction">the async work to do</param>
            <returns>an async task</returns>
        </member>
        <member name="M:PowerArgs.Cli.CliMessagePump.QueueActionAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Schedules the given async action for work on the UI thread.
            </summary>
            <typeparam name="T">the expected result of the work</typeparam>
            <param name="asyncAction">the async work to do</param>
            <returns>an async result of type t</returns>
        </member>
        <member name="M:PowerArgs.Cli.CliMessagePump.QueueAction(PowerArgs.Cli.PumpMessage)">
            <summary>
            Queues the given message for processing on the pump thread
            </summary>
            <param name="pumpMessage">the message that will be processed in order on the pump thread</param>
        </member>
        <member name="M:PowerArgs.Cli.CliMessagePump.QueueActionInFront(System.Action)">
            <summary>
            Puts the given action into the work queue, but skips it to the front of the queue
            </summary>
            <param name="a">the action code to run</param>
            <returns>a promise that will resolve when the work is done</returns>
        </member>
        <member name="M:PowerArgs.Cli.CliMessagePump.QueueActionInFront(PowerArgs.Cli.PumpMessage)">
            <summary>
            Puts the given action into the work queue, but skips it to the front of the queue
            </summary>
            <param name="pumpMessage">the message to process</param>
        </member>
        <member name="M:PowerArgs.Cli.CliMessagePump.SetInterval(System.Action,System.TimeSpan)">
            <summary>
            Schedules the given action for periodic processing by the message pump
            </summary>
            <param name="a">The action to schedule for periodic processing</param>
            <param name="interval">the execution interval for the action</param>
            <returns>A handle that can be passed to ClearInterval if you want to cancel the work</returns>
        </member>
        <member name="M:PowerArgs.Cli.CliMessagePump.SetTimeout(System.Action,System.TimeSpan)">
            <summary>
            Schedules the given action for a one time execution after the given period elapses
            </summary>
            <param name="a">The action to schedule</param>
            <param name="period">the period of time to wait before executing the action</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.Cli.CliMessagePump.ChangeInterval(System.IDisposable,System.TimeSpan)">
            <summary>
            Updates a previously scheduled interval
            </summary>
            <param name="handle">the handle that was returned by a previous call to setInterval</param>
            <param name="newInterval">the new interval</param>
        </member>
        <member name="M:PowerArgs.Cli.CliMessagePump.Start">
            <summary>
            Starts the message pump which will begin processing messages
            </summary>
            <returns>A task that will complete when the message pump starts</returns>
        </member>
        <member name="M:PowerArgs.Cli.CliMessagePump.Stop">
            <summary>
            Stops the pump thread
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.CliProgressBar">
            <summary>
            A utility that lets you display a progress bar on the console
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.CliProgressBar.BorderPen">
            <summary>
            Gets or sets the character to write when drawing the border
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.CliProgressBar.FillColor">
            <summary>
            Gets or sets the background color to use when filling in progress
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.CliProgressBar.MessageFillColor">
            <summary>
            Gets or sets the foreground color to use when filling in progress
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.CliProgressBar.Progress">
            <summary>
            Gets or sets the progress.  This value should be between 0 and 1, both inclusive.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.CliProgressBar.Width">
            <summary>
            Gets the width, in characters of the progress bar control.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.CliProgressBar.Message">
            <summary>
            Gets or sets the message to display inside of the progress bar
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.CliProgressBar.Console">
            <summary>
            Gets or sets the console to write to
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.CliProgressBar.#ctor(PowerArgs.ConsoleString,System.Nullable{System.Int32})">
            <summary>
            Creates a new progress bar given a width
            </summary>
            <param name="initialMessage">an initial message to display in the progress bar</param>
            <param name="width">the width to use or null to use the default width which is one third of the console buffer width</param>
        </member>
        <member name="M:PowerArgs.Cli.CliProgressBar.#ctor(System.String,System.Nullable{System.Int32})">
            <summary>
            Creates a new progress bar given a width
            </summary>
            <param name="initialMessage">an initial message to display in the progress bar</param>
            <param name="width">the width to use or null to use the default width which is one third of the console buffer width</param>
        </member>
        <member name="M:PowerArgs.Cli.CliProgressBar.Render">
            <summary>
            Renders the entire progress bar
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.CliProgressBar.RenderAndPollIndeterminate(System.Func{System.Boolean},System.TimeSpan)">
            <summary>
            Renders the progress bar and shows an indeterminate progress animation until the operation completes
            </summary>
            <param name="heartbeat">a function that should return true as long as you want to continue to block.  If you return false then this method will return.</param>
            <param name="pollingInterval">How fast you want the progress bar to call your heartbeat function</param>
        </member>
        <member name="M:PowerArgs.Cli.CliProgressBar.RenderUntilIndeterminate(System.Threading.Tasks.Task)">
            <summary>
            Renders the progress bar and shows an indeterminate progress animation until the Task completes.  This method will not
            start the task so it must be started somewhere else.
            </summary>
            <param name="workTask">the task to wait for.  This method will not start the task so it must be started somewhere else.</param>
        </member>
        <member name="M:PowerArgs.Cli.CliProgressBar.RenderUntilIndeterminate(System.Action)">
            <summary>
            Renders the progress bar and shows an indeterminate progress animation. Simultaneously, the work action is started. The bar will animate
            as long as the work action is running.
            </summary>
            <param name="workTask">the task to wait for</param>
        </member>
        <member name="M:PowerArgs.Cli.CliProgressBar.RenderAndPollDeterminate(System.Action,System.TimeSpan)">
            <summary>
            Renders the progress bar and automatically updates it on a polling interval. The method blocks until the progress reaches 1 or
            your poll action throws an OperationCancelledException, whichever comes first.  It is expected that you will update the progress
            via the poll action.  You can also update the message during the poll action.
            </summary>
            <param name="pollAction">An action to run on each polling interval</param>
            <param name="pollingInterval">The polling interval</param>
        </member>
        <member name="M:PowerArgs.Cli.CliProgressBar.Wipe">
            <summary>
            Clears the progress bar from the console and restores the console to the position it was in before drawing the progress bar
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.CliProgressBar.Update">
            <summary>
            Renders the middle portion of the progress bar that contains the message and progress fill.  You must have called Render() ahead of time for this
            to make sense.
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.ConsoleApp">
            <summary>
            A class representing a console application that uses a message pump to synchronize work on a UI thread
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleApp.Current">
            <summary>
            Gets a reference to the current app running on this thread.  This will only be populated by the thread
            that is running the message pump (i.e. it will never be your main thread).
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleApp.RequiredHeight">
            <summary>
            Specifies the minimum console height for this app to run. If the console is too small
            then the app will show a message to the user that asks them to resize it.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleApp.RequiredWidth">
            <summary>
            Specifies the minimum console width for this app to run. If the console is too small
            then the app will show a message to the user that asks them to resize it.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleApp.Stopping">
            <summary>
            An event that fires when the application is about to stop, before the console is wiped
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleApp.Stopped">
            <summary>
            An event that fires after the message pump is completely stopped and the console is wiped
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleApp.ControlAdded">
            <summary>
            An event that fires when a control is added to the visual tree
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleApp.ControlRemoved">
            <summary>
            An event that fires when a control is removed from the visual tree
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleApp.Bitmap">
            <summary>
            Gets the bitmap that will be painted to the console
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleApp.LayoutRoot">
            <summary>
            Gets the root panel that contains the controls being used by the app
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleApp.FocusManager">
            <summary>
            Gets the focus manager used to manage input focus
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleApp.AutoFillOnConsoleResize">
            <summary>
            If set to true then the app will automatically update its layout to fill the entire window.  If false the app
            will not react to resizing, which means it may clip or wrap in unexpected ways when the window is resized.
            
            If you use the constructor that takes no parameters then this is set to true and assumes you want to take the
            whole window and respond to window size changes.  If you use the constructor that takes in coordinates and boudnds
            then it is set to false and it is assumed that you only want the app to live within those bounds
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleApp.SetFocusOnStart">
            <summary>
            Gets or set whether or not to give focus to a control when the app starts.  The default is true.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleApp.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new console app given a set of boundaries
            </summary>
            <param name="x">The left position on the target console to bound this app</param>
            <param name="y">The right position on the target console to bound this app</param>
            <param name="w">The width of the app</param>
            <param name="h">The height of the app</param>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleApp.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new console app of the given width and height, positioned at x=0,y=0
            </summary>
            <param name="w">The width of the app</param>
            <param name="h">The height of the app</param>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleApp.FromMvVm(System.String,System.Object)">
            <summary>
            Creates a ConsoleApp from markup and a view model
            </summary>
            <param name="markup">The xml markup that defines the app's view</param>
            <param name="viewModel">The view model object that defines the code behind the view</param>
            <returns>An app where the view has been bound to the view model</returns>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleApp.#ctor">
            <summary>
            Creates a full screen console app that will automatically adjust its layout if the window size changes
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleApp.Show(PowerArgs.Cli.ConsoleControl)">
            <summary>
            Adds the given control to a ConsoleApp, fills the space, and blocks until the app terminates
            </summary>
            <param name="control">the control to show</param>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleApp.Start">
            <summary>
            Starts the app, asynchronously.
            </summary>
            <returns>A task that will complete when the app exits</returns>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleApp.Paint">
            <summary>
            Queues up a request to paint the app.  The system will dedupe multiple paint requests when there are multiple in the pump's work queue
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleApp.HandleKeyInput(System.ConsoleKeyInfo)">
            <summary>
            Handles key input for the application
            </summary>
            <param name="info">The key that was pressed</param>
        </member>
        <member name="T:PowerArgs.Cli.BitmapControl">
            <summary>
            A control that displays a ConsoleBitmap
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.BitmapControl.Bitmap">
            <summary>
            The Bitmap image to render in the control
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.BitmapControl.AutoSize">
            <summary>
            If true then this control will auto size itself based on its target bitmap
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.BitmapControl.#ctor">
            <summary>
            Creates a new Bitmap control
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.BitmapControl.OnPaint(PowerArgs.Cli.ConsoleBitmap)">
            <summary>
            Draws the bitmap
            </summary>
            <param name="context">the pain context</param>
        </member>
        <member name="T:PowerArgs.Cli.KeyboardShortcut">
            <summary>
            A class that represents a keyboard shortcut that can be activate a control that does not have focus
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.KeyboardShortcut.Key">
            <summary>
            The shortcut key
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.KeyboardShortcut.Modifier">
            <summary>
            A key modifier (e.g. shift, alt) that, when present, must be pressed in order for the shortcut key to trigger.  Note that control is not
            supported because it doesn't play well in a console
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.KeyboardShortcut.#ctor(System.ConsoleKey,System.Nullable{System.ConsoleModifiers})">
            <summary>
            Creates a new shortut
            </summary>
            <param name="key">the shortcut key</param>
            <param name="modifier">A key modifier (e.g. shift, alt) that, when present, must be pressed in order for the shortcut key to trigger.  Note that control is not
            supported because it doesn't play well in a console</param>
        </member>
        <member name="T:PowerArgs.Cli.Button">
            <summary>
            A button control that can be 'pressed' by the user
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Button.Pressed">
            <summary>
            An event that fires when the button is clicked
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Button.Text">
            <summary>
            Gets or sets the text that is displayed on the button
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Button.Shortcut">
            <summary>
            Gets or sets the keyboard shortcut info for this button.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.Button.#ctor">
            <summary>
            Creates a new button control
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.Button.OnAddedToVisualTree">
            <summary>
            Called when the button is added to an app
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.Button.OnPaint(PowerArgs.Cli.ConsoleBitmap)">
            <summary>
            paints the button
            </summary>
            <param name="context">drawing context</param>
        </member>
        <member name="T:PowerArgs.Cli.ConsoleControl">
            <summary>
            A class that represents a visual element within a CLI application
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.Id">
            <summary>
            An id that can be used for debugging.  It is not used for anything internally.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.ZIndex">
            <summary>
            Used to determine the order in which to paint a control within its parent.  Controls
            with higher ZIndex values are pained on top of controls with lower values.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.Focused">
            <summary>
            An event that fires after this control gets focus
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.Unfocused">
            <summary>
            An event that fires after this control loses focus
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.AddedToVisualTree">
            <summary>
            An event that fires when this control is added to the visual tree of a ConsoleApp. 
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.BeforeAddedToVisualTree">
            <summary>
            An event that fires just before this control is added to the visual tree of a ConsoleApp
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.RemovedFromVisualTree">
            <summary>
            An event that fires when this control is removed from the visual tree of a ConsoleApp.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.BeforeRemovedFromVisualTree">
            <summary>
            An event that fires just before this control is removed from the visual tree of a ConsoleApp
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.KeyInputReceived">
            <summary>
            An event that fires when a key is pressed while this control has focus and the control has decided not to process
            the key press internally.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.Application">
            <summary>
            Gets a reference to the application this control is a part of
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.Parent">
            <summary>
            Gets a reference to this control's parent in the visual tree.  It will be null if this control is not in the visual tree 
            and also if this control is the root of the visual tree.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.Background">
            <summary>
            Gets or sets the background color
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.Foreground">
            <summary>
            Gets or sets the foreground color
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.TransparentBackground">
            <summary>
            Gets or sets whether or not this control should paint its background color or leave it transparent.  By default
            this value is false.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.Tag">
            <summary>
            An arbitrary reference to an object to associate with this control
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.IsVisible">
            <summary>
            Gets or sets whether or not this control is visible.  Invisible controls are still fully functional, except that they
            don't get painted
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.CanFocus">
            <summary>
            Gets or sets whether or not this control can accept focus.  By default this is set to true, but can
            be overridden by derived classes to be false by default.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.HasFocus">
            <summary>
            Gets whether or not this control currently has focus
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleControl.#ctor">
            <summary>
            Creates a new ConsoleControl
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleControl.TryFocus">
            <summary>
            Tries to give this control focus. If the focus is in the visual tree, and is in the current focus layer, 
            and has it's CanFocus property to true then focus should be granted.
            </summary>
            <returns>True if focus was granted, false otherwise.  </returns>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleControl.TryUnfocus">
            <summary>
            Tries to unfocus this control.
            </summary>
            <returns>True if focus was cleared and moved.  False otherwise</returns>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleControl.ToString">
            <summary>
            Gets the type and Id of this control
            </summary>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleControl.OnPaint(PowerArgs.Cli.ConsoleBitmap)">
            <summary>
            You should override this method if you are building a custom control, from scratch, and need to control
            every detail of the painting process.  If possible, prefer to create your custom control by deriving from
            ConsolePanel, which will let you assemble a new control from others.
            </summary>
            <param name="context">The scoped bitmap that you can paint on</param>
        </member>
        <member name="T:PowerArgs.Cli.LabelRenderMode">
            <summary>
            Determines how a label renders
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.LabelRenderMode.SingleLineAutoSize">
            <summary>
            Render the text on a single line and auto size the width based on the text
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.LabelRenderMode.MultiLineSmartWrap">
            <summary>
            Render on multiple lines, breaking spaces and punctuation near the control's width.  Good for paragraph text.
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.LabelRenderMode.ManualSizing">
            <summary>
            Manually size the label, truncation can occur
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.Label">
            <summary>
            A control that displays text
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Label.Text">
            <summary>
            Gets or sets the text displayed on the label
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Label.MaxWidth">
            <summary>
            Gets or sets the max width.  This is only used in the single line auto size mode.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Label.MaxHeight">
            <summary>
            Gets or sets the max height.  This is only used in the multi line smart wrap mode.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Label.Mode">
            <summary>
            Gets or sets the render mode
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.Label.#ctor">
            <summary>
            Creates a new label
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.PixelControl">
            <summary>
            A control that renders a single pixel
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.PixelControl.Value">
            <summary>
            Gets or sets the character value to be displayed
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.PixelControl.#ctor">
            <summary>
            Creates a new pixel control
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.Spinner">
            <summary>
            A control that animates (or spins). It can be used to let the user know that the system
            is working when they are required to wait
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Spinner.IsSpinning">
            <summary>
            Gets or sets the flag that indicates that the spinner should be spinning
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.Spinner.#ctor">
            <summary>
            Creates a new spinner
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.Orientation">
            <summary>
            Represents the orientation of a 2d visual
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.Orientation.Vertical">
            <summary>
            Vertical orientation (up and down)
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.Orientation.Horizontal">
            <summary>
            Horizontal orientation (left and right)
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.StackPanel">
            <summary>
            A panel that handles stacking child controls
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.StackPanel.Orientation">
            <summary>
            Gets or sets the orientation of the control
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.StackPanel.Margin">
            <summary>
            Gets or sets the value, in number of console pixels to space between child elements.  Defaults to 0.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.StackPanel.AutoSize">
            <summary>
            When set to true, the panel will size itself automatically based on its children.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.StackPanel.#ctor">
            <summary>
            Creates a new stack panel
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.TextBox">
            <summary>
            A control that lets the user provide text input
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.TextBox.RichTextEditor">
            <summary>
            Gets the editor object that controls the rich text capabilities of the text box
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.TextBox.Value">
            <summary>
            Gets or sets the value in the text box
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.TextBox.BlinkEnabled">
            <summary>
            Gets or sets a flag that enables or disables the blinking cursor that appears when the text box has focus
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.TextBox.#ctor">
            <summary>
            Creates a new text box
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.TextBox.OnPaint(PowerArgs.Cli.ConsoleBitmap)">
            <summary>
            paints the text box
            </summary>
            <param name="context"></param>
        </member>
        <member name="T:PowerArgs.Cli.XYChartOptions">
            <summary>
            The options for the XYChart control
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.XYChartOptions.Title">
            <summary>
            Sets a title for the chart
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.XYChartOptions.Data">
            <summary>
            The data to plot
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.XYChartOptions.YMinOverride">
            <summary>
            When specified, forces the bottom of the Y axis to this value rather than
            letting the chart choose an appropriate value
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.XYChartOptions.YMaxOverride">
            <summary>
            When specified, forces the top of the Y axis to this value rather than
            letting the chart choose an appropriate value
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.XYChartOptions.XMinOverride">
            <summary>
            When specified, forces the left of the X axis to this value rather than
            letting the chart choose an appropriate value
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.XYChartOptions.XMaxOverride">
            <summary>
            When specified, forces the right of the X axis to this value rather than
            letting the chart choose an appropriate value
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.XYChartOptions.XAxisFormatter">
            <summary>
            Sets the formatter of the x axis. The default is to use a number formatter.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.XYChartOptions.YAxisFormatter">
            <summary>
            Sets the formatter of the y axis. The default is to use a number formatter.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.XYChartOptions.XAxisRangePadding">
            <summary>
            When you let the chart determine appropriate x axis boundaries it will pad 
            the data in the values by this value, as a percentage of the range. 
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.XYChartOptions.YAxisRangePadding">
            <summary>
            When you let the chart determine appropriate y axis boundaries then it will pad 
            the data in the values by this value, as a percentage of the range. 
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.Series">
            <summary>
            A model for a series of data that can be plotted on an XYChart
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Series.Title">
            <summary>
            The title of the series
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Series.PlotCharacter">
            <summary>
            The character to use to visually represent a point in this data series
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Series.AllowInteractivity">
            <summary>
            When set to true the user will be able to focus on the data points in this series using the tab and arrow keys.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Series.Points">
            <summary>
            The data points in this series
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.DataPoint">
            <summary>
            A model for a data point that can be plotted on an XYChart
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.DataPoint.X">
            <summary>
            The x coordinate
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.DataPoint.Y">
            <summary>
            The y coordinate
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.XYChart">
            <summary>
            A chart control that can render 2d data points on an X and Y axis
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.XYChart.#ctor(PowerArgs.Cli.XYChartOptions)">
            <summary>
            Initializes the chart with the given options
            </summary>
            <param name="options">the options to use to render the chart</param>
        </member>
        <member name="M:PowerArgs.Cli.XYChart.Show(System.Collections.Generic.IEnumerable{System.Double[]})">
            <summary>
            Shows the data in a chart via an interactive console app
            </summary>
            <param name="data">the data points, where each inner array is expected to have 2 values, the first being the X value and the second being the Y value</param>
        </member>
        <member name="M:PowerArgs.Cli.XYChart.Show(System.Collections.Generic.IEnumerable{System.Tuple{System.Double,System.Double}})">
            <summary>
            Shows the data in a chart via an interactive console app
            </summary>
            <param name="data">the data points, where the first item in the tuple is the X value and the second is the Y value</param>
        </member>
        <member name="M:PowerArgs.Cli.XYChart.Show(System.Collections.Generic.IEnumerable{PowerArgs.Cli.DataPoint})">
            <summary>
            Shows the data in a chart via an interactive console app
            </summary>
            <param name="data">the data points to plot</param>
        </member>
        <member name="M:PowerArgs.Cli.XYChart.Show(PowerArgs.Cli.XYChartOptions)">
            <summary>
            Shows the data in a chart via an interactive console app
            </summary>
            <param name="options">options used to render the chart</param>
        </member>
        <member name="M:PowerArgs.Cli.XYChart.Refresh">
            <summary>
            Re-evaluates the data and re-renders the chart
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.XYChart.OnPaint(PowerArgs.Cli.ConsoleBitmap)">
            <summary>
            Paints the chart
            </summary>
            <param name="context">the pain context</param>
        </member>
        <member name="M:PowerArgs.Cli.XYChart.DetermineYAxisLabels">
            <summary>
            This method has the side effect of updating the maxYAxisLabelLength, which is used by the various calculations
            that determine the plot area. It needs to be called anytime the data has changed, and this next part is important, it must
            be called as the very first part of the rendering pass since just about all of the rendering depends on the plot area being defined.
            </summary>
            <returns>the label info for the y axis</returns>
        </member>
        <member name="T:PowerArgs.Cli.IAxisFormatter">
            <summary>
            The interface for an axis formatter
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.IAxisFormatter.GetOptimizedAxisLabelValues(System.Double,System.Double,System.Int32)">
            <summary>
            Gets the values for ideal increments to be shown on an axis
            </summary>
            <param name="min">the lowest value represented on the axis</param>
            <param name="max">the highest value represented on the axis</param>
            <param name="maxNumberOfLabels">the maximun number of labels that can be rendered on the axis</param>
            <returns>the ideal increments</returns>
        </member>
        <member name="M:PowerArgs.Cli.IAxisFormatter.FormatValue(System.Double,System.Double,System.Double)">
            <summary>
            Formats the given value for display
            </summary>
            <param name="min">the lowest value represented on the axis</param>
            <param name="max">the highest value represented on the axis</param>
            <param name="value">the value to format</param>
            <returns>the formatted value</returns>
        </member>
        <member name="T:PowerArgs.Cli.NumberFormatter">
            <summary>
            A general purpose formatter used to format a number axis
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.NumberFormatter.GetOptimizedAxisLabelValues(System.Double,System.Double,System.Int32)">
            <summary>
            Gets the values for ideal increments to be shown on an axis
            </summary>
            <param name="min">the lowest value represented on the axis</param>
            <param name="max">the highest value represented on the axis</param>
            <param name="maxNumberOfLabels">the maximun number of labels that can be rendered on the axis</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.Cli.NumberFormatter.FormatValue(System.Double,System.Double,System.Double)">
            <summary>
            Formats the given value for display
            </summary>
            <param name="min">the lowest value represented on the axis</param>
            <param name="max">the highest value represented on the axis</param>
            <param name="value">the value to format</param>
            <returns>the formatted value</returns>
        </member>
        <member name="T:PowerArgs.Cli.DateTimeFormatter">
            <summary>
            A formatter that can format date times on an axis
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.DateTimeFormatter.GetOptimizedAxisLabelValues(System.Double,System.Double,System.Int32)">
            <summary>
            Gets the values for ideal increments to be shown on an axis
            </summary>
            <param name="min">the lowest value represented on the axis</param>
            <param name="max">the highest value represented on the axis</param>
            <param name="maxNumberOfLabels">the maximun number of labels that can be rendered on the axis</param>
            <returns>the ideal increments</returns>
        </member>
        <member name="M:PowerArgs.Cli.DateTimeFormatter.FormatValue(System.Double,System.Double,System.Double)">
            <summary>
            Formats the given value for display
            </summary>
            <param name="min">the lowest value represented on the axis</param>
            <param name="max">the highest value represented on the axis</param>
            <param name="value">the value to format</param>
            <returns>the formatted value</returns>
        </member>
        <member name="M:PowerArgs.Cli.TimeSpanFormatter.GetOptimizedAxisLabelValues(System.Double,System.Double,System.Int32)">
            <summary>
            Gets the values for ideal increments to be shown on an axis
            </summary>
            <param name="min">the lowest value represented on the axis</param>
            <param name="max">the highest value represented on the axis</param>
            <param name="maxNumberOfLabels">the maximun number of labels that can be rendered on the axis</param>
            <returns>the ideal increments</returns>
        </member>
        <member name="M:PowerArgs.Cli.TimeSpanFormatter.FormatValue(System.Double,System.Double,System.Double)">
            <summary>
            Formats the given value for display
            </summary>
            <param name="min">the lowest value represented on the axis</param>
            <param name="max">the highest value represented on the axis</param>
            <param name="value">the value to format</param>
            <returns>the formatted value</returns>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleBitmap.ToConsoleString(System.Boolean)">
            <summary>
            Converts this ConsoleBitmap to a ConsoleString
            </summary>
            <param name="trimMode">if false (the default), unformatted whitespace at the end of each line will be included as whitespace in the return value. If true, that whitespace will be trimmed from the return value.</param>
            <returns>the bitmap as a ConsoleString</returns>
        </member>
        <member name="T:PowerArgs.Cli.ConsoleBitmapFrame">
            <summary>
            The base class for a console bitmap frame
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleBitmapFrame.Timestamp">
            <summary>
            The timestamp of the frame
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleBitmapFrame.Paint(PowerArgs.Cli.ConsoleBitmap@)">
            <summary>
            Paints the current frame onto the given bitmap
            </summary>
            <param name="bitmap">The image to paint on</param>
            <returns>the resulting bitmap, which is the same as what you passed in as long as it was not null</returns>
        </member>
        <member name="T:PowerArgs.Cli.ConsoleBitmapRawFrame">
            <summary>
            A raw frame that contains all of the bitmap data needed to construct a frame
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleBitmapRawFrame.Pixels">
            <summary>
            The pixel data for the current frame
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleBitmapRawFrame.Paint(PowerArgs.Cli.ConsoleBitmap@)">
            <summary>
            Paints the entire frame onto the given bitmap.  If the given bitmap is null then
            a new bitmap of the correct size will be created and assigned to the reference you
            have provided.  The normal usage pattern is to pass null when reading the first frame,
            which will always be a raw frame.  You can then pass this same bitmap to subsequent calls
            to Paint, and it will work whether the subsequent frames are raw frames or diff frames.
            
            </summary>
            <param name="bitmap">The bitmap to paint on or null to create a new bitmap from the raw frame</param>
            <returns>the same bitmap you passed in or one that was created for you</returns>
        </member>
        <member name="T:PowerArgs.Cli.ConsoleBitmapDiffFrame">
            <summary>
            A frame that contains only the pixel data for pixels that have changed since the previous frame
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleBitmapDiffFrame.Diffs">
            <summary>
            The pixel diff data, one element for each pixel that has changed since the last frame
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleBitmapDiffFrame.Paint(PowerArgs.Cli.ConsoleBitmap@)">
            <summary>
            Paints the diff on top of the given image which, unlike with raw frames, cannot be null,
            since a diff frame can only be applied to an existing image
            </summary>
            <param name="bitmap">the image to apply the diff to</param>
            <returns>the same image reference you passed in, updated with the diff</returns>
        </member>
        <member name="T:PowerArgs.Cli.ConsoleBitmapPixelDiff">
            <summary>
            Represents a changed pixel
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleBitmapPixelDiff.X">
            <summary>
            The x coordinate of the pixel
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleBitmapPixelDiff.Y">
            <summary>
            The y coordinate of the pixel
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleBitmapPixelDiff.Value">
            <summary>
            The value of the pixel
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.ConsoleBitmapFrameSerializer">
            <summary>
            The code that converts console bitmap frames from their in memory structure to lines of text, and vice versa
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.ConsoleBitmapFrameSerializer.tokenizer">
            <summary>
            The tokenizer that will parse each line during deserialization
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleBitmapFrameSerializer.#ctor">
            <summary>
            Creates a new instance of the serializer
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleBitmapFrameSerializer.SerializeFrame(PowerArgs.Cli.ConsoleBitmapRawFrame)">
            <summary>
            Serializes the given raw frame.
            
            A serialized raw frame is always a single line with this structure:
            
            All data values are surrounded in square brackets like [dataValue]
            
            Segment1 - Timestamp in the format: [$timestampInTicks$] where $timestampInTicks$ represents a 64 bit non-negative integer
            Segment2 - The type of frame, in this case [Raw]
            Segment3 - The raw bitmap data
                
                The first pixel will be preceded by color markers for foreground (e.g. [F=Red]) and background (e.g. [B=Red]) which means that subsequence characters have those color characteristics.
                If the next pixel is a different foreground and/or background color then there will be color markers for those changes in between the pixel data values
                If the next pixel shares the same foreground and background then there will be no color markers in between those pixels. This saves space.
                Each pixel value is surrounded by square brackets like [A] if the pixel value was A.
                Each pixel value is generally a single character, but square brackets are encoded a OB for the opening bracket and CB for the closing bracket
                The pixels are ordered vertically starting at x = 0, y = 0.  
                There are no markers for the end of a vertical scan line since you're assumed to know the size from the header.
            </summary>
            <param name="frame">a raw frame</param>
            <returns>a serialized string</returns>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleBitmapFrameSerializer.SerializeFrame(PowerArgs.Cli.ConsoleBitmapDiffFrame)">
            <summary>
            Serializes the given diff frame.
            
            A serialized diff frame is always a single line with this structure:
            
            All data values are surrounded in square brackets like [dataValue]
            
            Segment1 - Timestamp in the format: [$timestampInTicks$] where $timestampInTicks$ represents a 64 bit non-negative integer
            Segment2 - The type of frame, in this case [Diff]
            Segment3 - The diff data
                
                The first pixel will be preceded by color markers for foreground (e.g. [F=Red]) and background (e.g. [B=Red]) which means that subsequence characters have those color characteristics.
                If the next pixel is a different foreground and/or background color then there will be color markers for those changes in between the pixel data values
                If the next pixel shares the same foreground and background then there will be no color markers in between those pixels. This saves space.
                Diff pixels are surrounded in square brackets in this format: [xCoordinate,yCoordinate,pixelValue].
                pixelValue is generally a single character, but square brackets are encoded a OB for the opening bracket and CB for the closing bracket    
            
            </summary>
            <param name="frame">a raw frame</param>
            <returns>a serialized string</returns>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleBitmapFrameSerializer.DeserializeFrame(System.String,System.Int32,System.Int32)">
            <summary>
            Deserializes the given frame given a known width and height.
            </summary>
            <param name="serializedFrame">the frame data</param>
            <param name="width">the known width of the frame</param>
            <param name="height">the known height of the frame</param>
            <returns>a deserialized frame that's either a raw frame or a diff frame, depending on what was in the serialized string</returns>
        </member>
        <member name="T:PowerArgs.Cli.PlayerState">
            <summary>
            All states that the player can be in
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.ConsoleBitmapPlayer">
            <summary>
            A control that can play console app recordings from a stream
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleBitmapPlayer.State">
            <summary>
            Gets the current state of the player
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleBitmapPlayer.AfterFrameLoadDelay">
            <summary>
            An artificial delay that is added after each frame is loaded from the stream.  This can simulate
            a slow loading connection and is good for testing.  This should always be set to null when PowerArgs ships.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleBitmapPlayer.RewindAndFastForwardIncrement">
            <summary>
            Gets or sets the rewind and fast forward increment, defaults to 10 seconds
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.ConsoleBitmapPlayer.playerProgressBar">
            <summary>
            The bar that's rendered below the player.  It shows the current play cursor and loading progress.
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.ConsoleBitmapPlayer.pictureFrame">
            <summary>
            The border control that hosts the current frame inside of it
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.ConsoleBitmapPlayer.pictureInTheFrame">
            <summary>
            The control that renders the current frame in the video
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.ConsoleBitmapPlayer.playButton">
            <summary>
            The buttons that appear under the player progress bar
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.ConsoleBitmapPlayer.seekToBeginningButton">
            <summary>
            The buttons that appear under the player progress bar
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.ConsoleBitmapPlayer.seekBack10SButton">
            <summary>
            The buttons that appear under the player progress bar
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.ConsoleBitmapPlayer.seekForward10SButton">
            <summary>
            The buttons that appear under the player progress bar
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.ConsoleBitmapPlayer.seekToEndButton">
            <summary>
            The buttons that appear under the player progress bar
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.ConsoleBitmapPlayer.playLifetime">
            <summary>
            The lifetime of the current play operation (or null if the player is not playing)
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.ConsoleBitmapPlayer.duration">
            <summary>
            The duration of the currently loaded video.  This is set once the first frame of the video is loaded
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.ConsoleBitmapPlayer.inMemoryVideo">
            <summary>
            The in memory video data structure.  This is set once the first frame of the video is loaded
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.ConsoleBitmapPlayer.playStartPosition">
            <summary>
            The cursor position at the time playback started.  If the current state is not Playing then this value
            is meaningless.
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.ConsoleBitmapPlayer.playStartTime">
            <summary>
            The wall clock time when playback started.  If the current state is not playing then this value is meaningless.
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.ConsoleBitmapPlayer.lastFrameIndex">
            <summary>
            The most recent frame index received from the reader's TrySeek method
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.ConsoleBitmapPlayer.failedMessage">
            <summary>
            The error message to show if loading failed
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleBitmapPlayer.CurrentFrame">
            <summary>
            Gets or sets the current frame image
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleBitmapPlayer.#ctor">
            <summary>
            Creates a console bitmap player control with no video loaded
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleBitmapPlayer.SeekToBeginningButtonPressed">
            <summary>
            Seeks to the beginning of the video.  If the video is playing then it will continue playing
            from the beginning of the video
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleBitmapPlayer.SeekToEndButtonPressed">
            <summary>
            Seeks to the end of the video
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleBitmapPlayer.Rewind">
            <summary>
            Rewinds the video by the amount defined by the RewindAndFastForwardIncrement.  If the
            video was playing then it will continue to play
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleBitmapPlayer.FastForward">
            <summary>
            Fast forwards the video by the amount defined by the RewindAndFastForwardIncrement.  If the
            video was playing then it will continue to play, unless it hits the end of the video.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleBitmapPlayer.PlayPressed">
            <summary>
            The handler for the play button that handles play / pause toggling and resetting to the beginning
            if the player is currently stopped at the end of the video.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleBitmapPlayer.StateChanged">
            <summary>
            The state change handler that defines what happens whenever the player changes state
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleBitmapPlayer.Load(System.IO.Stream)">
            <summary>
            Loads a video from a given stream
            </summary>
            <param name="videoStream">the video stream</param>
        </member>
        <member name="T:PowerArgs.Cli.ConsoleBitmapStreamReader">
            <summary>
            An object that can read console bitmap frames from a stream
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleBitmapStreamReader.Duration">
            <summary>
            The duration of the video, only known once the first frame is read
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleBitmapStreamReader.InnerStream">
            <summary>
            The inner stream that was passed to the constructor
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.ConsoleBitmapStreamReader.readBuffer">
            <summary>
            A bitmap that represents the most recently read frame
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleBitmapStreamReader.CurrentBitmap">
            <summary>
            The most recently read frame bitmap
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleBitmapStreamReader.CurrentFrame">
            <summary>
            The most recently read frame data
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleBitmapStreamReader.#ctor(System.IO.Stream)">
            <summary>
            Creates a new reader from a given stream
            </summary>
            <param name="s">a stream to read</param>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleBitmapStreamReader.ReadToEnd(System.Action{PowerArgs.Cli.InMemoryConsoleBitmapVideo})">
            <summary>
            Reads the stream to the end, providing progress information along the way
            </summary>
            <param name="progressCallback">a callback that will be called each time there is a new frame available</param>
            <returns>The complete video in its in fully expanded in memory structure</returns>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleBitmapStreamReader.ReadFrame">
            <summary>
            Reads an individual frame from the stream.  CurrentFrame will be set to the current frame data or null if
            there are no more frames to read.  
            </summary>
            <returns>This reader</returns>
        </member>
        <member name="T:PowerArgs.Cli.InMemoryConsoleBitmapVideo">
            <summary>
            The fully expanded in memory representation of a console bitmap video
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.InMemoryConsoleBitmapVideo.LoadProgress">
            <summary>
            The loading progress, from 0 to 1
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.InMemoryConsoleBitmapVideo.Duration">
            <summary>
            The duration of the video, populated once the first frame is read
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.InMemoryConsoleBitmapVideo.Frames">
            <summary>
            All frames that have been loaded so far
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.InMemoryConsoleBitmapVideo.Seek(System.TimeSpan,PowerArgs.Cli.ConsoleBitmap@,System.Int32)">
            <summary>
            Tries to seek to the requested destination in the video.
            </summary>
            <param name="destination">the timestamp to seek to</param>
            <param name="bitmap">the bitmap reference to update</param>
            <param name="startFrameIndex">the first frame index to look into or 0 if starting from the beginning</param>
            <returns>the frame index of the loaded frame or -1 if the destination has not yet loaded</returns>
        </member>
        <member name="T:PowerArgs.Cli.InMemoryConsoleBitmapFrame">
            <summary>
            The fully expanded representation of an in memory video frame
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.InMemoryConsoleBitmapFrame.FrameTime">
            <summary>
            The frame's timestamp
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.InMemoryConsoleBitmapFrame.Bitmap">
            <summary>
            The frame image
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.ConsoleBitmapStreamWriter">
            <summary>
            An object that can write console bitmap video data to a stream
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleBitmapStreamWriter.FramesWritten">
            <summary>
            Gets the total number of frames written by the writer. This only counts unique frames
            since calls to write frames with the same image as the previous frame are ignored.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleBitmapStreamWriter.CloseInnerStream">
            <summary>
            If true then the writer will close the inner stream when it's finished
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleBitmapStreamWriter.InnerStream">
            <summary>
            Gets the inner stream that was passed to the constructor
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleBitmapStreamWriter.#ctor(System.IO.Stream)">
            <summary>
            Creates a new writer given a stream
            </summary>
            <param name="s">the stream to write to</param>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleBitmapStreamWriter.WriteFrame(PowerArgs.Cli.ConsoleBitmap,System.Boolean,System.Nullable{System.TimeSpan})">
            <summary>
            Writes the given bitmap image as a frame to the stream.  If this is the first image or more than half of the pixels have
            changed then a raw frame will be written.   Otherwise, a diff frame will be written.
            
            This method uses the system's wall clock to determine the timestamp for this frame. The timestamp will be 
            relative to the wall clock time when the first frame was written.
            </summary>
            <param name="bitmap">the image to write</param>
            <param name="desiredFrameTime">if provided, sstamp the frame with this time, otherwise stamp it with the wall clock delta from the first frame time</param>
            <param name="force">if true, writes the frame even if there are no changes</param>
            <returns>the same bitmap that was passed in</returns>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleBitmapStreamWriter.WriteEnd">
            <summary>
            Writes the duration information in the beginning of the stream and then closes the inner stream
            if CloseInnerStream is true
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.PlayerProgressBar">
            <summary>
            A progress bar designed for use with the console bitmap player.  It shows the current play cursor and indicates loading progress
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.PlayerProgressBar.LoadProgressPosition">
            <summary>
            The current position of the loading indicator (0 to 1)
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.PlayerProgressBar.PlayCursorPosition">
            <summary>
            The current position of the play cursor (0 to 1)
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.PlayerProgressBar.LoadingProgressColor">
            <summary>
            The color of the portion of the bar that represents loaded content, defaults to white
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.PlayerProgressBar.ShowPlayCursor">
            <summary>
            True if you want to render the play cursor, false otherwise
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.PlayerProgressBar.PlayCursorColor">
            <summary>
            The color of the play cursor, defaults to green
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.PlayerProgressBar.OnPaint(PowerArgs.Cli.ConsoleBitmap)">
            <summary>
            Paints the progress bar
            </summary>
            <param name="context"></param>
        </member>
        <member name="T:PowerArgs.Cli.FocusManager">
            <summary>
            A class that manages the focus of a CLI application
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.FocusManager.FocusContext">
            <summary>
            Data object used to capture the focus context on the stack
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.FocusManager.FocusContext.Controls">
            <summary>
            The controls being managed by this context
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.FocusManager.FocusContext.FocusIndex">
            <summary>
            The current focus index within this context
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.FocusManager.FocusContext.#ctor">
            <summary>
            Creates a new focus context
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.FocusManager.StackDepth">
            <summary>
            Gets the number of layers on the stack
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.FocusManager.GlobalKeyHandlers">
            <summary>
            Gets the keyboard manager that can be used to intercept keystrokes on the current layer
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.FocusManager.FocusedControl">
            <summary>
            Gets the currently focused control or null if there is no control with focus yet.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.FocusManager.#ctor">
            <summary>
            Initializes the focus manager
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.FocusManager.Add(PowerArgs.Cli.ConsoleControl)">
            <summary>
            Adds the current control to the current focus context
            </summary>
            <param name="c">The control to add</param>
        </member>
        <member name="M:PowerArgs.Cli.FocusManager.Remove(PowerArgs.Cli.ConsoleControl)">
            <summary>
            Removes the control from all focus contexts
            </summary>
            <param name="c">The control to remove</param>
        </member>
        <member name="M:PowerArgs.Cli.FocusManager.Push">
            <summary>
            Pushes a new focus context onto the stack.  This is useful, for example, when a dialog appears above all other
            controls and you want to limit focus to the dialog to acheive a modal affect.  You must remember to call pop
            when your context ends.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.FocusManager.Pop">
            <summary>
            Pops the current focus context.  This should be called if you've implemented a modal dialog like experience and your dialog
            has just closed.  Pop() will automatically restore focus on the previous context.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.FocusManager.TrySetFocus(PowerArgs.Cli.ConsoleControl)">
            <summary>
            Tries to set focus on the given control.
            </summary>
            <param name="newFocusControl">the control to focus.  </param>
            <returns>True if the focus was set or if it was already set, false if the control cannot be focused</returns>
        </member>
        <member name="M:PowerArgs.Cli.FocusManager.TryMoveFocus(System.Boolean)">
            <summary>
            Tries to move the focus forward or backwards
            </summary>
            <param name="forward">If true then the manager will try to move forwards, otherwise backwards</param>
            <returns>True if the focus moved, false otehrwise</returns>
        </member>
        <member name="M:PowerArgs.Cli.FocusManager.TryRestoreFocus">
            <summary>
            Tries to restore the focus on the given context
            </summary>
            <returns>True if the focus changed, false otehrwise</returns>
        </member>
        <member name="M:PowerArgs.Cli.FocusManager.ClearFocus">
            <summary>
            Clears the focus, but preserves the focus index
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.MarkupPropertyAttribute">
            <summary>
            An attribute that a can be added to a ConsoleControl property of a complex type
            so that text values in markup can be converted to those types.  If the complex type implements
            a static Parse method then you may not need this attribute.  However, if your complex type would benefit
            from an experience where the user provides multiple attributes for your type (e.g. Fill and Fill-Padding)
            then the MarkupPropertyAttribute will work because you will have access to the parser context. 
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.MarkupPropertyAttribute.#ctor(System.Type)">
            <summary>
            Initiates the processor
            </summary>
            <param name="processorType">The processor type that must implement IMarkupProcessor</param>
        </member>
        <member name="T:PowerArgs.Cli.MarkupIgnoreAttribute">
            <summary>
            An attribute you can add to a ConsoleControl class to indicate that the given markup
            attribute name can be safely ignored.  This is likely because another markup processor
            will handle it.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.MarkupIgnoreAttribute.#ctor(System.String)">
            <summary>
            Initiates the ignore attribute given the markup xml attribute name
            </summary>
            <param name="attributeName">the xml markup attribute name to ignore</param>
        </member>
        <member name="T:PowerArgs.Cli.MarkupExtensionAttribute">
            <summary>
            An attribute that can be added to a ConsoleControl class that lets you process markup attributes that do not map to properties on your control
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.MarkupExtensionAttribute.AttributeName">
            <summary>
            The markup attribute name that you're adding support for
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.MarkupExtensionAttribute.#ctor(System.String,System.Type)">
            <summary>
            Creates a markup extension given an attribute name and a processor type
            </summary>
            <param name="attributeName">The markup attribute name that you're adding support for</param>
            <param name="processorType">The processor type that must implement IMarkupProcessor</param>
        </member>
        <member name="T:PowerArgs.Cli.IMarkupProcessor">
            <summary>
            An interface that defines the protocol for processing ConsoleApp markup
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.IMarkupProcessor.Process(PowerArgs.Cli.ParserContext)">
            <summary>
            A method that will be called by the markup parser at the appropriate time
            </summary>
            <param name="context">Context about the markup element, control, and view model being processed</param>
        </member>
        <member name="T:PowerArgs.Cli.ParserContext">
            <summary>
            A class that provides context to code that is building a visual tree from markup and binding it to a view model
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ParserContext.CurrentElement">
            <summary>
            The current xml element being parsed
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ParserContext.RootElement">
            <summary>
            The root xml element being parsed
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ParserContext.RootViewModel">
            <summary>
            The root view model
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ParserContext.CurrentViewModel">
            <summary>
            the view model to apply to the current control
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ParserContext.CurrentControl">
            <summary>
            The current control being processed in the visual treee
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.XmlAttribute">
            <summary>
            Represents an XML attribute
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.XmlAttribute.Name">
            <summary>
            Gets the name of the attribute
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.XmlAttribute.Value">
            <summary>
            Gets the value of the attribute
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.XmlAttribute.LineNumber">
            <summary>
            gets the line number of the attribute from IXmlLineInfo.LineNumber
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.XmlAttribute.LinePosition">
            <summary>
            Gets the line position of the attribute from IXmlLineInfo.LinePosition
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.XmlAttribute.HasLineInfo">
            <summary>
            Always returns true
            </summary>
            <returns>Always returns true</returns>
        </member>
        <member name="T:PowerArgs.Cli.XmlElement">
            <summary>
            Represents an XML element
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.XmlElement.Name">
            <summary>
            Gets the name of the element
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.XmlElement.LineNumber">
            <summary>
            gets the line number of the attribute from IXmlLineInfo.LineNumber
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.XmlElement.LinePosition">
            <summary>
            Gets the line position of the attribute from IXmlLineInfo.LinePosition
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.XmlElement.HasLineInfo">
            <summary>
            Always returns true
            </summary>
            <returns>Always returns true</returns>
        </member>
        <member name="P:PowerArgs.Cli.XmlElement.Item(System.String)">
            <summary>
            Gets the string value of the given attribute name or null if the attribute does not exist
            </summary>
            <param name="attributeName">the name of the attribute to inspect</param>
            <returns>the string value of the given attribute name or null if the attribute does not exist</returns>
        </member>
        <member name="P:PowerArgs.Cli.XmlElement.Item(System.Int32)">
            <summary>
            Gets the child element at the given index
            </summary>
            <param name="index">the index</param>
            <returns>the child element at the given index</returns>
        </member>
        <member name="P:PowerArgs.Cli.XmlElement.Elements">
            <summary>
            Gets the child elements of this element
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.XmlElement.Attributes">
            <summary>
            Gets the attributes that this element has
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.XmlElement.Attribute``1(System.String,System.Func{System.String,``0},System.Nullable{``0})">
            <summary>
            Gets the value of the given attribute name
            </summary>
            <typeparam name="T">The expected type of the attribute</typeparam>
            <param name="attributeName">the name of the attribute</param>
            <param name="parser">a parser to use, by default this method will try to find a static Parse method that accepts a single string argument and returns the proper type</param>
            <param name="defaultValue">optionally pass a default value to return if the attribute was not found</param>
            <returns>the value of the attribute parsed to the requested type, or a default value (null if no default provided)</returns>
        </member>
        <member name="T:PowerArgs.Cli.Event">
            <summary>
            A lifetime aware event
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Event.HasSubscriptions">
            <summary>
            returns true if there is at least one subscriber
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.Event.Fire">
            <summary>
            Fires the event. All subscribers will be notified
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.Event.#ctor">
            <summary>
            Creates a new event
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.Event.SubscribeUnmanaged(System.Action)">
            <summary>
            Subscribes to this event such that the given handler will be called when the event fires 
            </summary>
            <param name="handler">the action to run when the event fires</param>
            <returns>A subscription that can be disposed when you no loner want to be notified from this event</returns>
        </member>
        <member name="M:PowerArgs.Cli.Event.SubscribeForLifetime(System.Action,PowerArgs.Cli.ILifetimeManager)">
            <summary>
            Subscribes to this event such that the given handler will be called when the event fires. Notifications will stop
            when the lifetime associated with the given lifetime manager is disposed.
            </summary>
            <param name="handler">the action to run when the event fires</param>
            <param name="lifetimeManager">the lifetime manager that determines when to stop being notified</param>
        </member>
        <member name="M:PowerArgs.Cli.Event.SubscribeOnce(System.Action)">
            <summary>
            Subscribes to the event for one notification and then immediately unsubscribes so your callback will only be called at most once
            </summary>
            <param name="handler">The action to run when the event fires</param>
        </member>
        <member name="T:PowerArgs.Cli.Event`1">
            <summary>
            A lifetime aware event that can deliver a data payload to subscribers
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:PowerArgs.Cli.Event`1.HasSubscriptions">
            <summary>
            returns true if there is at least one subscriber
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.Event`1.Fire(`0)">
            <summary>
            Fires the event and delivers the given data payload to all subscribers
            </summary>
            <param name="item">the data payload</param>
        </member>
        <member name="M:PowerArgs.Cli.Event`1.#ctor">
            <summary>
            Creates the event
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.Event`1.SubscribeUnmanaged(System.Action{`0})">
            <summary>
            Subscribes to this event such that the given handler will be called when the event fires 
            </summary>
            <param name="handler">the action to run when the event fires</param>
            <returns>a subscription that can be disposed when you no longer want to be notified from this event</returns>
        </member>
        <member name="M:PowerArgs.Cli.Event`1.SubscribeForLifetime(System.Action{`0},PowerArgs.Cli.ILifetimeManager)">
            <summary>
            Subscribes to this event such that the given handler will be called when the event fires. Notifications will stop
            when the lifetime associated with the given lifetime manager is disposed.
            </summary>
            <param name="handler">the action to run when the event fires</param>
            <param name="lifetimeManager">the lifetime manager that determines when to stop being notified by this event</param>
        </member>
        <member name="M:PowerArgs.Cli.Event`1.SubscribeOnce(System.Action{`0})">
            <summary>
            Subscribes to the event for one notification and then immediately unsubscribes so your callback will only be called at most once
            </summary>
            <param name="handler">The action to run when the event fires</param>
        </member>
        <member name="T:PowerArgs.Cli.EventRouter`1">
            <summary>
            A router that can route events based on paths and variables
            </summary>
            <typeparam name="T">The event data object type</typeparam>
        </member>
        <member name="P:PowerArgs.Cli.EventRouter`1.NotFound">
            <summary>
            An event that fires when a route was not found for a given path
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.EventRouter`1.Route(System.String,`0)">
            <summary>
            Fires an event with the given id and data
            </summary>
            <param name="path">the event id</param>
            <param name="data">the event data to send to subscribers</param>
        </member>
        <member name="M:PowerArgs.Cli.EventRouter`1.Await(System.String,System.Nullable{System.TimeSpan})">
            <summary>
            Delays until the next time an event occurs for the given route
            </summary>
            <param name="route">the route to match</param>
            <param name="timeout">an optional timeout</param>
            <returns>the event args</returns>
        </member>
        <member name="M:PowerArgs.Cli.EventRouter`1.Register(System.String,System.Action{PowerArgs.Cli.RoutedEvent{`0}},PowerArgs.Cli.ILifetimeManager)">
            <summary>
            Subscribes to the given event for the given lifetime
            </summary>
            <param name="route">the event to subscribe to</param>
            <param name="handler">the event handler</param>
            <param name="lifetimeManager">defines the lifetime of the subscription</param>
        </member>
        <member name="M:PowerArgs.Cli.EventRouter`1.RegisterOnce(System.String,System.Action{PowerArgs.Cli.RoutedEvent{`0}})">
            <summary>
            Subscribes to the given event for at most one notification
            </summary>
            <param name="route">the event to subscribe to</param>
            <param name="handler">the event handler</param>
        </member>
        <member name="T:PowerArgs.Cli.Lifetime">
            <summary>
            An object that has a beginning and and end  that can be used to define the lifespan of event and observable subscriptions.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Lifetime.Forever">
            <summary>
            The forever lifetime manager that will never end. Any subscriptions you intend to keep forever should use this lifetime so it's easy to spot leaks.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Lifetime.IsExpired">
            <summary>
            If true then this lifetime has already ended
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.ObservableCollection`1">
            <summary>
            An observable list implementation
            </summary>
            <typeparam name="T">the type of elements this collection will contain</typeparam>
        </member>
        <member name="P:PowerArgs.Cli.ObservableCollection`1.BeforeAdded">
            <summary>
            Called before an item is added to the list
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ObservableCollection`1.BeforeRemoved">
            <summary>
            Called after an item is removed from the list
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ObservableCollection`1.Added">
            <summary>
            Called when an element is added to this list
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ObservableCollection`1.Removed">
            <summary>
            Called when an element is removed from this list
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ObservableCollection`1.Changed">
            <summary>
            Called whenever this list changes.  You may receive one event for multiple changes
            if the changes were atomic (e.g. after calling Clear()).
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ObservableCollection`1.AssignedToIndex">
            <summary>
            Called whenever an index assignment is made
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ObservableCollection`1.#ctor">
            <summary>
            Initialized the collection
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ObservableCollection`1.GetPrevious(System.String)">
            <summary>
            Gets the previous value of the given property
            </summary>
            <param name="name">the name of the property to lookup</param>
            <returns>the previous value or null if there was no value</returns>
        </member>
        <member name="M:PowerArgs.Cli.ObservableCollection`1.FireAdded(`0)">
            <summary>
            Fires the Added event for the given item
            </summary>
            <param name="item">The item that was added</param>
        </member>
        <member name="M:PowerArgs.Cli.ObservableCollection`1.FireRemoved(`0)">
            <summary>
            Fired the Removed event for the given item
            </summary>
            <param name="item">The item that was removed</param>
        </member>
        <member name="M:PowerArgs.Cli.ObservableCollection`1.IndexOf(`0)">
            <summary>
            Returns the index of the given item in the list
            </summary>
            <param name="item">the item to look for</param>
            <returns>the index or a negative number if the element is not in the list</returns>
        </member>
        <member name="M:PowerArgs.Cli.ObservableCollection`1.Insert(System.Int32,`0)">
            <summary>
            Inserts the given item into the list at the specified position
            </summary>
            <param name="index">the index to insert the item into</param>
            <param name="item">the item to insert</param>
        </member>
        <member name="M:PowerArgs.Cli.ObservableCollection`1.RemoveAt(System.Int32)">
            <summary>
            Removes the element at the specified index
            </summary>
            <param name="index">the index of the item to remove</param>
        </member>
        <member name="P:PowerArgs.Cli.ObservableCollection`1.Item(System.Int32)">
            <summary>
            Gets or sets the value at a particular index
            </summary>
            <param name="index">the index of the item to get or set</param>
            <returns>the value at a particular index</returns>
        </member>
        <member name="M:PowerArgs.Cli.ObservableCollection`1.Add(`0)">
            <summary>
            Adds the given item to the list
            </summary>
            <param name="item">the item to add</param>
        </member>
        <member name="M:PowerArgs.Cli.ObservableCollection`1.Clear">
            <summary>
            Removes all items from the collection
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ObservableCollection`1.Contains(`0)">
            <summary>
            Tests to see if the list contains the given item
            </summary>
            <param name="item">the item to look for</param>
            <returns>true if the list contains the given item, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.Cli.ObservableCollection`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies values from this list into the given array starting at the given index in the destination
            </summary>
            <param name="array">the destination array</param>
            <param name="arrayIndex">the index in the destination array to start the copy</param>
        </member>
        <member name="P:PowerArgs.Cli.ObservableCollection`1.Count">
            <summary>
            Gets the number of items in the list
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ObservableCollection`1.IsReadOnly">
            <summary>
            Always returns false
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ObservableCollection`1.Remove(`0)">
            <summary>
            Removes the given item from the list
            </summary>
            <param name="item">the item to remove</param>
            <returns>true if an item was removed, false if the item was not found in the list</returns>
        </member>
        <member name="M:PowerArgs.Cli.ObservableCollection`1.GetEnumerator">
            <summary>
            Gets an enumerator for this list
            </summary>
            <returns>an enumerator for this list</returns>
        </member>
        <member name="M:PowerArgs.Cli.ObservableCollection`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator for this list
            </summary>
            <returns>an enumerator for this list</returns>
        </member>
        <member name="T:PowerArgs.Cli.ObservableDocument">
            <summary>
            A wrapper for an IObservableObject that provides deep change notification along
            with deep undo / redo. 
            
            This is useful if you are building an editing experience for a structured document.
            
            To use this effectively you should model your document as an IObjectObservable. Nested
            properties and collections are supported as long as the nested properties are themselves
            IObservableObjects or IObservableCollections. Any properties that are not observable
            will not have their changes reflected by the Changed event nor will thier changes be
            modified by Undo or Redo operations.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ObservableDocument.Changed">
            <summary>
            An event that fires when any change is detected in the document. This could be a 
            property change on the root object or some nested observable. It could also be an
            add, remove ,or index assigment on a property that is an IObservableCollection.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ObservableDocument.Undo">
            <summary>
            Undoes the last change that was detected
            </summary>
            <returns>true if there was a previous change to undo, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.Cli.ObservableDocument.Redo">
            <summary>
            Redoes the last change that was undone
            </summary>
            <returns>true if there was a change to redo, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.Cli.ObservableDocument.ClearUndoRedoStack">
            <summary>
            Clears the undo / redo stack.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ObservableDocument.#ctor(PowerArgs.Cli.IObservableObject)">
            <summary>
            Creates an ObservableDocument given a root observable. The ObservableDocument will
            immiediately attach to the root object and all child observables.
            </summary>
            <param name="root">the root object to observe</param>
        </member>
        <member name="T:PowerArgs.Cli.ObservableObject">
            <summary>
            A class that makes it easy to define an object with observable properties
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.ObservableObject.AnyProperty">
            <summary>
            Subscribe or synchronize using this key to receive notifications when any property changes
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ObservableObject.SuppressEqualChanges">
            <summary>
            Set to true if you want to suppress notification events for properties that get set to their existing values.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ObservableObject.DeepObservableRoot">
            <summary>
            DeepObservableRoot
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ObservableObject.#ctor(PowerArgs.Cli.IObservableObject)">
            <summary>
            Creates a new bag and optionally sets the notifier object.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ObservableObject.Get``1(System.String)">
            <summary>
            This should be called by a property getter to get the value
            </summary>
            <typeparam name="T">The type of property to get</typeparam>
            <param name="name">The name of the property to get</param>
            <returns>The property's current value</returns>
        </member>
        <member name="M:PowerArgs.Cli.ObservableObject.GetPrevious``1(System.String)">
            <summary>
            Gets the previous value of the given property name
            </summary>
            <typeparam name="T">the type of property to get</typeparam>
            <param name="name">the name of the property</param>
            <returns>the previous value or default(T) if there was none</returns>
        </member>
        <member name="M:PowerArgs.Cli.ObservableObject.Set``1(``0,System.String)">
            <summary>
            This should be called by a property getter to set the value.
            </summary>
            <typeparam name="T">The type of property to set</typeparam>
            <param name="value">The value to set</param>
            <param name="name">The name of the property to set</param>
        </member>
        <member name="M:PowerArgs.Cli.ObservableObject.SubscribeUnmanaged(System.String,System.Action)">
            <summary>
            Subscribes to be notified when the given property changes.
            </summary>
            <param name="propertyName">The name of the property to subscribe to or ObservableObject.AnyProperty if you want to be notified of any property change.</param>
            <param name="handler">The action to call for notifications</param>
            <returns>A subscription that will receive notifications until it is disposed</returns>
        </member>
        <member name="M:PowerArgs.Cli.ObservableObject.SubscribeForLifetime(System.String,System.Action,PowerArgs.Cli.ILifetimeManager)">
            <summary>
            Subscribes to be notified when the given property changes.  The subscription expires when
            the given lifetime manager's lifetime ends.
            </summary>
            <param name="propertyName">The name of the property to subscribe to or ObservableObject.AnyProperty if you want to be notified of any property change.</param>
            <param name="handler">The action to call for notifications</param>
            <param name="lifetimeManager">the lifetime manager that determines when the subscription ends</param>
        </member>
        <member name="M:PowerArgs.Cli.ObservableObject.SynchronizeUnmanaged(System.String,System.Action)">
            <summary>
            Subscribes to be notified when the given property changes and also fires an initial notification immediately.
            </summary>
            <param name="propertyName">The name of the property to subscribe to or ObservableObject.AnyProperty if you want to be notified of any property change.</param>
            <param name="handler">The action to call for notifications</param>
            <returns>A subscription that will receive notifications until it is disposed</returns>
        </member>
        <member name="M:PowerArgs.Cli.ObservableObject.SynchronizeForLifetime(System.String,System.Action,PowerArgs.Cli.ILifetimeManager)">
            <summary>
            Subscribes to be notified when the given property changes and also fires an initial notification.  The subscription expires when
            the given lifetime manager's lifetime ends.
            </summary>
            <param name="propertyName">The name of the property to subscribe to or ObservableObject.AnyProperty if you want to be notified of any property change.</param>
            <param name="handler">The action to call for notifications</param>
            <param name="lifetimeManager">the lifetime manager that determines when the subscription ends</param>
        </member>
        <member name="M:PowerArgs.Cli.ObservableObject.FirePropertyChanged(System.String)">
            <summary>
            Fires the PropertyChanged event with the given property name.
            </summary>
            <param name="propertyName">the name of the property that changed</param>
        </member>
        <member name="M:PowerArgs.Cli.ObservableObject.EqualsSafe(System.Object,System.Object)">
            <summary>
            A generic equals implementation that allows nulls to be passed for either parameter.  Objects should not call this from
            within their own equals method since that will cause a stack overflow.  The Equals() functions do not get called if the two
            inputs reference the same object.
            </summary>
            <param name="a">The first object to test</param>
            <param name="b">The second object to test</param>
            <returns>True if the values are equal, false otherwise.</returns>
        </member>
        <member name="T:PowerArgs.Cli.Physics.SignalDirection">
            <summary>
            Enum to represent the falling or rising action of a signal
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.Physics.SignalDirection.Rising">
            <summary>
            The signal value is increasing
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.Physics.SignalDirection.Falling">
            <summary>
            The signal value is decreasing
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.Physics.DebounceableSignal">
            <summary>
            Debounces a numeric signal whose value changes over time based on a threshold.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Physics.DebounceableSignal.ActiveChanged">
            <summary>
            An event that fires when the threshold is crossed
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Physics.DebounceableSignal.ActiveDirection">
            <summary>
            Gets or sets the active direction. If you expect the signal to remain below a given threshold
            then you should set this to 'Rising'. If you expect the signal to remain above a given threshold then set this to 'Falling'.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Physics.DebounceableSignal.Threshold">
            <summary>
            The threshold to either remain above or below
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Physics.DebounceableSignal.CoolDownAmount">
            <summary>
            The amount that the signal must surpass the threshold before moving from the active to the inactive state
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Physics.DebounceableSignal.Active">
            <summary>
            Gets the current active state of the signal
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.Physics.DebounceableSignal.Update(System.Double)">
            <summary>
            Updates the value of the signal
            </summary>
            <param name="newValue">the new value</param>
        </member>
        <member name="M:PowerArgs.Cli.Physics.SpaceExtensions.NormalizeQuantity(System.Single,System.Single,System.Boolean)">
            <summary>
            In most consoles the recrtangles allocated to characters are about twice as tall as they
            are wide. Since we want to treat the console like a uniform grid we'll have to account for that.
            
            This method takes in some quantity and an angle and normalizes it so that if the angle were flat (e.g. 0 or 180)
            then you'll get back the same quantity you gave in. If the angle is vertical (e.g. 90 or 270) then you will get back
            a quantity that is only half of what you gave. The degree to which we normalize the quantity is linear.
            </summary>
            <param name="quantity">The quantity to normalize</param>
            <param name="angle">the angle to use to adjust the quantity</param>
            <param name="reverse">if true, grows the quantity instead of shrinking it. This is useful for angle quantities.</param>
            <returns></returns>
        </member>
        <member name="T:PowerArgs.Cli.Physics.PauseFunction">
            <summary>
            A function used to temporarily pause a time simulation
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.Physics.PauseFunction.Initialize">
            <summary>
            This method sleeps until the function is removed from the time simulation
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.Physics.PauseFunction.Evaluate">
            <summary>
            Not implemented, pause is impemented by the Initialize method.
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.Physics.RateGovernor">
            <summary>
            A rate regulator
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Physics.RateGovernor.Rate">
            <summary>
            The regulation rate
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.Physics.RealTimeViewingFunction">
            <summary>
            A time function that ensures that its target time simulation does not proceed
            faster than the system's wall clock
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Physics.RealTimeViewingFunction.Behind">
            <summary>
            An event that fires when the target time simulation falls behind or catches up to
            the wall clock
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Physics.RealTimeViewingFunction.Enabled">
            <summary>
            Enables or disables the real time viewing function
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.Physics.RealTimeViewingFunction.#ctor(PowerArgs.Cli.Physics.Time,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan})">
            <summary>
            Creates a realtime viewing function
            </summary>
            <param name="t">the time simulation model to target</param>
            <param name="fallBehindThreshold">The time model will be determined to have fallen behind if the simulation falls
            behind the system wall clock by more than this amound (defaults to 100 ms)</param>
            <param name="fallBehindCooldownPeriod">When in the behind state the time simulation must surpass the FallBehindThreshold
            by this amount before moving out of the behind state. This is a debouncing mechanism.</param>
        </member>
        <member name="T:PowerArgs.Cli.Physics.Time">
            <summary>
            A model of time that lets you plug time functions and play them out on a thread. Each iteration of the time loop processes queued actions,
            executes time functions in order, and then increments the Now value.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Physics.Time.CurrentTime">
            <summary>
            Gets the time model running on the current thread. 
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Physics.Time.TimeFunctionAdded">
            <summary>
            An event that fires when a time function is added to the model
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Physics.Time.TimeFunctionRemoved">
            <summary>
            An event that fires when a time function is removed from the model
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Physics.Time.UnhandledException">
            <summary>
            An event that fires when there is an unhandled exception on the model's thread
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Physics.Time.AfterTick">
            <summary>
            An event that fires after the time is incremented.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Physics.Time.Now">
            <summary>
            The current time
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Physics.Time.Increment">
            <summary>
            The amount to add to the value of 'Now' after each tick.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Physics.Time.IsRunning">
            <summary>
            Tells you if the time thread is currently running
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Physics.Time.Functions">
            <summary>
            Enumerates all of the time functions that are a part of the model as of now.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.Physics.Time.#ctor(System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan})">
            <summary>
            Creates a new time model, optionally providing a starting time and increment
            </summary>
            <param name="increment">The amount of time to increment on each iteration, defaults to one 100 nanosecond tick</param>
            <param name="now">The starting time, defaults to zero</param>
        </member>
        <member name="M:PowerArgs.Cli.Physics.Time.Start">
            <summary>
            Starts the time simulation thread
            </summary>
            <returns>A promise that represents the end of the time simulation</returns>
        </member>
        <member name="M:PowerArgs.Cli.Physics.Time.Stop">
            <summary>
            Stops the time model
            </summary>
            <returns>A promise that will complete when the simulation finishes</returns>
        </member>
        <member name="M:PowerArgs.Cli.Physics.Time.QueueAction(System.Action)">
            <summary>
            Queues an action that will run at the beginning of the next time iteration
            </summary>
            <param name="action">code to run at the beginning of the next time iteration</param>
        </member>
        <member name="M:PowerArgs.Cli.Physics.Time.Add``1(``0)">
            <summary>
            Adds the given time function to the model. This method must be called from the time thread.
            </summary>
            <typeparam name="T">The type of the time function</typeparam>
            <param name="timeFunction">the time function to add</param>
            <returns>the time function that was passed in</returns>
        </member>
        <member name="M:PowerArgs.Cli.Physics.Time.Delay(System.Action,System.Int32)">
            <summary>
            Runs the given code after a Time thread delay (not wall time)
            </summary>
            <param name="action">the code to run</param>
            <param name="delayInMilliseconds">The amount of Time thread time (not wall time) to delay</param>
            <returns>A time function that represents your action</returns>
        </member>
        <member name="M:PowerArgs.Cli.Physics.Time.AssertIsThisTimeThread">
            <summary>
            Call this method to guard against code running on this model's time thread. It will throw an InvalidOperationException
            if the check fails.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.Physics.Time.AssertTimeThread">
            <summary>
            Asserts that there is a time model running on the current thread
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.Physics.ITimeFunction">
            <summary>
            An interface for a time function that can be plugged into a time simulation
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Physics.ITimeFunction.Added">
            <summary>
            An event that will be fired when this function is added to a time model
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Physics.ITimeFunction.InternalState">
            <summary>
            Used internally for bookkeeping. Implementors should just new up one of these upon
            construction
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Physics.ITimeFunction.Lifetime">
            <summary>
            Gets the lifetime of this time function. The end point of the lifetime
            will be when this function is removed from a time model.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Physics.ITimeFunction.Governor">
            <summary>
            Gets the rate governor that determines how frequently this function should be evaluated. 
            The actual evaulation interval will be either the governor value or the time model's increment value, 
            whichever is largest.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.Physics.ITimeFunction.Initialize">
            <summary>
            An initialization function that will be called when the function is added to the model
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.Physics.ITimeFunction.Evaluate">
            <summary>
            The method that will be called by the time model when it is time for this function to
            be evaluated.
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.Physics.TimeFunction">
            <summary>
            A base class to use for general purpose time functions that implements all but the
            functional elements of the time function interface
            
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Physics.TimeFunction.Added">
            <summary>
            An event that will be fired when this function is added to a time model
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Physics.TimeFunction.InternalState">
            <summary>
            Internal state
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Physics.TimeFunction.Lifetime">
            <summary>
            Gets the lifetime of this time function. The end point of the lifetime
            will be when this function is removed from a time model.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.Physics.TimeFunction.Governor">
            <summary>
            Gets the rate governor that determines how frequently this function should be evaluated. 
            The actual evaulation interval will be either the governor value or the time model's increment value, 
            whichever is largest.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.Physics.TimeFunction.Initialize">
            <summary>
            An initialization function that will be called when the function is added to the model
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.Physics.TimeFunction.Evaluate">
            <summary>
            Gets the rate governor that determines how frequently this function should be evaluated. 
            The actual evaulation interval will be either the governor value or the time model's increment value, 
            whichever is largest.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.Physics.TimeFunction.Create(System.Action,System.Action,System.Nullable{System.TimeSpan})">
            <summary>
            Creates a time function given action code to run
            </summary>
            <param name="eval">The evaluation action to run</param>
            <param name="init">An optional initialization function</param>
            <param name="rate">The governor rate for the function</param>
            <returns>A time function that can be added into a time model</returns>
        </member>
        <member name="M:PowerArgs.Cli.Physics.TimeFunction.CreateDelayed(System.TimeSpan,System.Action,System.Action,System.Nullable{System.TimeSpan})">
            <summary>
            Creates a time function that will not initialzie / evaluate untl after the returned function has been added to Time
            for the delay period
            </summary>
            <param name="delay">The amount of time to wait before creating the function</param>
            <param name="eval">the evaluate method</param>
            <param name="init">the initialize method</param>
            <param name="rate">the rate at which the evaluate function runs</param>
            <returns>A delayed time function</returns>
        </member>
        <member name="T:PowerArgs.Cli.Physics.ITimeFunctionExtensions">
            <summary>
            Extension methods that target the ITimeFunction interface
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.Physics.ITimeFunctionExtensions.CalculateAge(PowerArgs.Cli.Physics.ITimeFunction)">
            <summary>
            Gets the age of the given function defined as the amount of simulation time that the function has been a part of the model.
            </summary>
            <param name="function">the function to target</param>
            <returns>The age, as a time span</returns>
        </member>
        <member name="M:PowerArgs.Cli.Physics.ITimeFunctionExtensions.IsAttached(PowerArgs.Cli.Physics.ITimeFunction)">
            <summary>
            Determines if the given function is currently attached to a time simulation
            </summary>
            <param name="function">the function to target</param>
            <returns>true if attached to a time model, false otherwise</returns>
        </member>
        <member name="T:PowerArgs.Cli.Physics.TimeFunctionInternalState">
            <summary>
            A bookkeeping class that is used internally
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.PowerArgsRichCommandLineReader">
            <summary>
            A customized version of the RichTextCommandLineReader that configures tab completion, history, and syntax highlighting for a given
            command line arguments definition.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.PowerArgsRichCommandLineReader.ArgumentNameForeground">
            <summary>
            Gets or sets the foreground color to use when a valid argument name appears on the command line
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.PowerArgsRichCommandLineReader.NumericForeground">
            <summary>
            Gets or sets the foreground color to use when a numeric value appears on the command line
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.PowerArgsRichCommandLineReader.StringLiteralForeground">
            <summary>
            Gets or sets the foreground color to use when a double quoted string literal appears on the command line
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.PowerArgsRichCommandLineReader.ActionForeground">
            <summary>
            Gets or sets the foregrund color to use when a valid action alias appears as the first token on the command line
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.PowerArgsRichCommandLineReader.Definition">
            <summary>
            Gets the definition that is used to configure the reader
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.PowerArgsRichCommandLineReader.#ctor(PowerArgs.CommandLineArgumentsDefinition,System.Collections.Generic.List{PowerArgs.ConsoleString})">
            <summary>
            Configures the reader for the given definition and history information.
            </summary>
            <param name="definition">The definition to use to configure the reader</param>
            <param name="history">previous command line values that the end user will be able to cycle through using the up and down arrows</param>
        </member>
        <member name="M:PowerArgs.Cli.PowerArgsRichCommandLineReader.TryTabComplete(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            Implementation of tab completion that leverages tab completion sources that are registered with the target definition.
            </summary>
            <param name="cliContext">cintext used internally</param>
            <returns>true if a tab completion was successfully made, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.Cli.PowerArgsRichCommandLineReader.FindCurrentTokenArgument(PowerArgs.CommandLineAction,System.String,System.Boolean@,PowerArgs.CommandLineArgumentsDefinition)">
            <summary>
            A helper that detects the argument represented by the current token given a definition.  
            </summary>
            <param name="contextualAction">An action to inspect for a match if the current token does not match a global argument.  Pass null to only check global arguments.</param>
            <param name="currentToken">The token to inspect.  If you pass null you will get null back.</param>
            <param name="expectMatchingArg">This will be set to true if the current token starts with a '-' or a '/' meaning that the token was an argument indicator, even if it didn't match an argument in the definition.</param>
            <param name="def">The definition to inspect.  If null, the ambient definition will be used.  If there is no ambient definition and null is passed then this method throws a NullReferenceException.</param>
            <returns>An argument that is matched by the given token or null if there was no match</returns>
        </member>
        <member name="M:PowerArgs.Cli.PowerArgsRichCommandLineReader.FindContextualArgument(System.String,PowerArgs.CommandLineAction,PowerArgs.CommandLineArgumentsDefinition)">
            <summary>
            A helper that detects the argument represented by the current token given a definition.  
            </summary>
            <param name="previousToken">The token to inspect.  If you pass null you will get null back.</param>
            <param name="contextualAction">An action to inspect for a match if the current token does not match a global argument.  Pass null to only check global arguments.</param>
            <param name="def">The definition to inspect.  If null, the ambient definition will be used.  If there is no ambient definition and null is passed then this method throws a NullReferenceException.</param>
            <returns>An argument that is matched by the given token or null if there was no match</returns>
        </member>
        <member name="M:PowerArgs.Cli.PowerArgsRichCommandLineReader.FindPreviousNonWhitespaceToken(PowerArgs.Cli.RichCommandLineContext,PowerArgs.Cli.HighlighterContext)">
            <summary>
            Searches the reader's tokens for a non whitespace token that preceeds the current token
            </summary>
            <param name="readerContext">the reader context to inspect</param>
            <param name="highlighterContext">the highlighter context to inspect</param>
            <returns>a non whitespace token that preceeds the current token or null if no such token is found</returns>
        </member>
        <member name="M:PowerArgs.Cli.PowerArgsRichCommandLineReader.FindContextualAction(System.String,PowerArgs.CommandLineArgumentsDefinition)">
            <summary>
            Finds the action that matches the given token in the given definition
            </summary>
            <param name="firstToken">the token to test.  If you pass null you will get null back.</param>
            <param name="def">The definition to inspect.  If null, the ambient definition will be used.  If there is no ambient definition and null is passed then this method throws a NullReferenceException.</param>
            <returns>the action that matches the given token in the given definition or null if no such action is found</returns>
        </member>
        <member name="T:PowerArgs.Cli.ConsoleHistoryManager">
            <summary>
            A class that stores and manages command line history that is used by the up and down arrow keys handler to let users cycle through historical command lines.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleHistoryManager.Values">
            <summary>
            Gets the list of values that can be cycled through
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.ContextAssistPicker">
            <summary>
            A context assist provider that lets the user select from a fixed set of options
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ContextAssistPicker.SupportsAsync">
            <summary>
            returns false, always
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ContextAssistPicker.Options">
            <summary>
            The options the user can choose from
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ContextAssistPicker.CanAssist(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            Returns true if there is at least one option, false otherwise.
            </summary>
            <param name="context">context about the parent reader</param>
            <returns>true if there is at least one option, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.Cli.ContextAssistPicker.#ctor">
            <summary>
            initialized the picker
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ContextAssistPicker.GetResults(System.String)">
            <summary>
            returns all options that contain the given search string, ignoring case
            </summary>
            <param name="searchString">the search string</param>
            <returns>all options that contain the given search string, ignoring case</returns>
        </member>
        <member name="M:PowerArgs.Cli.ContextAssistPicker.GetResultsAsync(System.String)">
            <summary>
            Not implemented
            </summary>
            <param name="searchString">Not implemented</param>
            <returns>Not implemented</returns>
        </member>
        <member name="M:PowerArgs.Cli.ContextAssistPicker.Pick(PowerArgs.IConsoleProvider,System.Boolean)">
            <summary>
            Lets the user pick from the set of options.
            </summary>
            <param name="console">optionally provide a custom console implementation</param>
            <param name="allowCancel">if true, users can cancel picking by pressing the escape key.  If false, the escape key does nothing.</param>
            <returns>A valid selection or null if the search was cancelled.</returns>
        </member>
        <member name="T:PowerArgs.Cli.ContextAssistResultStatusCode">
            <summary>
            Status codes that content assist providers can return
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.ContextAssistResultStatusCode.NoOp">
            <summary>
            Indicates that no progress was made and that the assist provider should continue to accept keyboard input.
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.ContextAssistResultStatusCode.Success">
            <summary>
            Indicates that progress was made and that the value of the result object's NewBuffer property should be used to replace the parent reader's buffer.
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.ContextAssistResultStatusCode.Cancel">
            <summary>
            Indicates that the user or system cancelled the assist provider and the parent buffer should not be modified. 
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.ContextAssistResult">
            <summary>
            A class that represents a result that an IContentAssistProvider returns to a parent reader.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ContextAssistResult.StatusCode">
            <summary>
            Gets status code for this result
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ContextAssistResult.NewBuffer">
            <summary>
            Gets the new buffer to apply to the parent reader.  This is only applicable for a status code of Success.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ContextAssistResult.ConsoleRefreshLeftOffset">
            <summary>
            Gets the offset to apply to the cursor position.  This is only applicable for a status code of Success.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ContextAssistResult.IsTerminal">
            <summary>
            Returns true if this result should stop the current assist provider, false otherwise
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.ContextAssistResult.NoOp">
            <summary>
            A result that indicates that no result is ready and that the assist provider should continue to accept keyboard input
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.ContextAssistResult.Cancel">
            <summary>
            A result that indicates that either the user or the system wants to stop the assist provider without making any changes to the 
            parent reader
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ContextAssistResult.CreateCustomResult(System.Collections.Generic.List{PowerArgs.ConsoleCharacter},System.Int32)">
            <summary>
            Creates a custom result that manually replaces the entire parent reader's buffer.
            </summary>
            <param name="newBuffer">the new buffer to apply to the parent reader</param>
            <param name="consoleRefreshLeftOffset">The relative offset to apply to the current cursor position</param>
            <returns>a custom result that manually replaces the entire parent reader's buffer</returns>
        </member>
        <member name="M:PowerArgs.Cli.ContextAssistResult.CreateInsertResult(PowerArgs.Cli.RichCommandLineContext,PowerArgs.ConsoleString)">
            <summary>
            Creates a result that replaces the current token with the given selection.
            </summary>
            <param name="context">Context from the parent reader</param>
            <param name="selection">The selection string to insert</param>
            <returns>a result that replaces the current token with the given selection</returns>
        </member>
        <member name="T:PowerArgs.Cli.ContextAssistSearchResult">
            <summary>
            A class that represents a search result that can be selected by the ContextAssistSearch context assist provider.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ContextAssistSearchResult.DisplayText">
            <summary>
            Gets the text to display in the results view.  This text is also used when this result is inserted into the parent reader
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ContextAssistSearchResult.RichDisplayText">
            <summary>
            Gets the text to display in the results view.  This text is also used when this result is inserted into the parent reader
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ContextAssistSearchResult.ResultValue">
            <summary>
            Gets a plain old .NET object that represents the underlying result value.  In many cases this will be the same as the display text.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ContextAssistSearchResult.FromString(System.String)">
            <summary>
            Creates a string result where the display text and value are the same object.
            </summary>
            <param name="stringValue">the result string</param>
            <returns>a search result</returns>
        </member>
        <member name="M:PowerArgs.Cli.ContextAssistSearchResult.FromConsoleString(PowerArgs.ConsoleString)">
            <summary>
            Creates a string result where the display text and value are the same object.
            </summary>
            <param name="stringValue">the result string</param>
            <returns>a search result</returns>
        </member>
        <member name="M:PowerArgs.Cli.ContextAssistSearchResult.FromObject(System.Object,System.String)">
            <summary>
            Creates a search result from an object, given an optional display value.
            </summary>
            <param name="value">The object to use as a result.</param>
            <param name="displayText">The display text for the result.  If null, the value's ToString() method will be called</param>
            <returns>a search result</returns>
        </member>
        <member name="M:PowerArgs.Cli.ContextAssistSearchResult.FromObject(System.Object,PowerArgs.ConsoleString)">
            <summary>
            Creates a search result from an object, given an optional display value.
            </summary>
            <param name="value">The object to use as a result.</param>
            <param name="displayText">The display text for the result.  If null, the value's ToString() method will be called</param>
            <returns>a search result</returns>
        </member>
        <member name="T:PowerArgs.Cli.IContextAssistProvider">
            <summary>
            An interface you can implement to inject custom contextually aware command line helpers.  PowerArgs provides a few out of the box, but
            you are free to create your own. 
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.IContextAssistProvider.CanAssist(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            Determines if this assistant provider can assist given context about what the user has typed on the command line so far.
            </summary>
            <param name="context">context about what the user has typed on the command line so far</param>
            <returns>true if your provider can assist, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.Cli.IContextAssistProvider.DrawMenu(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            Draws the provider's menu.  You can be sure that PowerArgs has called CanAssist and received a value of true before it will call this
            method.
            </summary>
            <param name="context">context about what the user has typed on the command line so far</param>
            <returns>You can choose to return a result right away if you handle keyboard input manually in your drawing function</returns>
        </member>
        <member name="M:PowerArgs.Cli.IContextAssistProvider.ClearMenu(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            Clears the provider's menu.  This gets called if the user cancel's the assistance via the escape key or if your
            provider returns a terminal result when handling keyboard input.
            </summary>
            <param name="context">context about what the user has typed on the command line so far</param>
        </member>
        <member name="M:PowerArgs.Cli.IContextAssistProvider.OnKeyboardInput(PowerArgs.Cli.RichCommandLineContext,System.ConsoleKeyInfo)">
            <summary>
            Called when your provider is visible and the user provides keyboard input.  All keys will be forwarded to your provider.  Unless you
            have a really good reason you should return a cancel result when you encounter the escape key and you should use the enter key as your
            selection mechanism.  If you returned a terminating result in your DrawMenu() function then this will never get called.
            </summary>
            <param name="context">context about what the user has typed on the command line so far</param>
            <param name="keyPress">Information about the key that was pressed</param>
            <returns>You should return the appropriate result based on how you've decided to handle the keypress.</returns>
        </member>
        <member name="T:PowerArgs.Cli.MultiContextAssistProvider">
            <summary>
            A context assist provider that wraps a collection of inner providers.  
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.MultiContextAssistProvider.Providers">
            <summary>
            The inner providers that will be cycled through whenever assistance is requested
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.MultiContextAssistProvider.CurrentProvider">
            <summary>
            Gets the current provider
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.MultiContextAssistProvider.#ctor">
            <summary>
            Initializes the provider
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.MultiContextAssistProvider.DrawMenu(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            Draws the current provider's menu
            </summary>
            <param name="context">passed to the current provider</param>
            <returns>the inner provider's result</returns>
        </member>
        <member name="M:PowerArgs.Cli.MultiContextAssistProvider.ClearMenu(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            Clears the current provider's menu
            </summary>
            <param name="context">passed to the current provider</param>
        </member>
        <member name="M:PowerArgs.Cli.MultiContextAssistProvider.OnKeyboardInput(PowerArgs.Cli.RichCommandLineContext,System.ConsoleKeyInfo)">
            <summary>
            Passes the keyboard input to the current provider
            </summary>
            <param name="context">passed to the current provider</param>
            <param name="keyPress">passed to the current provider</param>
            <returns>the current provider's result</returns>
        </member>
        <member name="M:PowerArgs.Cli.MultiContextAssistProvider.CanAssist(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            Cycles through the inner providers and calls their CanAssist method until one of them returns true.
            If that happens, the first to return true is promoted to be the current provider.
            </summary>
            <param name="context">passed to inner providers to see if they can assist</param>
            <returns>true if one of the inner providers can assist, false otherwise</returns>
        </member>
        <member name="T:PowerArgs.Cli.IKeyHandler">
            <summary>
            An interface that defines the contract for how key presses get handled within the RichTextCommandLineReader context
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.IKeyHandler.KeysHandled">
            <summary>
            Gets the list of keys that are handled by this handler
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.IKeyHandler.Handle(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            This will be called when the user presses one of the keys defined by KeysHandled.
            </summary>
            <param name="context">Context that lets you inspect the current state of the command line and modify it</param>
        </member>
        <member name="T:PowerArgs.Cli.KeyHandler">
            <summary>
            A class that lets you dynamically create key handlers
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.KeyHandler.KeysHandled">
            <summary>
            Gets the keys handled by this handler
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.KeyHandler.Handler">
            <summary>
            gets the action that implements the handler functionality
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.KeyHandler.FromAction(System.Action{PowerArgs.Cli.RichCommandLineContext},System.ConsoleKey[])">
            <summary>
            Creates a key handler from the given action
            </summary>
            <param name="handler">the handler action code</param>
            <param name="keysHandled">the keys that this handler handles</param>
            <returns>the handler</returns>
        </member>
        <member name="M:PowerArgs.Cli.KeyHandler.Handle(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            Calls the handler action code
            </summary>
            <param name="context">context from the parent reader</param>
        </member>
        <member name="T:PowerArgs.Cli.ITabCompletionHandler">
            <summary>
            An interface that defines the contract for tab completion in the context of a RichTextCommandLineReader.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ITabCompletionHandler.TryTabComplete(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            When the user presses the tab key in the context of a RichTextCommandLineReader's read operation, registered
            tab completion handlers will have this method invoked, in order.  Handlers should return true if they've updated the
            context by performing a successful tab completion.  They should return false if they have not.  Processing stops as soon
            as any handler returns true.
            </summary>
            <param name="context">Context you can use to inspect the current command line to perform tab completion</param>
            <returns>true if you've updated the context and performed a successful tab completion, false otherwise</returns>
        </member>
        <member name="T:PowerArgs.Cli.TabKeyHandler">
            <summary>
            The built in tab key handler
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.TabKeyHandler.KeysHandled">
            <summary>
            gets a collection that only contains ConsoleKey.Tab
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.TabKeyHandler.ThrowOnTabCompletionHandlerException">
            <summary>
            Gets or sets whether or not to propagate exceptions thrown by tab completion highlighters.  The default is false.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.TabKeyHandler.TabCompletionHandlers">
            <summary>
            Gets the list of registered tab completion handlers.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.TabKeyHandler.#ctor">
            <summary>
            Creates a new tab key handler.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.TabKeyHandler.Handle(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            Handles the tab key by calling all registered tab completion handlers.
            </summary>
            <param name="context">Context that can be used to inspect the current command line to perform tab completion</param>
        </member>
        <member name="T:PowerArgs.Cli.RichCommandLineContext">
            <summary>
            A class that provides context for consumers of the RichTextCommandLineReader
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.DisableConsoleRefresh">
            <summary>
            For now this is here to support the mode when this context is used within a ConsoleApp.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.Console">
            <summary>
            Gets the console implementation that's being used to read the input
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.Buffer">
            <summary>
            The current buffer of characters on the command line.  If you manipulate the buffer during tab completion or other key handling
            then you should call RefreshConsole() or ReplaceConsole() so that the updates get reflected.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.KeyPressed">
            <summary>
            The key that was last pressed and is currently being processed.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.Intercept">
            <summary>
            You should set this flag if your handler is goind to take care of updating the console manually.  If false, the reader will
            apply the keypress to the console automatically.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.HistoryManager">
            <summary>
            Gets a reference to the history manager that contains previous command line values.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.CharacterToWrite">
            <summary>
            Gets a reference to the character that is about to be written
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.IsFinished">
            <summary>
            You should set this to true if you want to commit the line being read.  Typically this is only set by the enter key handler.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.ConsoleStartLeft">
            <summary>
            Gets the value of the cursor left position when the read operation began
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.ConsoleStartTop">
            <summary>
            Gets the value of the cursor top position when the read operation began
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.BufferPosition">
            <summary>
            Gets the cursor position, relative to the buffer as opposed to the absolute left and right positions within the console.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.Tokens">
            <summary>
            Gets the tokens that were last parsed.  This is not always populated for you since not all key handlers require tokenizing
            the input.  If you need this in your handler then first call RefreshTokenInfo().
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.Tokenizer">
            <summary>
            Gets the tokenizer used to tokenize command line input.  By default it knows how to handle string literals and escape
            sequences that are appropriate for a command line.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.CurrentToken">
            <summary>
            Gets the token that maps to the current BufferPosition. This is not always populated for you since not all key handlers require tokenizing
            the input.  If you need this in your handler then first call RefreshTokenInfo().
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.CurrentTokenIndex">
            <summary>
            Gets the index of the current token within the list of tokens.  This is not always populated for you since not all key handlers require tokenizing
            the input.  If you need this in your handler then first call RefreshTokenInfo().
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.PreviousNonWhitespaceToken">
            <summary>
            Gets the non whitespace token that comes immediately before the current token, or null if there is no previous non whitespace token.  This is not always populated for you since not all key handlers require tokenizing
            the input.  If you need this in your handler then first call RefreshTokenInfo().
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.RichCommandLineContext.GetBufferSubstringFromToken(PowerArgs.Token)">
            <summary>
            Returns the portion of the buffer represented by the given token
            </summary>
            <param name="t">the token whose position to use to look into the buffer</param>
            <returns>the portion of the buffer represented by the given token</returns>
        </member>
        <member name="M:PowerArgs.Cli.RichCommandLineContext.ClearConsole">
            <summary>
            Clears the console
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.RichCommandLineContext.RefreshConsole(System.Int32,System.Int32)">
            <summary>
            Rewrites the console using the latest values in the Buffer, preserving the cursor position with an optional adjustment.  
            </summary>
            <param name="leftAdjust">Adjusts the left cursor position by the desired amound.  If you want the cursor to stay where it was then use 0.</param>
            <param name="topAdjust">Adjusts the top cursor position by the desired amound.  If you want the cursor to stay where it was then use 0.</param>
        </member>
        <member name="M:PowerArgs.Cli.RichCommandLineContext.ReplaceConsole(PowerArgs.ConsoleString)">
            <summary>
            Rewrites the console using the latest values in the Buffer and moves the cursor to the end of the line.
            </summary>
            <param name="newBuffer">The new line of text that will replace the current buffer.</param>
        </member>
        <member name="M:PowerArgs.Cli.RichCommandLineContext.RefreshTokenInfo(System.Boolean)">
            <summary>
            Runs the tokenizer if it hasn't already been run on the current key press.  You can pass a force flag if you want to
            force the tokenizer to run.  You would need to do this only if you've manually changed the buffer within your handler.
            </summary>
            <param name="force">If true, then the tokenizer is run no matter what.  If false, the tokenizer only runs if it hasn't yet run on this keystroke.</param>
        </member>
        <member name="M:PowerArgs.Cli.RichCommandLineContext.WriteCharacterForPressedKey">
            <summary>
            Takes the value of KeyPressed.KeyChar and writes it to the console in the current buffer position.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.RichCommandLineContext.CompleteCurrentToken(PowerArgs.Token,PowerArgs.ConsoleString)">
            <summary>
            Performs an auto complete of the given token.
            </summary>
            <param name="currentToken">the token to complete</param>
            <param name="completion">the completed token.  Note that it is not required that the completion string starts with the current token value, though it usually does.</param>
        </member>
        <member name="T:PowerArgs.Cli.RichTextCommandLineReader">
            <summary>
            A utility that lets you prompt a console user for input in an interactive way.  It provides hooks for tab completion, syntax highlighting, history management via the up and down arrows, etc.
            </summary>
        </member>
        <member name="E:PowerArgs.Cli.RichTextCommandLineReader.AfterReadKey">
            <summary>
            An event that fires after the user enters a key.  The event will not fire for
            terminating keystrokes
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichTextCommandLineReader.Console">
            <summary>
            The console implementation to target
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichTextCommandLineReader.RegisteredKeyHandlers">
            <summary>
            Gets a read only collection of currently registered key handlers.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichTextCommandLineReader.Highlighter">
            <summary>
            Gets or sets the highlighter used to highlight tokens as the user types
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichTextCommandLineReader.TabHandler">
            <summary>
            Gets the tab hey handler.  This will let you plug in custom tab completion logic.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichTextCommandLineReader.ContextAssistProvider">
            <summary>
            Gets or sets the context assit provider that should be used for this reader
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichTextCommandLineReader.HistoryManager">
            <summary>
            Gets the history manager.  This will let you add your historical command line values so that end users can cycle through them using the up and down arrows.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichTextCommandLineReader.ThrowOnSyntaxHighlightException">
            <summary>
            Gets or sets whether or not to propagate exceptions thrown by syntax highlighters.  The default is false.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichTextCommandLineReader.SyncLock">
            <summary>
            Gets or sets the object to use to synchronize reading with other threads that are interacting with the console
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.RichTextCommandLineReader.#ctor">
            <summary>
            Creates a new reader.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.RichTextCommandLineReader.RegisterHandler(PowerArgs.Cli.IKeyHandler)">
            <summary>
            Lets you register a custom key handler. You are responsible for ensuring that each key is only handled by one handler.  This method will throw if
            you try to add a duplicate key handler.
            </summary>
            <param name="handler">The handler to register</param>
        </member>
        <member name="M:PowerArgs.Cli.RichTextCommandLineReader.UnregisterHandler(PowerArgs.Cli.IKeyHandler)">
            <summary>
            Unregisters the given key handler from the reader.  You should only do this if you're planning on overriding the default handlers, and you should do so
            with caution.
            </summary>
            <param name="handler">The handler to unregister</param>
        </member>
        <member name="M:PowerArgs.Cli.RichTextCommandLineReader.UnregisterHandler(System.ConsoleKey)">
            <summary>
            Unregisters the handler for the given key
            </summary>
            <param name="key">the key to unregister</param>
            <returns>true if there was a handler registered and removed, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.Cli.RichTextCommandLineReader.ReadCommandLine(PowerArgs.ConsoleString)">
            <summary>
            Reads a line of text from the console and converts it into a string array that has accounted for escape sequences and quoted string literals.
            </summary>
            <param name="initialBuffer">Optionally seed the prompt with an initial value that the end user can modify</param>
            <returns>the command line that was read</returns>
        </member>
        <member name="M:PowerArgs.Cli.RichTextCommandLineReader.ReadLine(PowerArgs.ConsoleString)">
            <summary>
            Reads a line of text from the console.  Any interactions you've configured before calling this method will be in effect.
            </summary>
            <param name="initialBuffer">Optionally seed the prompt with an initial value that the end user can modify</param>
            <returns>a line of text from the console</returns>
        </member>
        <member name="M:PowerArgs.Cli.RichTextCommandLineReader.IsWriteable(System.ConsoleKeyInfo)">
            <summary>
            Determines if the given key is writable text
            </summary>
            <param name="info">the key info</param>
            <returns>true if the given key is writable text, false otherwise</returns>
        </member>
        <member name="P:PowerArgs.Cli.RichTextEditor.Highlighter">
            <summary>
            Gets or sets the highlighter used to highlight tokens as the user types
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichTextEditor.TabHandler">
            <summary>
            Gets the tab hey handler.  This will let you plug in custom tab completion logic.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichTextEditor.RegisteredKeyHandlers">
            <summary>
            Gets a read only collection of currently registered key handlers.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichTextEditor.ContextAssistProvider">
            <summary>
            Gets or sets the context assit provider that should be used for this reader
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.RichTextEditor.RegisterHandler(PowerArgs.Cli.IKeyHandler)">
            <summary>
            Lets you register a custom key handler. You are responsible for ensuring that each key is only handled by one handler.  This method will throw if
            you try to add a duplicate key handler.
            </summary>
            <param name="handler">The handler to register</param>
        </member>
        <member name="M:PowerArgs.Cli.RichTextEditor.RegisterKeyPress(System.ConsoleKeyInfo,System.Nullable{PowerArgs.ConsoleCharacter})">
            <summary>
            Registers a keypress with the editor.
            </summary>
            <param name="key">The key press info</param>
            <param name="prototype">if specified, the foreground and background color will be taken from this prototype, otherwise the system defaults will be used</param>
        </member>
        <member name="T:PowerArgs.Cli.HighlighterContext">
            <summary>
            Context about a token that helps determine if it should be highlighted
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.HighlighterContext.CurrentTokenIndex">
            <summary>
            The index of this token within the set of tokens in the base context
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.HighlighterContext.CurrentToken">
            <summary>
            The token that may or may not need to be highlighted
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.HighlighterContext.IsLastToken">
            <summary>
            True if this is the last token, false otherwise
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.SimpleSyntaxHighlighter">
            <summary>
            A utility that makes it easy to perform common types of syntax highlighting based on keywords, regular expressions, etc.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.SimpleSyntaxHighlighter.#ctor">
            <summary>
            Creates a new SimpleSyntaxHighlighter
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.SimpleSyntaxHighlighter.AddKeyword(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor},System.StringComparison)">
            <summary>
            Registers a keyword with the highlighter.
            </summary>
            <param name="keyword">The keyword that will be highlighted when found on the command line</param>
            <param name="fg">The foreground highlight color</param>
            <param name="bg">The background highlight color</param>
            <param name="comparison">Determines how strings are compared. </param>
        </member>
        <member name="M:PowerArgs.Cli.SimpleSyntaxHighlighter.AddConditionalKeyword(System.String,System.Func{PowerArgs.Cli.RichCommandLineContext,PowerArgs.Cli.HighlighterContext,System.Boolean},System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor},System.StringComparison)">
            <summary>
            Registers a keyword with the highlighter that should only be highlighted if some condition is true
            </summary>
            <param name="keyword">The keyword that will conditionally be highlighted when found on the command line</param>
            <param name="conditionEval">the conditional evaluation function</param>
            <param name="fg">The foreground highlight color</param>
            <param name="bg">The background highlight color</param>
            <param name="comparison">Determines how strings are compared. </param>
        </member>
        <member name="M:PowerArgs.Cli.SimpleSyntaxHighlighter.AddRegex(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Registers a regular expression with the highlighter. Tokens that exactly match the given regex will be highlighted.
            </summary>
            <param name="regex">the regular expression pattern to search for</param>
            <param name="fg">The foreground highlight color</param>
            <param name="bg">The background highlight color</param>
        </member>
        <member name="M:PowerArgs.Cli.SimpleSyntaxHighlighter.AddTokenHighlighter(PowerArgs.Cli.ITokenHighlighter)">
            <summary>
            Registers a custom token highlighter
            </summary>
            <param name="highlighter">the custom highlighter</param>
        </member>
        <member name="M:PowerArgs.Cli.SimpleSyntaxHighlighter.SetQuotedStringLiteralHighlight(System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Lets you control how quoted string literals should be highlighted
            </summary>
            <param name="fg">The foreground highlight color</param>
            <param name="bg">The background highlight color</param>
        </member>
        <member name="M:PowerArgs.Cli.SimpleSyntaxHighlighter.SetNumericHighlight(System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Lets you control how numeric values should be highlighted
            </summary>
            <param name="fg">The foreground highlight color</param>
            <param name="bg">The background highlight color</param>
        </member>
        <member name="M:PowerArgs.Cli.SimpleSyntaxHighlighter.TryHighlight(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            The implementation of ISyntaxHighlighter that uses the configuration you've created to perform syntax highlighting.
            </summary>
            <param name="readerContext">Context that is used internally</param>
            <returns>true if any highlighting changes were made, false otherwise</returns>
        </member>
        <member name="T:PowerArgs.Cli.IHighlighterConfigurator">
            <summary>
            An interface that defines how to dynamically configure a highlighter
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.IHighlighterConfigurator.Configure(PowerArgs.Cli.SimpleSyntaxHighlighter)">
            <summary>
            Lets implementors configure a highlighter in a dynamic way
            </summary>
            <param name="highlighter">The highlighter to configure</param>
        </member>
        <member name="T:PowerArgs.Cli.ITokenHighlighter">
            <summary>
            An interface the defines the contract for how individual tokens get syntax highlighting on the command line
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ITokenHighlighter.ShouldBeHighlighted(PowerArgs.Cli.RichCommandLineContext,PowerArgs.Cli.HighlighterContext)">
            <summary>
            Determines if this highlighter should highlight the current token with this highlighter's foreground and background
            colors.  
            </summary>
            <param name="readerContext">context from the reader</param>
            <param name="highlighterContext">context about the current token</param>
            <returns>true if this highlighter should highlight the current token, false otherwise</returns>
        </member>
        <member name="P:PowerArgs.Cli.ITokenHighlighter.HighlightForegroundColor">
            <summary>
            The foreground color of this highlighter.  If null, the console default is used.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ITokenHighlighter.HighlightBackgroundColor">
            <summary>
            The background color of this highlighter.  If null, the console default is used.
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.FixedHighlightTokenHighlighter">
            <summary>
            A highlighter that has a fixed foreground and background color.  Most highlighters derive from this base.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.FixedHighlightTokenHighlighter.HighlightForegroundColor">
            <summary>
            The foreground color of this highlighter.  If null, the console default is used.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.FixedHighlightTokenHighlighter.HighlightBackgroundColor">
            <summary>
            The background color of this highlighter.  If null, the console default is used.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.FixedHighlightTokenHighlighter.#ctor(System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Creates a new highlighter using the given colors
            </summary>
            <param name="fg">The foreground color of this highlighter.  If null, the console default is used.</param>
            <param name="bg">The background color of this highlighter.  If null, the console default is used.</param>
        </member>
        <member name="M:PowerArgs.Cli.FixedHighlightTokenHighlighter.ShouldBeHighlighted(PowerArgs.Cli.RichCommandLineContext,PowerArgs.Cli.HighlighterContext)">
            <summary>
            Determines if this highlighter should highlight the current token with this highlighter's foreground and background
            colors.  
            </summary>
            <param name="readerContext">context from the reader</param>
            <param name="highlighterContext">context about the current token</param>
            <returns>true if this highlighter should highlight the current token, false otherwise</returns>
        </member>
        <member name="T:PowerArgs.Cli.KeywordHighlighter">
            <summary>
            A highlighter that is used to highlight a specific keyword
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.KeywordHighlighter.keyword">
            <summary>
            The keyword to highlight whenever it is found
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.KeywordHighlighter.#ctor(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor},System.StringComparison)">
            <summary>
            Creates the highlighter.
            </summary>
            <param name="keyword">The keyword to highlight whenever it is found</param>
            <param name="fg">The foreground color of this highlighter.  If null, the console default is used.</param>
            <param name="bg">The background color of this highlighter.  If null, the console default is used.</param>
            <param name="comparison">determines how strings are compared.  By default the comparison is case sensitive</param>
        </member>
        <member name="M:PowerArgs.Cli.KeywordHighlighter.ShouldBeHighlighted(PowerArgs.Cli.RichCommandLineContext,PowerArgs.Cli.HighlighterContext)">
            <summary>
            Returns true if the keyword is matched, false otherwise
            </summary>
            <param name="readerContext">context from the reader</param>
            <param name="highlighterContext">context about the current token</param>
            <returns>true if the keyword matched, false otherwise</returns>
        </member>
        <member name="T:PowerArgs.Cli.ConditionalKeywordHighlighter">
            <summary>
            A keyword highlighter that highlights based on a condition
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ConditionalKeywordHighlighter.#ctor(System.String,System.Func{PowerArgs.Cli.RichCommandLineContext,PowerArgs.Cli.HighlighterContext,System.Boolean},System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor},System.StringComparison)">
            <summary>
            Creates the highlighter.
            </summary>
            <param name="keyword">The keyword to match</param>
            <param name="conditionEval">The conditional match evaluation function</param>
            <param name="fg">The foreground color of this highlighter.  If null, the console default is used.</param>
            <param name="bg">The background color of this highlighter.  If null, the console default is used.</param>
            <param name="comparison">determines how characters are compared</param>
        </member>
        <member name="M:PowerArgs.Cli.ConditionalKeywordHighlighter.ShouldBeHighlighted(PowerArgs.Cli.RichCommandLineContext,PowerArgs.Cli.HighlighterContext)">
            <summary>
            Returns true if the token matches the keyword and the given conditional evaluation returns true
            </summary>
            <param name="readerContext">context from the reader</param>
            <param name="highlighterContext">context about the current token</param>
            <returns>true if the token matches the keyword and the given conditional evaluation returns true</returns>
        </member>
        <member name="T:PowerArgs.Cli.RegexHighlighter">
            <summary>
            A highlighter that highlights based on a regular expression match
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.RegexHighlighter.#ctor(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Creates the highlighter
            </summary>
            <param name="pattern">The regular expression pattern</param>
            <param name="fg">The foreground color of this highlighter.  If null, the console default is used.</param>
            <param name="bg">The background color of this highlighter.  If null, the console default is used.</param>
        </member>
        <member name="M:PowerArgs.Cli.RegexHighlighter.ShouldBeHighlighted(PowerArgs.Cli.RichCommandLineContext,PowerArgs.Cli.HighlighterContext)">
            <summary>
            Returns true if the regular expression is matched, false otherwise
            </summary>
            <param name="readerContext">context from the reader</param>
            <param name="highlighterContext">context about the current token</param>
            <returns>true if the regular expression is matched, false otherwise</returns>
        </member>
        <member name="T:PowerArgs.Cli.StringLiteralHighlighter">
            <summary>
            A highlighter that highlights double quoted string literals
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.StringLiteralHighlighter.#ctor(System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Creates the highlighter
            </summary>
            <param name="fg">The foreground color of this highlighter.  If null, the console default is used.</param>
            <param name="bg">The background color of this highlighter.  If null, the console default is used.</param>
        </member>
        <member name="T:PowerArgs.Cli.NumericHighlighter">
            <summary>
            A highlighter that highlights numeric values
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.NumericHighlighter.#ctor(System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Creates the highlighter
            </summary>
            <param name="fg">The foreground color of this highlighter.  If null, the console default is used.</param>
            <param name="bg">The background color of this highlighter.  If null, the console default is used.</param>
        </member>
        <member name="M:PowerArgs.Cli.NumericHighlighter.ShouldBeHighlighted(PowerArgs.Cli.RichCommandLineContext,PowerArgs.Cli.HighlighterContext)">
            <summary>
            Returns true if the current token is a numeric value, false otherwise
            </summary>
            <param name="readerContext">context from the reader</param>
            <param name="highlighterContext">context about the current token</param>
            <returns>true if the current token is a numeric value, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.Games.GameApp.#ctor">
            <summary>
            Creates the app
            </summary>
        </member>
        <member name="P:PowerArgs.Games.GameApp.SceneFactory">
            <summary>
            Set the factory that will be used to hydrate levels
            </summary>
        </member>
        <member name="M:PowerArgs.Games.GameApp.AfterLevelLoaded(PowerArgs.Games.Level)">
            <summary>
            This is called at the end of every level load. It is a good time to apply game state. This is called from the SpaceTime
            thread so you can safely interact with the game elements.
            </summary>
            <param name="l"></param>
        </member>
        <member name="M:PowerArgs.Games.GameApp.BeforeLevelUnloaded">
            <summary>
            This is called just before levels are unloaded. It is a good time to store
            your game state. This is called from the SpaceTime thread so you can safely 
            interact with the game elements.
            </summary>
        </member>
        <member name="T:PowerArgs.Games.MultiPlayerServer">
            <summary>
            Manages communication between clients
            </summary>
        </member>
        <member name="T:PowerArgs.Games.Sound">
            <summary>
            The main API for playing sound in PowerArgs games. By default it is configured with a No op provider that will not play any sound.
            
            If you want sound and are on Windows then you must make your project a ull .NET project that can reference WindowsBase, PresentationCore, and PresentationFramework.
            Then you can use the WindowsSoundProvider that implements ISoundProvider by creating an instance of WindowsSoundProvider.SoundProvider and assigning it to Sound.Provider.
            
            I have not yet figured out how to make sound work in .NET Core.
            
            </summary>
        </member>
        <member name="F:PowerArgs.Games.Sound.Provider">
            <summary>
            The current provider, by default a no op that does not play sound
            </summary>
        </member>
        <member name="M:PowerArgs.Games.Sound.Play(System.String)">
            <summary>
            Plays the sound associated with the given id immediately and once
            </summary>
            <param name="soundId">a sound id</param>
        </member>
        <member name="M:PowerArgs.Games.Sound.Loop(System.String)">
            <summary>
            Plays the sound associated with the given id immidiately and in a loop
            </summary>
            <param name="soundId">a sound id</param>
            <returns>a promist to a disposable that can be used to stop the loop</returns>
        </member>
        <member name="M:PowerArgs.Games.Sound.Dispose">
            <summary>
            Disposes the current provider and resets the provider to a no op provider
            </summary>
        </member>
        <member name="T:PowerArgs.Games.ISoundProvider">
            <summary>
            The interface for playing sound in PowerArgs games
            </summary>
        </member>
        <member name="M:PowerArgs.Games.ISoundProvider.Play(System.String)">
            <summary>
            Plays the sound associated with the given id immediately and once
            </summary>
            <param name="soundId">a sound id</param>
        </member>
        <member name="M:PowerArgs.Games.ISoundProvider.Loop(System.String)">
            <summary>
            Plays the sound associated with the given id immidiately and in a loop
            </summary>
            <param name="soundId">a sound id</param>
            <returns>a promist to a disposable that can be used to stop the loop</returns>
        </member>
        <member name="T:PowerArgs.Games.NoOpSoundProvider">
            <summary>
            A sound provider that does not play sound
            </summary>
        </member>
        <member name="M:PowerArgs.Games.NoOpSoundProvider.Dispose">
            <summary>
            Does nothing
            </summary>
        </member>
        <member name="M:PowerArgs.Games.NoOpSoundProvider.Play(System.String)">
            <summary>
            Does nothing
            </summary>
            <param name="soundId">unused</param>
        </member>
        <member name="M:PowerArgs.Games.NoOpSoundProvider.Loop(System.String)">
            <summary>
            Does nothing
            </summary>
            <param name="soundId">unused</param>
            <returns>a promise that resolves immediately to a dummy disposable</returns>
        </member>
        <member name="T:PowerArgs.Games.DarkTheme">
            <summary>
            A dark theme
            </summary>
        </member>
        <member name="M:PowerArgs.Games.DarkTheme.#ctor">
            <summary>
            Creates the theme
            </summary>
        </member>
        <member name="T:PowerArgs.Games.DefaultTheme">
            <summary>
            The default theme
            </summary>
        </member>
        <member name="M:PowerArgs.Games.DefaultTheme.#ctor">
            <summary>
            Creates the theme
            </summary>
        </member>
        <member name="T:PowerArgs.Games.Theme">
            <summary>
            Defines a set of theming rules that can target specific renderer types
            </summary>
        </member>
        <member name="M:PowerArgs.Games.Theme.Bind(PowerArgs.Cli.ConsoleApp)">
            <summary>
            Binds this theme to the given app. It will process every renderer currently in the app. As long as this theme is alive (not disposed) it will also listen for new
            controls added to the app and process new renderers too.
            </summary>
            <param name="app">The app to bind to</param>
        </member>
        <member name="M:PowerArgs.Games.Theme.Add``1(System.Action{``0})">
            <summary>
            Adds a new rule that will be applied to every instance of T in the visual tree
            </summary>
            <typeparam name="T">the type of renderer to target</typeparam>
            <param name="themeAction">the theming action to take on the rendrer</param>
        </member>
        <member name="T:PowerArgs.Games.ThemeAwareSpacialElementRenderer">
            <summary>
            A renderer that can be themed
            </summary>
        </member>
        <member name="T:PowerArgs.Games.SingleStyleRenderer">
            <summary>
            A themeable renderer that has a uniform style
            </summary>
        </member>
        <member name="T:PowerArgs.ContextAssistSearch">
            <summary>
            A context assist provider that lets a user search for an option.  The class is abstract.  Implementors just need to define the search implementation
            and this class will do the rest.
            </summary>
        </member>
        <member name="F:PowerArgs.ContextAssistSearch.parentReaderContext">
            <summary>
            context about the parent reader that is only populated when used by a parent reader.
            </summary>
        </member>
        <member name="P:PowerArgs.ContextAssistSearch.FetchResultsFailed">
            <summary>
            An event that fires when the fetching search results fails. When this happens the search will swallow the excpetion and simply 
            show no results to the user.
            </summary>
        </member>
        <member name="P:PowerArgs.ContextAssistSearch.SelectedValue">
            <summary>
            Gets the most recent search result that was selected and committed by the user
            </summary>
        </member>
        <member name="P:PowerArgs.ContextAssistSearch.SupportsAsync">
            <summary>
            True indicates that the derived class has implemented GetResultsAsync(), which will be called by the base class.  If false then
            the base class will call GetResults() and will never call GetResultsAsync() so you can choose not to implement it.
            </summary>
        </member>
        <member name="M:PowerArgs.ContextAssistSearch.#ctor">
            <summary>
            Initializes the search assist class
            </summary>
        </member>
        <member name="M:PowerArgs.ContextAssistSearch.GetResults(System.String)">
            <summary>
            When implemented in the derived class, gets search results that match the search string.  This ONLY gets called if SupportsAsync returns false.
            </summary>
            <param name="searchString">the search string entered by the user</param>
            <returns>the search results as a list of strings</returns>
        </member>
        <member name="M:PowerArgs.ContextAssistSearch.GetResultsAsync(System.String)">
            <summary>
            When implemented in the derived class, gets search results that match the search string asynchronously.  This ONLY gets called if SupportsAsync returns true.
            </summary>
            <param name="searchString">the search string entered by the user</param>
            <returns>an async task that will return the search results as a list of strings</returns>
        </member>
        <member name="M:PowerArgs.ContextAssistSearch.CanAssist(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            Always returns true.  When overrided in a derived class the derived class can provide custom logic to determine whether or not this assist provider
            can assist.
            </summary>
            <param name="parentContext">context about the parent reader that we may be assisting </param>
            <returns>Always returns true.  When overrided in a derived class the derived class can provide custom logic to determine whether or not this assist provider
            can assist.</returns>
        </member>
        <member name="M:PowerArgs.ContextAssistSearch.OnKeyboardInput(PowerArgs.Cli.RichCommandLineContext,System.ConsoleKeyInfo)">
            <summary>
            This is not implemented because this assist provider always takes over the console during the draw menu.
            </summary>
            <param name="parentReaderContext">not implemented</param>
            <param name="keyPress">not implemented</param>
            <returns>not implemented</returns>
        </member>
        <member name="M:PowerArgs.ContextAssistSearch.DrawMenu(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            Writes the prompt message and takes over the console until the user makes a selection or cancels via the escape key.  This method
            never returns a NoOp result.
            </summary>
            <param name="parentContext">context about the parent reader that we are assisting </param>
            <returns>A selection or cancellation result, never a NoOp</returns>
        </member>
        <member name="M:PowerArgs.ContextAssistSearch.ClearMenu(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            Clears the menu from the console
            </summary>
            <param name="notUsed"></param>
        </member>
        <member name="M:PowerArgs.ContextAssistSearch.Search(PowerArgs.IConsoleProvider,System.Boolean)">
            <summary>
            Performs a standalone search and cleans up the menu at the end.
            </summary>
            <param name="console">Optionally choose a custom console target</param>
            <param name="allowCancel">if true, users can cancel the search by pressing the escape key.  If false, the escape key does nothing.</param>
            <returns>A valid search result or null if the search was cancelled.</returns>
        </member>
        <member name="T:PowerArgs.ArgException">
            <summary>
            An exception that should be thrown when the error condition is caused because of bad user input.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgException.Context">
            <summary>
            The parser context that may be incomplete since it depends on where the exception was thrown
            </summary>
        </member>
        <member name="M:PowerArgs.ArgException.#ctor(System.String)">
            <summary>
            Creates a new ArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
        </member>
        <member name="M:PowerArgs.ArgException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new ArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.InvalidArgDefinitionException">
            <summary>
            An exception that should be thrown when the error condition is caused by an improperly formed
            argument scaffold type.  For example if the user specified the same shortcut value for more than one property.
            </summary>
        </member>
        <member name="M:PowerArgs.InvalidArgDefinitionException.#ctor(System.String)">
            <summary>
            Creates a new InvalidArgDefinitionException given a message.
            </summary>
            <param name="msg">An error message.</param>
        </member>
        <member name="M:PowerArgs.InvalidArgDefinitionException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new InvalidArgDefinitionException given a message.
            </summary>
            <param name="msg">An error message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.UnexpectedArgException">
            <summary>
            An exception that should be thrown when an unexpected named|positional argument is found.
            </summary>
        </member>
        <member name="M:PowerArgs.UnexpectedArgException.#ctor(System.String)">
            <summary>
            Creates a new UnexpectedArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
        </member>
        <member name="M:PowerArgs.UnexpectedArgException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new UnexpectedArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.DuplicateArgException">
            <summary>
            An exception that should be thrown when the same argument is repeated.
            </summary>
        </member>
        <member name="M:PowerArgs.DuplicateArgException.#ctor(System.String)">
            <summary>
            Creates a new DuplicateArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
        </member>
        <member name="M:PowerArgs.DuplicateArgException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new DuplicateArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.MissingArgException">
            <summary>
            An exception that should be thrown when a required argument is missing.
            </summary>
        </member>
        <member name="M:PowerArgs.MissingArgException.#ctor(System.String)">
            <summary>
            Creates a new MissingArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
        </member>
        <member name="M:PowerArgs.MissingArgException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new MissingArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.UnknownActionArgException">
            <summary>
            An exception that should be thrown when an unknown action argument is specified.
            </summary>
        </member>
        <member name="M:PowerArgs.UnknownActionArgException.#ctor(System.String)">
            <summary>
            Creates a new UnknownActionArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
        </member>
        <member name="M:PowerArgs.UnknownActionArgException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new UnknownActionArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.QueryInvalidArgException">
            <summary>
            An exception that should be thrown when the query can not be compiled.
            </summary>
        </member>
        <member name="M:PowerArgs.QueryInvalidArgException.#ctor(System.String)">
            <summary>
            Creates a new QueryInvalidArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
        </member>
        <member name="M:PowerArgs.QueryInvalidArgException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new QueryInvalidArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.ValidationArgException">
            <summary>
            An exception that should be thrown when an argument's value is not valid.
            </summary>
        </member>
        <member name="M:PowerArgs.ValidationArgException.#ctor(System.String)">
            <summary>
            Creates a new ValidationArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
        </member>
        <member name="M:PowerArgs.ValidationArgException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new ValidationArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.CollectionsEx">
            <summary>
            Extension methods for collections
            </summary>
        </member>
        <member name="M:PowerArgs.CollectionsEx.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Executes the given action for each element in the collection
            </summary>
            <typeparam name="T">The type of items in the collection</typeparam>
            <param name="enumerable">the collection</param>
            <param name="a">the action to execute against each item</param>
        </member>
        <member name="M:PowerArgs.CollectionsEx.WhereAs``1(System.Collections.IEnumerable)">
            <summary>
            Filters the collection to only those who are of type TOut and then narrows the IEnumerable type to TOut
            </summary>
            <typeparam name="TOut">The type to narrow to</typeparam>
            <param name="enumerable">the collection to filter and narrow</param>
            <returns>the filtered and narrowed enumerable</returns>
        </member>
        <member name="T:PowerArgs.IConsoleProviderEx">
            <summary>
            Extension methods for IConsoleProvider
            </summary>
        </member>
        <member name="M:PowerArgs.IConsoleProviderEx.TakeSnapshot(PowerArgs.IConsoleProvider)">
            <summary>
            Takes a snapshot that stores the console cursor's current position.
            </summary>
            <param name="console">the console to target</param>
            <returns>a snapshot that stores the console cursor's current position.</returns>
        </member>
        <member name="T:PowerArgs.IArgMetadataEx">
            <summary>
            Extension methods that make it easy to work with metadata collections
            </summary>
        </member>
        <member name="M:PowerArgs.IArgMetadataEx.HasMeta``1(System.Collections.Generic.IEnumerable{PowerArgs.IArgMetadata})">
            <summary>
            Returns true if the given collection of metadata contains metadata of the generic type T
            provided.
            </summary>
            <typeparam name="T">The type of metadata to search for</typeparam>
            <param name="metadata">The list of metadata to search</param>
            <returns>rue if the given collection of metadata contains metadata of the generic type T
            provided, otherwise false</returns>
        </member>
        <member name="M:PowerArgs.IArgMetadataEx.Meta``1(System.Collections.Generic.IEnumerable{PowerArgs.IArgMetadata})">
            <summary>
            Gets the first instance of metadata of the given generic type T in the collection
            or null if it was not found.
            </summary>
            <typeparam name="T">The type of metadata to search for</typeparam>
            <param name="metadata">The list of metadata to search</param>
            <returns>the first instance of an metadata of the given generic type T in the collection
            or null if it was not found</returns>
        </member>
        <member name="M:PowerArgs.IArgMetadataEx.TryGetMeta``1(System.Collections.Generic.IEnumerable{PowerArgs.IArgMetadata},``0@)">
            <summary>
            Try to get the first instance of metadata of the given generic type T in the collection.
            </summary>
            <typeparam name="T">The type of metadata to search for</typeparam>
            <param name="metadata">The list of metadata to search</param>
            <param name="ret">the our variable to set if the metadata was found</param>
            <returns>true if the metadata was found, otherwise false</returns>
        </member>
        <member name="M:PowerArgs.IArgMetadataEx.Metas``1(System.Collections.Generic.IEnumerable{PowerArgs.IArgMetadata})">
            <summary>
            Gets the subset of metadata of the given generic type T from the collection.
            </summary>
            <typeparam name="T">The type of metadata to search for</typeparam>
            <param name="metadata">The list of metadata to search</param>
            <returns>the subset of metadata of the given generic type T from the collection</returns>
        </member>
        <member name="T:PowerArgs.MatchCollectionEx">
            <summary>
            A simple helper that makes it possible to do Linq queries over a MatchCollection
            </summary>
        </member>
        <member name="M:PowerArgs.MatchCollectionEx.ToList(System.Text.RegularExpressions.MatchCollection)">
            <summary>
            Converts a MatchCollection to a List of Match objects so that you can perform linq queries over the matches.
            </summary>
            <param name="matches">The MatchCollection to convert</param>
            <returns>a list of Match objects</returns>
        </member>
        <member name="T:PowerArgs.MemberInfoEx">
            <summary>
            Provides some reflection helpers in the form of extension methods for the MemberInfo type.
            </summary>
        </member>
        <member name="M:PowerArgs.MemberInfoEx.HasAttr``1(System.Reflection.MemberInfo)">
            <summary>
            Returns true if the given member has an attribute of the given type (including inherited types).
            </summary>
            <typeparam name="T">The type of attribute to test for (will return true for attributes that inherit from this type)</typeparam>
            <param name="info">The member to test</param>
            <returns>true if a matching attribute was found, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.MemberInfoEx.Attr``1(System.Reflection.MemberInfo)">
            <summary>
            Gets the attribute of the given type or null if the member does not have this attribute defined.  The standard reflection helper GetCustomAttributes will
            give you a new instance of the attribute every time you call it.  This helper caches it's results so if you ask for the same attibute twice you will actually
            get back the same attribute.  Note that the cache key is based off of the type T that you provide.  So asking for Attr() where T : BaseType> and then asking for Attr() where T : ConcreteType 
            will result in two different objects being returned.  If you ask for Attr() where T : BaseType and then Attr() where T :BaseType the caching will work and you'll get the same object back
            the second time.
            </summary>
            <typeparam name="T">The type of attribute to search for</typeparam>
            <param name="info">The member to inspect</param>
            <returns>The desired attribute or null if it is not present</returns>
        </member>
        <member name="M:PowerArgs.MemberInfoEx.Attrs``1(System.Reflection.MemberInfo)">
            <summary>
            Gets the attributes of the given type.  The standard reflection helper GetCustomAttributes will give you new instances of the attributes every time you call it.  
            This helper caches it's results so if you ask for the same attibutes twice you will actually get back the same attributes.  Note that the cache key is based off 
            of the type T that you provide.  So asking for Attrs() where T : BaseType and then asking for Attrs() where T : ConcreteType
            will result in two different sets of objects being returned.  If you ask for Attrs() where T : BaseType and then Attrs() where T : BaseType the caching will work and you'll get the
            same results back the second time.
            </summary>
            <typeparam name="T">The type of attribute to search for</typeparam>
            <param name="info">The member to inspect</param>
            <returns>The list of attributes that you asked for</returns>
        </member>
        <member name="T:PowerArgs.ParemeterInfoEx">
            <summary>
            Some useful helper extensions for the ParameterInfo type
            </summary>
        </member>
        <member name="M:PowerArgs.ParemeterInfoEx.HasAttr``1(System.Reflection.ParameterInfo)">
            <summary>
            Returns true if the given parameter has an attribute of the given type (including inherited types).
            </summary>
            <typeparam name="T">The type of attribute to test for (will return true for attributes that inherit from this type)</typeparam>
            <param name="info">The parameter to test</param>
            <returns>true if a matching attribute was found, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ParemeterInfoEx.Attr``1(System.Reflection.ParameterInfo)">
            <summary>
            Gets the attribute of the given type or null if the parameter does not have this attribute defined.  The standard reflection helper GetCustomAttributes will
            give you a new instance of the attribute every time you call it.  This helper caches it's results so if you ask for the same attibute twice you will actually
            get back the same attribute.  Note that the cache key is based off of the type T that you provide.  So asking for Attr() where T : BaseType> and then asking for Attr() where T : ConcreteType 
            will result in two different objects being returned.  If you ask for Attr() where T : BaseType and then Attr() where T :BaseType the caching will work and you'll get the same object back
            the second time.
            </summary>
            <typeparam name="T">The type of attribute to search for</typeparam>
            <param name="info">The parameter to inspect</param>
            <returns>The desired attribute or null if it is not present</returns>
        </member>
        <member name="M:PowerArgs.ParemeterInfoEx.Attrs``1(System.Reflection.ParameterInfo)">
            <summary>
            Gets the attributes of the given type.  The standard reflection helper GetCustomAttributes will give you new instances of the attributes every time you call it.  
            This helper caches it's results so if you ask for the same attibutes twice you will actually get back the same attributes.  Note that the cache key is based off 
            of the type T that you provide.  So asking for Attrs() where T : BaseType and then asking for Attrs() where T : ConcreteType
            will result in two different sets of objects being returned.  If you ask for Attrs() where T : BaseType and then Attrs() where T : BaseType the caching will work and you'll get the
            same results back the second time.
            </summary>
            <typeparam name="T">The type of attribute to search for</typeparam>
            <param name="info">The parameter to inspect</param>
            <returns>The list of attributes that you asked for</returns>
        </member>
        <member name="T:PowerArgs.StringEx">
            <summary>
            string extension methods
            </summary>
        </member>
        <member name="M:PowerArgs.StringEx.ToConsoleString(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Converts a string to a ConsoleString
            </summary>
            <param name="s">the string to convert</param>
            <param name="fg">the foreground color to apply to the result</param>
            <param name="bg">the background color to apply to the result</param>
            <returns>a console string</returns>
        </member>
        <member name="M:PowerArgs.StringEx.ToBlack(System.String,System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to black, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="s">the string to use to create the result</param>
            <param name="bg">The new background color for all characters or null to use the console's default</param>
            <returns>a new console string with the desired color attributes</returns>
        </member>
        <member name="M:PowerArgs.StringEx.ToDarkBlue(System.String,System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to dark blue, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="s">the string to use to create the result</param>
            <param name="bg">The new background color for all characters or null to use the console's default</param>
            <returns>a new console string with the desired color attributes</returns>
        </member>
        <member name="M:PowerArgs.StringEx.ToDarkGreen(System.String,System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to dark green, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="s">the string to use to create the result</param>
            <param name="bg">The new background color for all characters or null to use the console's default</param>
            <returns>a new console string with the desired color attributes</returns>
        </member>
        <member name="M:PowerArgs.StringEx.ToDarkCyan(System.String,System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to dark cyan, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="s">the string to use to create the result</param>
            <param name="bg">The new background color for all characters or null to use the console's default</param>
            <returns>a new console string with the desired color attributes</returns>
        </member>
        <member name="M:PowerArgs.StringEx.ToDarkRed(System.String,System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to dark red, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="s">the string to use to create the result</param>
            <param name="bg">The new background color for all characters or null to use the console's default</param>
            <returns>a new console string with the desired color attributes</returns>
        </member>
        <member name="M:PowerArgs.StringEx.ToDarkMagenta(System.String,System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to dark magenta, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="s">the string to use to create the result</param>
            <param name="bg">The new background color for all characters or null to use the console's default</param>
            <returns>a new console string with the desired color attributes</returns>
        </member>
        <member name="M:PowerArgs.StringEx.ToDarkYellow(System.String,System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to dark yellow, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="s">the string to use to create the result</param>
            <param name="bg">The new background color for all characters or null to use the console's default</param>
            <returns>a new console string with the desired color attributes</returns>
        </member>
        <member name="M:PowerArgs.StringEx.ToGray(System.String,System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to gray, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="s">the string to use to create the result</param>
            <param name="bg">The new background color for all characters or null to use the console's default</param>
            <returns>a new console string with the desired color attributes</returns>
        </member>
        <member name="M:PowerArgs.StringEx.ToDarkGray(System.String,System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to dark gray, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="s">the string to use to create the result</param>
            <param name="bg">The new background color for all characters or null to use the console's default</param>
            <returns>a new console string with the desired color attributes</returns>
        </member>
        <member name="M:PowerArgs.StringEx.ToBlue(System.String,System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to blue, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="s">the string to use to create the result</param>
            <param name="bg">The new background color for all characters or null to use the console's default</param>
            <returns>a new console string with the desired color attributes</returns>
        </member>
        <member name="M:PowerArgs.StringEx.ToGreen(System.String,System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to green, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="s">the string to use to create the result</param>
            <param name="bg">The new background color for all characters or null to use the console's default</param>
            <returns>a new console string with the desired color attributes</returns>
        </member>
        <member name="M:PowerArgs.StringEx.ToCyan(System.String,System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to cyan, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="s">the string to use to create the result</param>
            <param name="bg">The new background color for all characters or null to use the console's default</param>
            <returns>a new console string with the desired color attributes</returns>
        </member>
        <member name="M:PowerArgs.StringEx.ToRed(System.String,System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to red, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="s">the string to use to create the result</param>
            <param name="bg">The new background color for all characters or null to use the console's default</param>
            <returns>a new console string with the desired color attributes</returns>
        </member>
        <member name="M:PowerArgs.StringEx.ToMagenta(System.String,System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to magenta, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="s">the string to use to create the result</param>
            <param name="bg">The new background color for all characters or null to use the console's default</param>
            <returns>a new console string with the desired color attributes</returns>
        </member>
        <member name="M:PowerArgs.StringEx.ToYellow(System.String,System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to yellow, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="s">the string to use to create the result</param>
            <param name="bg">The new background color for all characters or null to use the console's default</param>
            <returns>a new console string with the desired color attributes</returns>
        </member>
        <member name="M:PowerArgs.StringEx.ToWhite(System.String,System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to white, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="s">the string to use to create the result</param>
            <param name="bg">The new background color for all characters or null to use the console's default</param>
            <returns>a new console string with the desired color attributes</returns>
        </member>
        <member name="T:PowerArgs.TaskEx">
            <summary>
            Extensions to System.Threading.Tasks.Task
            </summary>
        </member>
        <member name="M:PowerArgs.TaskEx.TimeoutAfter(System.Threading.Tasks.Task,System.TimeSpan,System.String)">
            <summary>
            Creates a new task that will throw a TimeoutException if the initial task fails to complete before the given timeout
            </summary>
            <param name="runningTask">the task to wrap</param>
            <param name="timeout">the amount of time to wait before throwing a TimeoutException</param>
            <param name="timeoutMessage">Optionally control the exception message</param>
            <returns>a new task that will throw a TimeoutException if the initial task fails to complete before the given timeout</returns>
        </member>
        <member name="M:PowerArgs.TaskEx.TimeoutAfter``1(System.Threading.Tasks.Task{``0},System.TimeSpan,System.String)">
            <summary>
            Creates a new task that will throw a TimeoutException if the initial task fails to complete before the given timeout
            </summary>
            <typeparam name="T">The type of result that the task produces</typeparam>
            <param name="runningTask">the task to wrap</param>
            <param name="timeout">the amount of time to wait before throwing a TimeoutException</param>
            <param name="timeoutMessage">Optionally control the exception message</param>
            <returns>a new task, with a result, that will throw a TimeoutException if the initial task fails to complete before the given timeout</returns>
        </member>
        <member name="T:PowerArgs.ArgRevivers">
            <summary>
            A class that knows how to revive .NET objects from strings provided on the command line
            </summary>
        </member>
        <member name="M:PowerArgs.ArgRevivers.CanRevive(System.Type)">
            <summary>
            Returns true if the given type can be revived, false otherwise
            </summary>
            <param name="t">The type to test</param>
            <returns>true if the given type can be revived, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ArgRevivers.Revive(System.Type,System.String,System.String)">
            <summary>
            Revives the given string into the desired .NET type
            </summary>
            <param name="t">The type to revive to</param>
            <param name="name">the name of the argument</param>
            <param name="value">The string value to revive</param>
            <returns>A revived object of the desired type</returns>
        </member>
        <member name="M:PowerArgs.ArgRevivers.SetReviver(System.Type,System.Func{System.String,System.String,System.Object})">
            <summary>
            Sets the reviver function for a given type, overriding any existing reviver that may exist.
            </summary>
            <param name="t">The type of object the reviver function can revive</param>
            <param name="reviverFunc">the function that revives a command line string, converting it into a consumable object</param>
        </member>
        <member name="M:PowerArgs.ArgRevivers.SetReviver``1(System.Func{System.String,System.String,``0})">
            <summary>
            Sets the reviver function for a given type, overriding any existing reviver that may exist.
            </summary>
            <typeparam name="T">The type of object the reviver function can revive</typeparam>
            <param name="reviverFunc">the function that revives a command line string, converting it into a consumable object</param>
        </member>
        <member name="T:PowerArgs.ConsoleOutInterceptor">
            <summary>
            A singleton text writer that can be used to intercept console output.
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleOutInterceptor.IsInitialized">
            <summary>
            returns true if the instance is initialized and is intercepting
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleOutInterceptor.Instance">
            <summary>
            Gets the interceptor, initializing it if needed.  
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleOutInterceptor.Attach">
            <summary>
            Attaches the interceptor to the Console so that it starts intercepting output
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleOutInterceptor.Detatch">
            <summary>
            Detaches the interceptor.  Console output will be written as normal.
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleOutInterceptor.Write(System.Char[],System.Int32,System.Int32)">
            <summary>
            Intercepts the Write event
            </summary>
            <param name="buffer">the string buffer</param>
            <param name="index">the start index</param>
            <param name="count">number of chars to write</param>
        </member>
        <member name="M:PowerArgs.ConsoleOutInterceptor.Write(System.Char)">
            <summary>
            Intercepts the Write event
            </summary>
            <param name="value">the char to write</param>
        </member>
        <member name="M:PowerArgs.ConsoleOutInterceptor.Write(System.String)">
            <summary>
            Intercepts the Write event
            </summary>
            <param name="value">the string to write</param>
        </member>
        <member name="M:PowerArgs.ConsoleOutInterceptor.Write(PowerArgs.ConsoleString)">
            <summary>
            Pretends to intercept a ConsoleString
            </summary>
            <param name="value">the string to intercept</param>
        </member>
        <member name="M:PowerArgs.ConsoleOutInterceptor.ReadAndClear">
            <summary>
            Reads the queued up intercepted characters and then clears the queue as an atomic operation.
            This method is thread safe.
            </summary>
            <returns>The queued up intercepted characters</returns>
        </member>
        <member name="P:PowerArgs.ConsoleOutInterceptor.Encoding">
            <summary>
            Returns System.Text.Encoding.Default
            </summary>
        </member>
        <member name="T:PowerArgs.ExpireableAsyncRequestManager">
            <summary>
            A utility that can be used to implement the following request pattern.  A user starts typing, triggering an async search.  
            While the async search is running, the user continues typing, triggering more searches.  Your goal is to ignore searches that
            are in flight, but are no longer the latest search.  This helper provides a programming model around orchestrating that behavior.
            </summary>
        </member>
        <member name="M:PowerArgs.ExpireableAsyncRequestManager.#ctor">
            <summary>
            Creates a new instance of the helper context
            </summary>
        </member>
        <member name="M:PowerArgs.ExpireableAsyncRequestManager.BeginRequest">
            <summary>
            You should call this from your foreground thread just before starting your async search request.  It will return a unique Id
            that you should make available to your code that runs when your async request completes.
            </summary>
            <returns>a unique Id
            that you should make available to your code that runs when your async request completes</returns>
        </member>
        <member name="M:PowerArgs.ExpireableAsyncRequestManager.EndRequest(System.Action,System.Guid)">
            <summary>
            When your async call is complete, and you have your results, call this method, passing in the action that should
            only be run if two conditions are both true.  1 - The given request Id represents the latest request.  2 - Nobody has
            called ExpireAll() on the context.
            </summary>
            <param name="endAction">the action to invoke only if the context is not expired and the given request id represents the most recent request</param>
            <param name="requestId">The request Id that you got from BeginRequest </param>
        </member>
        <member name="M:PowerArgs.ExpireableAsyncRequestManager.ExpireAll">
            <summary>
            Calling this method will disable end actions for the latest request as well as any future requests.  This is useful if your application
            have moved on to a different context and you want to ignore any pending requests.
            </summary>
        </member>
        <member name="T:PowerArgs.IConsoleProvider">
            <summary>
            An interface that serves as an abstraction layer for a console implementation.  
            </summary>
        </member>
        <member name="P:PowerArgs.IConsoleProvider.KeyAvailable">
            <summary>
            Gets whether or not a key is available to be read
            </summary>
        </member>
        <member name="P:PowerArgs.IConsoleProvider.ForegroundColor">
            <summary>
            Gets or sets the foreground color
            </summary>
        </member>
        <member name="P:PowerArgs.IConsoleProvider.BackgroundColor">
            <summary>
            Gets or sets the backgrund color
            </summary>
        </member>
        <member name="P:PowerArgs.IConsoleProvider.CursorLeft">
            <summary>
            Gets or sets the left position of the console cursor
            </summary>
        </member>
        <member name="P:PowerArgs.IConsoleProvider.CursorTop">
            <summary>
            Gets or sets the top position of the console cursor
            </summary>
        </member>
        <member name="P:PowerArgs.IConsoleProvider.BufferWidth">
            <summary>
            Gets or sets the buffer width of the console
            </summary>
        </member>
        <member name="P:PowerArgs.IConsoleProvider.WindowHeight">
            <summary>
            Gets or sets the window height of the console
            </summary>
        </member>
        <member name="P:PowerArgs.IConsoleProvider.WindowWidth">
            <summary>
            Gets or sets the window width of the console
            </summary>
        </member>
        <member name="M:PowerArgs.IConsoleProvider.Write(System.Object)">
            <summary>
            Write's the string representation of the given object to the console
            </summary>
        </member>
        <member name="M:PowerArgs.IConsoleProvider.WriteLine(System.Object)">
            <summary>
            Write's the string representation of the given object to the console, followed by a newline.
            </summary>
        </member>
        <member name="M:PowerArgs.IConsoleProvider.Write(PowerArgs.ConsoleString)">
            <summary>
            Writes the given console string to the console, preserving formatting
            </summary>
            <param name="consoleString">The string to write</param>
        </member>
        <member name="M:PowerArgs.IConsoleProvider.Write(PowerArgs.ConsoleCharacter)">
            <summary>
            Writes the given character to the console, preserving formatting
            </summary>
            <param name="consoleCharacter">The character to write</param>
        </member>
        <member name="M:PowerArgs.IConsoleProvider.WriteLine(PowerArgs.ConsoleString)">
            <summary>
            Writes the given console string to the console, followed by a newline, preserving formatting.
            </summary>
            <param name="consoleString">The string to write</param>
        </member>
        <member name="M:PowerArgs.IConsoleProvider.WriteLine">
            <summary>
            Writes a newline to the console
            </summary>
        </member>
        <member name="M:PowerArgs.IConsoleProvider.Clear">
            <summary>
            Clears the console window
            </summary>
        </member>
        <member name="M:PowerArgs.IConsoleProvider.Read">
            <summary>
            Reads the next character of input from the console
            </summary>
            <returns>the char or -1 if there is no more input</returns>
        </member>
        <member name="M:PowerArgs.IConsoleProvider.ReadKey(System.Boolean)">
            <summary>
            Reads a key from the console
            </summary>
            <param name="intercept">if true, intercept the key before it is shown on the console</param>
            <returns>info about the key that was pressed</returns>
        </member>
        <member name="M:PowerArgs.IConsoleProvider.ReadKey">
            <summary>
            Reads a key from the console
            </summary>
        </member>
        <member name="M:PowerArgs.IConsoleProvider.ReadLine">
            <summary>
            Reads a line of text from the console
            </summary>
            <returns>a line of text that was read from the console</returns>
        </member>
        <member name="T:PowerArgs.ConsoleProvider">
            <summary>
            The console provider that is used across all of Powerargs
            </summary>
        </member>
        <member name="F:PowerArgs.ConsoleProvider.Current">
            <summary>
            Gets or sets the console implementation that is targeted by PowerArgs.  By default, PowerArgs uses the standard system console.  In theory,
            you can implement a custom version of IConsoleProvider and plug it in here.  Everything should work, but it has not been attempted.  Proceed with caution.
            </summary>
        </member>
        <member name="T:PowerArgs.MatrixMode">
            <summary>
            An effect that makes all command line output get written in a green themed, futuristic fasion.   
            </summary>
        </member>
        <member name="M:PowerArgs.MatrixMode.Start">
            <summary>
            Starts MatrixMode.
            </summary>
            <returns>An action that when invoked stops MatrixMode.</returns>
        </member>
        <member name="T:PowerArgs.StdConsoleProvider">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.  This is basically a wrapper around the system console.
            </summary>
        </member>
        <member name="P:PowerArgs.StdConsoleProvider.ForegroundColor">
            <summary>
            Gets or sets the console foreground color
            </summary>
        </member>
        <member name="P:PowerArgs.StdConsoleProvider.BackgroundColor">
            <summary>
            Gets or sets the console background color
            </summary>
        </member>
        <member name="P:PowerArgs.StdConsoleProvider.CursorLeft">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="P:PowerArgs.StdConsoleProvider.CursorTop">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="P:PowerArgs.StdConsoleProvider.BufferWidth">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.ReadKey">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
            <returns>Used for internal implementation, but marked public for testing, please do not use.</returns>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.Write(System.Object)">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
            <param name="output">Used for internal implementation, but marked public for testing, please do not use.</param>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.WriteLine(System.Object)">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
            <param name="output">Used for internal implementation, but marked public for testing, please do not use.</param>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.WriteLine">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.ReadALineOfConsoleOutput(System.Int32)">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
            <param name="y">Used for internal implementation, but marked public for testing, please do not use.</param>
            <returns>Used for internal implementation, but marked public for testing, please do not use.</returns>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.Clear">
            <summary>
            Clears the console
            </summary>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.Read">
            <summary>
            Reads the next character of input from the console
            </summary>
            <returns>the char or -1 if there is no more input</returns>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.ReadKey(System.Boolean)">
            <summary>
            Reads a key from the console
            </summary>
            <param name="intercept">if true, intercept the key before it is shown on the console</param>
            <returns>info about the key that was pressed</returns>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.ReadLine">
            <summary>
            Reads a line of text from the console
            </summary>
            <returns>a line of text that was read from the console</returns>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.Write(PowerArgs.ConsoleString)">
            <summary>
            Writes the given string to the console
            </summary>
            <param name="consoleString">the string to write</param>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.WriteLine(PowerArgs.ConsoleString)">
            <summary>
            Writes the given string to the console, followed by a newline
            </summary>
            <param name="consoleString">the string to write</param>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.Write(PowerArgs.ConsoleCharacter)">
            <summary>
            Writes the given character to the console
            </summary>
            <param name="consoleCharacter">the character to write</param>
        </member>
        <member name="T:PowerArgs.ActionDebouncer">
            <summary>
            A class that can be used to ensure an action only fires after a burst of triggers ends.
            </summary>
        </member>
        <member name="P:PowerArgs.ActionDebouncer.BurstTimeWindow">
            <summary>
            Gets or sets the burst time window duration used to debounce multiple triggers
            </summary>
        </member>
        <member name="M:PowerArgs.ActionDebouncer.#ctor(System.TimeSpan,System.Action)">
            <summary>
            Creates the debouncer given a bust time window and an action callback.
            </summary>
            <param name="burstTimeWindow">The time span that determines the time window.  When a trigger fires, the debouncer will wait this amount of time before executing the callback.  If a trigger fires before the time elapses, the timer is reset.</param>
            <param name="callback">The action to execute when a trigger fires and the burst time window elapses.</param>
        </member>
        <member name="M:PowerArgs.ActionDebouncer.Trigger">
            <summary>
            Triggers a burst.  If this is the first trigger in a burst of events then a countdown of duration BurstTimeWindow begins.  If this trigger occurs
            while the countdown is in the process of counting to zero then the countdown is reset.  If the countdown ever hits zero then the callback fires
            and the burst is complete.
            </summary>
        </member>
        <member name="T:PowerArgs.AliasCollection">
            <summary>
            This class tracks the command line aliases for a CommandLineArgument and a CommandLineAction.
            It combines the aliases that have been retrieved from the ArgShortcut attibute and any additional
            aliases that may have been added to the model manually into a single collection.  It also makes sure that those two sources
            of aliases don't conflict.
            
            </summary>
        </member>
        <member name="M:PowerArgs.AliasCollection.IndexOf(System.String)">
            <summary>
            Gets the index of the given alias in the collection.
            </summary>
            <param name="item">the alias to look for</param>
            <returns>The index of item if found in the list; otherwise, -1.</returns>
        </member>
        <member name="M:PowerArgs.AliasCollection.Insert(System.Int32,System.String)">
            <summary>
            Not supported
            </summary>
            <param name="index">Not supported</param>
            <param name="item">Not supported</param>
        </member>
        <member name="M:PowerArgs.AliasCollection.RemoveAt(System.Int32)">
            <summary>
            Not supported
            </summary>
            <param name="index">Not supported</param>
        </member>
        <member name="P:PowerArgs.AliasCollection.Item(System.Int32)">
            <summary>
            The setter is not supported.  The getter returns the item at the specified index.
            </summary>
            <param name="index"></param>
            <returns>the item at the specified index</returns>
        </member>
        <member name="M:PowerArgs.AliasCollection.AddRange(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Adds the given aliases to the collection. 
            </summary>
            <param name="items">The alias to add</param>
        </member>
        <member name="M:PowerArgs.AliasCollection.Add(System.String)">
            <summary>
            Adds the given alias to the collection.  An InvalidArgDefinitionException is thrown if you try to add
            the same alias twice (case sensitivity is determined by the CommandLineArgument or CommandLineAction).
            </summary>
            <param name="item">The alias to add</param>
        </member>
        <member name="M:PowerArgs.AliasCollection.Clear">
            <summary>
            Clear is not supported, use ClearOverrides() to clear items that have manually been added
            </summary>
        </member>
        <member name="M:PowerArgs.AliasCollection.ClearOverrides">
            <summary>
            Clears the aliases that have been manually addd to this collection via Add() or AddRange().
            Aliases that are inferred from the Metadata will still be present in the collection. 
            </summary>
        </member>
        <member name="M:PowerArgs.AliasCollection.Contains(System.String)">
            <summary>
            Tests to see if this Alias collection contains the given item.  Case sensitivity is enforced
            based on the CommandLineArgument or CommandLineAction.
            </summary>
            <param name="item">The item to test for containment</param>
            <returns>True if the collection contains the item, otherwise false</returns>
        </member>
        <member name="M:PowerArgs.AliasCollection.CopyTo(System.String[],System.Int32)">
            <summary>
            Copies this collection to an array, starting at the given index
            </summary>
            <param name="array">the destination array</param>
            <param name="arrayIndex">the starting index of where to place the elements into the destination</param>
        </member>
        <member name="P:PowerArgs.AliasCollection.Count">
            <summary>
            Gets the count of aliases
            </summary>
        </member>
        <member name="P:PowerArgs.AliasCollection.IsReadOnly">
            <summary>
            Not read only ever
            </summary>
        </member>
        <member name="M:PowerArgs.AliasCollection.Remove(System.String)">
            <summary>
            Removes the given alias from the collection if it was added via Add() or AddRange().  If
            it was added by injecting metadata into a CommandLineArgument or a CommandLineAction then
            an InvalidOperationException will be thrown.  The correct way to remove metadata injected
            aliases is to remove it from the metadata directly.
            </summary>
            <param name="item">the item to remove</param>
            <returns>true if the alias was removed, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.AliasCollection.GetEnumerator">
            <summary>
            Gets an enumerator capable of enumerating all aliases
            </summary>
            <returns>an enumerator capable of enumerating all aliases</returns>
        </member>
        <member name="M:PowerArgs.AliasCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator capable of enumerating all aliases
            </summary>
            <returns>an enumerator capable of enumerating all aliases</returns>
        </member>
        <member name="T:PowerArgs.ArgAction`1">
            <summary>
            This is the more complex version of the public result that is produced by the parser.
            </summary>
            <typeparam name="T">Represents the custom argument scaffold type that was passed to the parser.</typeparam>
        </member>
        <member name="P:PowerArgs.ArgAction`1.Args">
            <summary>
            The instance of your custom scaffold type that the parser generated and parsed.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgAction">
            <summary>
            This is the weakly typed, more complex version of the public result that is produced by the parser.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgAction.Definition">
            <summary>
            The definition or model that was used to parse the arguments
            </summary>
        </member>
        <member name="P:PowerArgs.ArgAction.Value">
            <summary>
            The instance of your custom scaffold type that the parser generated and parsed.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgAction.ActionArgs">
            <summary>
            If you used the action framework then this will represent the instance of the action specific arguments
            that were parsed.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgAction.ActionArgsProperty">
            <summary>
            If you used the action framework then this will map to the property that the user specified as the first
            parameter on the command line.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgAction.ActionParameters">
            <summary>
            This is set if you defined your action via a method with simple parameters
            </summary>
        </member>
        <member name="P:PowerArgs.ArgAction.HandledException">
            <summary>
            If an exception was handled by the parser then this property will be populated and others will not be.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgAction.Cancelled">
            <summary>
            If processing was cancelled then this property will be set to true.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgAction.Invoke">
            <summary>
            This will find the implementation method for your action and invoke it, passing the action specific
            arguments as a parameter.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgumentAwareTabCompletionSource">
            <summary>
            An abstract class that can be used to implement tab completion logic that is specific to a given argument.
            </summary>
        </member>
        <member name="T:PowerArgs.BooleanExpressionParser">
            <summary>
            A simple boolean expression parser that supports and '&amp;', or '|', and grouping via parentheses.
            </summary>
        </member>
        <member name="M:PowerArgs.BooleanExpressionParser.Parse(System.String)">
            <summary>
            Parses the given boolean expression which can be made up of variables and boolean operators (and '&amp;' and or '|') grouped by parentheses.
            </summary>
            <param name="expressionText">The expression to parse</param>
            <returns>The parsed expression</returns>
        </member>
        <member name="M:PowerArgs.BooleanExpressionParser.Revive(System.String,System.String)">
            <summary>
            A reviver that makes boolean expressions specificable on the command line
            </summary>
            <param name="key">not used</param>
            <param name="val">the expression text</param>
            <returns></returns>
        </member>
        <member name="T:PowerArgs.BooleanOperator">
            <summary>
            Represents the set of supported boolean operators
            </summary>
        </member>
        <member name="F:PowerArgs.BooleanOperator.And">
            <summary>
            Represents an 'and' boolean operation
            </summary>
        </member>
        <member name="F:PowerArgs.BooleanOperator.Or">
            <summary>
            Represents an 'or' boolean operation
            </summary>
        </member>
        <member name="T:PowerArgs.BooleanExpressionTokenType">
            <summary>
            An enum representing a type of boolean expression token
            </summary>
        </member>
        <member name="F:PowerArgs.BooleanExpressionTokenType.Variable">
            <summary>
            Represents a boolean variable
            </summary>
        </member>
        <member name="F:PowerArgs.BooleanExpressionTokenType.GroupOpen">
            <summary>
            Represents the beginning of a logically grouped boolean expression
            </summary>
        </member>
        <member name="F:PowerArgs.BooleanExpressionTokenType.GroupClose">
            <summary>
            Represents the end of a logically grouped boolean expression
            </summary>
        </member>
        <member name="F:PowerArgs.BooleanExpressionTokenType.And">
            <summary>
            Represents an 'and' clause in a boolean expression
            </summary>
        </member>
        <member name="F:PowerArgs.BooleanExpressionTokenType.Or">
            <summary>
            Represents an 'or' clause in a boolean expression
            </summary>
        </member>
        <member name="F:PowerArgs.BooleanExpressionTokenType.Not">
            <summary>
            Indicates that an expression should be negated
            </summary>
        </member>
        <member name="T:PowerArgs.BooleanExpressionToken">
            <summary>
            A class that represents a boolean expression token
            </summary>
        </member>
        <member name="P:PowerArgs.BooleanExpressionToken.Type">
            <summary>
            The type of token
            </summary>
        </member>
        <member name="M:PowerArgs.BooleanExpressionToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a boolean expression token
            </summary>
            <param name="tokenText">the token text</param>
            <param name="startIndex">the start index of the token value</param>
            <param name="line">the line number of the token value</param>
            <param name="col">the column number of the token value</param>
        </member>
        <member name="T:PowerArgs.IBooleanVariableResolver">
            <summary>
            An interface that describes how to resolve boolean variables that can be either true or false
            </summary>
        </member>
        <member name="M:PowerArgs.IBooleanVariableResolver.ResolveBoolean(System.String)">
            <summary>
            Implementations should provide a value of true or false for each variable specified.  Implementations can
            choose how to handle unknown variables either by throwing or returning a default value.
            </summary>
            <param name="variableName"></param>
            <returns></returns>
        </member>
        <member name="T:PowerArgs.FuncBooleanVariableResolver">
            <summary>
            A class that can resolve a boolean variable based on a function.
            </summary>
        </member>
        <member name="P:PowerArgs.FuncBooleanVariableResolver.ResolverImpl">
            <summary>
            The function that knows how to resolve boolean variables
            </summary>
        </member>
        <member name="M:PowerArgs.FuncBooleanVariableResolver.#ctor(System.Func{System.String,System.Boolean})">
            <summary>
            Creates a new variable resolver given an implementation as a function.
            </summary>
            <param name="resolverImpl"></param>
        </member>
        <member name="M:PowerArgs.FuncBooleanVariableResolver.ResolveBoolean(System.String)">
            <summary>
            Resolves the given variable using the wrapped function
            </summary>
            <param name="variableName"></param>
            <returns></returns>
        </member>
        <member name="T:PowerArgs.IBooleanExpression">
            <summary>
            An interface representing a node in a boolean expression that can either be true or false.
            </summary>
        </member>
        <member name="M:PowerArgs.IBooleanExpression.Evaluate(PowerArgs.IBooleanVariableResolver)">
            <summary>
            Evaluates the state of the node (true or false) given a variable resolver.
            </summary>
            <param name="resolver">the object to use to resolve boolean variables</param>
            <returns>the result of the expression, true or false</returns>
        </member>
        <member name="M:PowerArgs.IBooleanExpression.Evaluate(System.Collections.Generic.Dictionary{System.String,System.Boolean})">
            <summary>
            Evaluates the state of the node (true or false) given a set of variable values.
            </summary>
            <param name="variableValues">The current state of variables</param>
            <returns>the result of the expression, true or false</returns>
        </member>
        <member name="P:PowerArgs.IBooleanExpression.Not">
            <summary>
            Gets or sets a flag indicating that the expression should be negated
            </summary>
        </member>
        <member name="T:PowerArgs.BooleanVariable">
            <summary>
            A node in a boolean expression that represents a variable that can either be true or false.
            </summary>
        </member>
        <member name="P:PowerArgs.BooleanVariable.Not">
            <summary>
            Gets or sets a flag indicating that the variable's value should be negated
            </summary>
        </member>
        <member name="P:PowerArgs.BooleanVariable.VariableName">
            <summary>
            The name of the variable referenced by this node
            </summary>
        </member>
        <member name="M:PowerArgs.BooleanVariable.Evaluate(PowerArgs.IBooleanVariableResolver)">
            <summary>
            Uses the given resolver to resolve the target boolean variable
            </summary>
            <param name="resolver">The object used to resolve boolean variables</param>
            <returns>the result of the resolver</returns>
        </member>
        <member name="M:PowerArgs.BooleanVariable.Evaluate(System.Collections.Generic.Dictionary{System.String,System.Boolean})">
            <summary>
            Evaluates the expression given a set of variable values
            </summary>
            <param name="variableValues">The value of variables that appear in the expression</param>
            <returns>True if the expression was true, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.BooleanVariable.ToString">
            <summary>
            Gets a string representation of the variable
            </summary>
            <returns>a string representation of the variable</returns>
        </member>
        <member name="T:PowerArgs.BooleanExpressionGroup">
            <summary>
            A class that represents a boolean expression that supports and, or, and grouping.
            </summary>
        </member>
        <member name="P:PowerArgs.BooleanExpressionGroup.Not">
            <summary>
            Gets or sets a flag indicating that the expression should be negated
            </summary>
        </member>
        <member name="P:PowerArgs.BooleanExpressionGroup.Operands">
            <summary>
            The operands (variables or grouped child expressions) that make up this expression.
            </summary>
        </member>
        <member name="P:PowerArgs.BooleanExpressionGroup.Operators">
            <summary>
            The operators to apply between each operand
            </summary>
        </member>
        <member name="M:PowerArgs.BooleanExpressionGroup.#ctor">
            <summary>
            Creates a new empty boolean expression
            </summary>
        </member>
        <member name="M:PowerArgs.BooleanExpressionGroup.Evaluate(System.Collections.Generic.Dictionary{System.String,System.Boolean})">
            <summary>
            Evaluates the expression given a set of variable values
            </summary>
            <param name="variableValues">The value of variables that appear in the expression</param>
            <returns>True if the expression was true, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.BooleanExpressionGroup.Evaluate(PowerArgs.IBooleanVariableResolver)">
            <summary>
            Evaluates the expression given a variable resolver.
            </summary>
            <param name="resolver">An object used to resolve variables that appear in the expression</param>
            <returns>True if the expression was true, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.BooleanExpressionGroup.ToString">
            <summary>
            Gets a string representation of the variable
            </summary>
            <returns>a string representation of the variable</returns>
        </member>
        <member name="T:PowerArgs.ConsoleInDriver">
            <summary>
             A utility that can be used to drive input to Console.In programatically.
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleInDriver.IsAttached">
            <summary>
            Gets a value indicating whether or not the driver is currently attached to Console.In
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleInDriver.Instance">
            <summary>
            Gets the singleton instance of the driver
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleInDriver.Attach">
            <summary>
            Attaches the drives to Console.In
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleInDriver.Detach">
            <summary>
            Detaches the driver from Console.In and reopens and reconnects the standard input stream.
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleInDriver.Drive(System.String)">
            <summary>
            Drives a string of text into Console.In
            </summary>
            <param name="s">the string to drive</param>
        </member>
        <member name="M:PowerArgs.ConsoleInDriver.DriveLine(System.String)">
            <summary>
            Drives a string of text into Console.In, followed by a newline character
            </summary>
            <param name="s">the string to drive</param>
        </member>
        <member name="M:PowerArgs.ConsoleInDriver.Peek">
            <summary>
            Not implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleInDriver.Read">
            <summary>
            Reads the next char from the driver as an int.
            </summary>
            <returns>the next char from the driver as an int.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleInDriver.Read(System.Char[],System.Int32,System.Int32)">
            <summary>
            Not implemented
            </summary>
            <param name="buffer">Not implemented</param>
            <param name="index">Not implemented</param>
            <param name="count">Not implemented</param>
            <returns>Not implemented</returns>
        </member>
        <member name="M:PowerArgs.ConsoleInDriver.ReadBlock(System.Char[],System.Int32,System.Int32)">
            <summary>
            Not implemented
            </summary>
            <param name="buffer">Not implemented</param>
            <param name="index">Not implemented</param>
            <param name="count">Not implemented</param>
            <returns>Not implemented</returns>
        </member>
        <member name="M:PowerArgs.ConsoleInDriver.ReadLine">
            <summary>
            reads a line of input from the driver
            </summary>
            <returns>a line of input from the driver</returns>
        </member>
        <member name="M:PowerArgs.ConsoleInDriver.ReadToEnd">
            <summary>
            Not implemented
            </summary>
            <returns>Not implemented</returns>
        </member>
        <member name="T:PowerArgs.ConsoleSnapshot">
            <summary>
            An object that tracks and restores the cursor on a console
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleSnapshot.Left">
            <summary>
            Gets or sets the left position of the snapshot
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleSnapshot.Top">
            <summary>
            Gets or sets the top position of the snapshot
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleSnapshot.Console">
            <summary>
            Gets a reference to the console this snapshot was taken from
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleSnapshot.#ctor(System.Int32,System.Int32,PowerArgs.IConsoleProvider)">
            <summary>
            Creates a snapshot with explicit cursor position values
            </summary>
            <param name="left">the left position of the snapshot</param>
            <param name="top">the top position of the snapshot</param>
            <param name="console">the target console</param>
        </member>
        <member name="M:PowerArgs.ConsoleSnapshot.#ctor(PowerArgs.IConsoleProvider)">
            <summary>
            Creates a snapshot from the given console's current position
            </summary>
            <param name="console">the target console</param>
        </member>
        <member name="M:PowerArgs.ConsoleSnapshot.CreateOffsetSnapshot(System.Int32,System.Int32)">
            <summary>
            Creates and returns a new snapshot that is offset from the current 
            snapshot
            </summary>
            <param name="xOffset">the delta from this snapshot's Left value</param>
            <param name="yOffset">the delta from this snapshot's Top value</param>
            <returns> a new snapshot that is offset from the current snapshot</returns>
        </member>
        <member name="M:PowerArgs.ConsoleSnapshot.Restore">
            <summary>
            Restores the target console to this snapshot's cursor position
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleSnapshot.Finalize">
            <summary>
            restores the snapshot
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleSnapshot.Dispose">
            <summary>
            Restores the target console to this snapshot's cursor position
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleSnapshot.Dispose(System.Boolean)">
            <summary>
            Restores the target console to this snapshot's cursor position
            </summary>
            <param name="disposing">used for correct dispose pattern impl</param>
        </member>
        <member name="T:PowerArgs.ICanBeAConsoleString">
            <summary>
            An interface that defines an object that implements ToConsoleString
            </summary>
        </member>
        <member name="M:PowerArgs.ICanBeAConsoleString.ToConsoleString">
            <summary>
            Formats this object as a ConsoleString
            </summary>
            <returns>a ConsoleString</returns>
        </member>
        <member name="T:PowerArgs.ConsoleCharacter">
            <summary>
            A wrapper for char that encapsulates foreground and background colors.
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleCharacter.Value">
            <summary>
            The value of the character
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleCharacter.ForegroundColor">
            <summary>
            The console foreground color to use when printing this character.
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleCharacter.BackgroundColor">
            <summary>
            The console background color to use when printing this character.
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.Black(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named foreground color and an optional background color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="bg">an optional background color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.BlackBG(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named background color and an optional foreground color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="fg">an optional foreground color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.DarkBlue(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named foreground color and an optional background color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="bg">an optional background color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.DarkBlueBG(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named background color and an optional foreground color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="fg">an optional foreground color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.DarkGreen(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named foreground color and an optional background color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="bg">an optional background color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.DarkGreenBG(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named background color and an optional foreground color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="fg">an optional foreground color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.DarkCyan(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named foreground color and an optional background color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="bg">an optional background color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.DarkCyanBG(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named background color and an optional foreground color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="fg">an optional foreground color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.DarkRed(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named foreground color and an optional background color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="bg">an optional background color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.DarkRedBG(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named background color and an optional foreground color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="fg">an optional foreground color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.DarkMagenta(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named foreground color and an optional background color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="bg">an optional background color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.DarkMagentaBG(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named background color and an optional foreground color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="fg">an optional foreground color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.DarkYellow(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named foreground color and an optional background color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="bg">an optional background color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.DarkYellowBG(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named background color and an optional foreground color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="fg">an optional foreground color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.Gray(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named foreground color and an optional background color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="bg">an optional background color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.GrayBG(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named background color and an optional foreground color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="fg">an optional foreground color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.DarkGray(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named foreground color and an optional background color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="bg">an optional background color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.DarkGrayBG(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named background color and an optional foreground color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="fg">an optional foreground color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.Blue(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named foreground color and an optional background color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="bg">an optional background color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.BlueBG(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named background color and an optional foreground color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="fg">an optional foreground color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.Green(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named foreground color and an optional background color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="bg">an optional background color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.GreenBG(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named background color and an optional foreground color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="fg">an optional foreground color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.Cyan(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named foreground color and an optional background color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="bg">an optional background color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.CyanBG(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named background color and an optional foreground color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="fg">an optional foreground color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.Red(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named foreground color and an optional background color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="bg">an optional background color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.RedBG(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named background color and an optional foreground color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="fg">an optional foreground color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.Magenta(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named foreground color and an optional background color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="bg">an optional background color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.MagentaBG(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named background color and an optional foreground color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="fg">an optional foreground color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.Yellow(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named foreground color and an optional background color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="bg">an optional background color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.YellowBG(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named background color and an optional foreground color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="fg">an optional foreground color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.White(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named foreground color and an optional background color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="bg">an optional background color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.WhiteBG(System.Char,System.Nullable{System.ConsoleColor})">
            <summary>
            Styles the given character with the named background color and an optional foreground color that defaults to the console default
            </summary>
            <param name="val">the character to style</param>
            <param name="fg">an optional foreground color that defaults to the console default</param>
            <returns>a styled character</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.#ctor(System.Char,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Create a new ConsoleCharacter given a char value and optionally set the foreground or background coor.
            </summary>
            <param name="value">The character value</param>
            <param name="foregroundColor">The foreground color (defaults to the console's foreground color at initialization time).</param>
            <param name="backgroundColor">The background color (defaults to the console's background color at initialization time).</param>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.Write">
            <summary>
            Write this formatted character to the console
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.ToString">
            <summary>
            Gets the string representation of the character
            </summary>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.Equals(System.Object)">
            <summary>
            ConsoleCharacters can be compared to other ConsoleCharacter instances or char values.
            </summary>
            <param name="obj">The ConsoleCharacter or char to compare to.</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.op_Equality(PowerArgs.ConsoleCharacter,PowerArgs.ConsoleCharacter)">
            <summary>
            Operator overload for Equals
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.op_Inequality(PowerArgs.ConsoleCharacter,PowerArgs.ConsoleCharacter)">
            <summary>
            Operator overload for !Equals
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.op_Equality(PowerArgs.ConsoleCharacter,System.Char)">
            <summary>
            Operator overload for Equals
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.op_Inequality(PowerArgs.ConsoleCharacter,System.Char)">
            <summary>
            Operator overload for !Equals
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.GetHashCode">
            <summary>
            Override of GetHashcode that returns the internal char's hashcode.
            </summary>
            <returns>the internal char's hashcode.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.ToConsoleString">
            <summary>
            Formats this object as a ConsoleString
            </summary>
            <returns>a ConsoleString</returns>
        </member>
        <member name="T:PowerArgs.ConsoleString">
            <summary>
            A wrapper for string that encapsulates foreground and background colors.  ConsoleStrings are immutable.
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleString.ConsoleProvider">
            <summary>
            The console provider to use when writing output
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleString.DefaultForegroundColor">
            <summary>
            Gets the console's default foreground color
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:PowerArgs.ConsoleString.DefaultBackgroundColor" -->
        <member name="F:PowerArgs.ConsoleString.Empty">
            <summary>
            Represents an empty string.
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleString.StringValue">
            <summary>
            Gets the string value of this ConsoleString.  Useful when using the debugger.
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleString.Length">
            <summary>
            The length of the string.
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleString.#ctor">
            <summary>
            Create a new empty ConsoleString
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleString.IsUnstyled">
            <summary>
            Returns true if all characters have the default foreground and background color
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleString.#ctor(System.Collections.Generic.IEnumerable{PowerArgs.ConsoleCharacter})">
            <summary>
            Creates a new ConsoleString from a collection of ConsoleCharacter objects
            </summary>
            <param name="chars">The value to use to seed this string</param>
        </member>
        <member name="M:PowerArgs.ConsoleString.#ctor(System.Collections.Generic.List{PowerArgs.ConsoleCharacter})">
            <summary>
            Creates a new ConsoleString from a list of ConsoleCharacter objects
            </summary>
            <param name="chars">The value to use to seed this string</param>
        </member>
        <member name="M:PowerArgs.ConsoleString.#ctor(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Create a ConsoleString given an initial text value and optional color info.
            </summary>
            <param name="value"></param>
            <param name="foregroundColor">The foreground color (defaults to the console's foreground color at initialization time).</param>
            <param name="backgroundColor">The background color (defaults to the console's background color at initialization time).</param>
        </member>
        <member name="M:PowerArgs.ConsoleString.ToConsoleStrings(System.Collections.Generic.IEnumerable{System.String},System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Converts a collection of plain strings into ConsoleStrings
            </summary>
            <param name="plainStrings">the input strings</param>
            <param name="foregroundColor">the foreground color of all returned ConsoleStrings</param>
            <param name="backgroundColor">the background color of all returned ConsoleStrings</param>
            <returns>a collection of ConsoleStrnigs</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.AppendUsingCurrentFormat(System.String)">
            <summary>
            Returns a new string that Appends the given value to this one using the formatting of the last character or the default formatting if this ConsoleString is empty.
            </summary>
            <param name="value">The string to append.</param>
        </member>
        <member name="M:PowerArgs.ConsoleString.Replace(System.String,System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor},System.StringComparison)">
            <summary>
            Replaces all occurrances of the given string with the replacement value using the specified formatting.
            </summary>
            <param name="toFind">The substring to find</param>
            <param name="toReplace">The replacement value</param>
            <param name="foregroundColor">The foreground color (defaults to the console's foreground color at initialization time).</param>
            <param name="backgroundColor">The background color (defaults to the console's background color at initialization time).</param>
            <param name="comparison">Specifies how characters are compared</param>
            <returns>A new ConsoleString with the replacements.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.Highlight(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor},System.StringComparison)">
            <summary>
            Highights all occurrances of the given string with the desired foreground and background color.
            </summary>
            <param name="toFind">The substring to find</param>
            <param name="foregroundColor">The foreground color (defaults to the console's foreground color at initialization time).</param>
            <param name="backgroundColor">The background color (defaults to the console's background color at initialization time).</param>
            <param name="comparison">Specifies how characters are compared</param>
            <returns>A new ConsoleString with the highlights.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.ToDifferentBackground(System.Nullable{System.ConsoleColor})">
            <summary>
            Creates a new ConsoleString with the sam characters as this one, but with a 
            new background color
            </summary>
            <param name="bg">the new background color</param>
            <returns>A  new string with a different background color</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.HighlightSubstring(System.Int32,System.Int32,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Returns a new ConsoleString that is a copy of this ConsoleString, but applies the given style to the range of characters specified.
            </summary>
            <param name="start">the start index to apply the highlight</param>
            <param name="length">the number of characters to apply the highlight</param>
            <param name="foregroundColor">the foreground color to apply to the highlighted characters or null to use the default foreground color</param>
            <param name="backgroundColor">the background color to apply to the highlighted characters or null to use the default background color</param>
            <returns>a new ConsoleString that is a copy of this ConsoleString, but applies the given style to the range of characters specified.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.ReplaceRegex(System.String,System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Replaces all matches of the given regular expression with the replacement value using the specified formatting.
            </summary>
            <param name="regex">The regular expression to find.</param>
            <param name="toReplace">The replacement value</param>
            <param name="foregroundColor">The foreground color (defaults to the console's foreground color at initialization time).</param>
            <param name="backgroundColor">The background color (defaults to the console's background color at initialization time).</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.IndexOf(System.String,System.StringComparison)">
            <summary>
            Finds the index of a given substring in this ConsoleString.
            </summary>
            <param name="toFind">The substring to search for.</param>
            <param name="comparison">Specifies how characters are compared</param>
            <returns>The first index of the given substring or -1 if the substring was not found.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.IndexOf(PowerArgs.ConsoleString,System.StringComparison)">
            <summary>
            Finds the index of a given substring in this ConsoleString.
            </summary>
            <param name="toFind">The substring to search for. The styles of the strings must match.</param>
            <param name="comparison">Specifies how characters are compared</param>
            <returns>The first index of the given substring or -1 if the substring was not found.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.StartsWith(System.String,System.StringComparison)">
            <summary>
            Determines if this ConsoleString starts with the given string
            </summary>
            <param name="substr">the substring to look for</param>
            <param name="comparison">Specifies how characters are compared</param>
            <returns>true if this ConsoleString starts with the given substring, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.EndsWith(System.String,System.StringComparison)">
            <summary>
            Determines if this ConsoleString ends with the given string
            </summary>
            <param name="substr">the substring to look for</param>
            <param name="comparison">Specifies how characters are compared</param>
            <returns>true if this ConsoleString ends with the given substring, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.Contains(System.String,System.StringComparison)">
            <summary>
            Determines if this ConsoleString contains the given substring.
            </summary>
            <param name="substr">The substring to search for.</param>
            <param name="comparison">Specifies how characters are compared</param>
            <returns>True if found, false otherwise.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.Contains(PowerArgs.ConsoleString,System.StringComparison)">
            <summary>
            Determines if this ConsoleString contains the given substring.
            </summary>
            <param name="substr">The substring to search for.</param>
            <param name="comparison">Specifies how characters are compared</param>
            <returns>True if found, false otherwise.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.Substring(System.Int32)">
            <summary>
            Get a substring of this ConsoleString starting at the given index.
            </summary>
            <param name="start">the start index.</param>
            <returns>A new ConsoleString representing the substring requested.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.Substring(System.Int32,System.Int32)">
            <summary>
            Get a substring of this ConsoleString starting at the given index and with the given length.
            </summary>
            <param name="start">the start index.</param>
            <param name="length">the number of characters to return</param>
            <returns>A new ConsoleString representing the substring requested.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.Write(System.Object,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Writes the string representation of the given object to the console using the specified colors.
            </summary>
            <param name="o">The object to write</param>
            <param name="fg">The foreground color to use</param>
            <param name="bg">The background color to use</param>
        </member>
        <member name="M:PowerArgs.ConsoleString.WriteLine(System.Object,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Writes the string representation of the given object to the console using the specified colors and appends a newline.
            </summary>
            <param name="o">The object to write</param>
            <param name="fg">The foreground color to use</param>
            <param name="bg">The background color to use</param>
        </member>
        <member name="M:PowerArgs.ConsoleString.Write(PowerArgs.ConsoleString)">
            <summary>
            Writes the given ConsoleString to the console
            </summary>
            <param name="str">the string to write</param>
        </member>
        <member name="M:PowerArgs.ConsoleString.WriteLine(PowerArgs.ConsoleString)">
            <summary>
            Writes the given ConsoleString to the console and appends a newline
            </summary>
            <param name="str">the string to write</param>
        </member>
        <member name="M:PowerArgs.ConsoleString.Write(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Writes the string to the console using the specified colors.
            </summary>
            <param name="str">The object to write</param>
            <param name="fg">The foreground color to use</param>
            <param name="bg">The background color to use</param>
        </member>
        <member name="M:PowerArgs.ConsoleString.WriteLine(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Writes the string to the console using the specified colors and appends a newline.
            </summary>
            <param name="str">The object to write</param>
            <param name="fg">The foreground color to use</param>
            <param name="bg">The background color to use</param>
        </member>
        <member name="M:PowerArgs.ConsoleString.Write">
            <summary>
            Write this ConsoleString to the console using the desired style.
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleString.WriteLine">
            <summary>
            Write this ConsoleString to the console using the desired style.  A newline is appended.
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleString.ToString">
            <summary>
            Get the string representation of this ConsoleString.
            </summary>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.Serialize(System.Boolean)">
            <summary>
            Serializes the console string, preserving the formatting by inserting color markers inside the string. You can
            later parse the serialized string back into a ConsoleString structure.
            </summary>
            <param name="implicitDefaultsMode">if true, characters that use the system's default foreground and background colors will be encoded with the knowledge that those characters were 'default' rather than explicitly capturing the default values</param>
            <returns>A string that can be later parsed into a ConsoleString structure</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.Parse(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Parses a serialized ConsoleString that's either been hand crafted or output from the ConsoleString.Serialize() method.
            
            To indicate that characters should be yellow, preceed those characters with [Yellow]. 
            To indicate that the background of characters should be green, preceed those characters with [B=Green].
            To indicate that characters should use the current console's default styling, preceed those characters with [D].
            If the input string does not start with any of these indicators then all characters up until the first indicator will be treated as if they were preceeded with [D].
            
            In these examples I used Yellow and Green. You can substitute these with any color from the System.ConsoleColor enum.
            
            If the input string contains a '[' or a ']' then those must be escaped with a '\'.
            
            </summary>
            <param name="serializedConsoleString">The serialized string to parse</param>
            <param name="defaultFg">optionally specify the default foreground color to apply for characters with an explicit default</param>
            <param name="defaultBg">optionally specify the default background color to apply for characters with an explicit default</param>
            <returns>a rehydrated ConsoleString</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.Split(System.String,System.Collections.Generic.IEqualityComparer{System.String})">
            <summary>
            Splits this ConsoleString into segments given a split value
            </summary>
            <param name="splitValue">the value to split on</param>
            <param name="comparer">optionally override the comparison function</param>
            <returns>A list of segments</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.Split(PowerArgs.ConsoleString,System.Collections.Generic.IEqualityComparer{PowerArgs.ConsoleString})">
            <summary>
            Splits this ConsoleString into segments given a split value
            </summary>
            <param name="splitValue">the value to split on</param>
            <param name="comparer">optionally override the comparison function</param>
            <returns>A list of segments</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.ToConsoleBitmap">
            <summary>
            Converts this ConsoleString to a ConsoleBitmap. Tabs will be replaced with 4 spaces.
            </summary>
            <returns>a ConsoleBitmap whose height equals the number of lines of text in the input string and whose width equals that length of the longest line in the input string. </returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.ToHtmlDiv(System.Nullable{System.ConsoleColor},System.Boolean,System.Boolean)">
            <summary>
            Converts this ConsoleString into an html div tag that can be inserted into a web page and rendered by a web browser. 
            
            The div will have:
            
              a class attribute set to 'powerargs-console-string'
              a style attribute set to font-family:Consolas and background-color set to the given background color
              
            Each chunk of text that shares the same foreground and background color will be HTML encoded and then placed within a span tag inside
            the main div. Each span will have a style property with a value for color and background-color. 
            
            Newlines will be converted to br tags.
            
            </summary>
            <param name="divBackground">optionally set the background color of the div, defaults to the current Console's default background color</param>
            <param name="indent">if true, the spans will be indented inside the parent div</param>
            <param name="htmlEncode">if true, the function will html encode content before inserting markup</param>
            <returns>a string that is a valid html div. Null inputs will result in a null return value. Empty string wi</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.GroupByFormatting">
            <summary>
            Splits this string into groups where each character in each group has the same foreground and background color
            </summary>
            <returns>groups where each character in each group has the same foreground and background color</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.Equals(System.Object)">
            <summary>
            Compare this ConsoleString to another ConsoleString or a plain string.
            </summary>
            <param name="obj">The ConsoleString or plain string to compare to.</param>
            <returns>True if equal, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.CompareTo(System.String)">
            <summary>
            Compare this ConsoleString to another ConsoleString.
            </summary>
            <param name="other">The ConsoleString to compare to.</param>
            <returns>True if equal, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.GetHashCode">
            <summary>
            Gets the hashcode of the underlying string
            </summary>
            <returns>the hashcode of the underlying string</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.op_Addition(PowerArgs.ConsoleString,PowerArgs.ConsoleString)">
            <summary>
            Operator overload that concatenates 2 ConsoleString instances and returns a new one.
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <returns>A new, concatenated ConsoleString</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.op_Addition(PowerArgs.ConsoleString,System.String)">
            <summary>
            Operator overload that concatenates a ConsoleString with a string and returns a new one.
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <returns>A new, concatenated ConsoleString</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.op_Equality(PowerArgs.ConsoleString,PowerArgs.ConsoleString)">
            <summary>
            Compares 2 ConsoleStrings for equality.
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <returns>True if they are the same, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.op_Inequality(PowerArgs.ConsoleString,PowerArgs.ConsoleString)">
            <summary>
            Compares 2 ConsoleStrings for inequality.
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <returns>False if they are the same, true otherwise</returns>
        </member>
        <member name="P:PowerArgs.ConsoleString.Item(System.Int32)">
            <summary>
            Gets the character at the specified index
            </summary>
            <param name="index">the index of the character to find</param>
            <returns>the character at the specified index</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.ToConsoleString">
            <summary>
            Formats this object as a ConsoleString
            </summary>
            <returns>a ConsoleString</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.ToBlack(System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to black, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="bg">The new background color for all characters or null to preserve each character's current background color</param>
            <returns>a new ConsoleString with the desired color changes</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.ToDarkBlue(System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to dark blue, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="bg">The new background color for all characters or null to preserve each character's current background color</param>
            <returns>a new ConsoleString with the desired color changes</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.ToDarkGreen(System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to dark green, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="bg">The new background color for all characters or null to preserve each character's current background color</param>
            <returns>a new ConsoleString with the desired color changes</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.ToDarkCyan(System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to dark cyan, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="bg">The new background color for all characters or null to preserve each character's current background color</param>
            <returns>a new ConsoleString with the desired color changes</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.ToDarkRed(System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to dark red, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="bg">The new background color for all characters or null to preserve each character's current background color</param>
            <returns>a new ConsoleString with the desired color changes</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.ToDarkMagenta(System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to dark magenta, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="bg">The new background color for all characters or null to preserve each character's current background color</param>
            <returns>a new ConsoleString with the desired color changes</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.ToDarkYellow(System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to dark yellow, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="bg">The new background color for all characters or null to preserve each character's current background color</param>
            <returns>a new ConsoleString with the desired color changes</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.ToGray(System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to gray, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="bg">The new background color for all characters or null to preserve each character's current background color</param>
            <returns>a new ConsoleString with the desired color changes</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.ToDarkGray(System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to dark gray, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="bg">The new background color for all characters or null to preserve each character's current background color</param>
            <returns>a new ConsoleString with the desired color changes</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.ToBlue(System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to blue, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="bg">The new background color for all characters or null to preserve each character's current background color</param>
            <returns>a new ConsoleString with the desired color changes</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.ToGreen(System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to green, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="bg">The new background color for all characters or null to preserve each character's current background color</param>
            <returns>a new ConsoleString with the desired color changes</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.ToCyan(System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to cyan, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="bg">The new background color for all characters or null to preserve each character's current background color</param>
            <returns>a new ConsoleString with the desired color changes</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.ToRed(System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to red, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="bg">The new background color for all characters or null to preserve each character's current background color</param>
            <returns>a new ConsoleString with the desired color changes</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.ToMagenta(System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to magenta, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="bg">The new background color for all characters or null to preserve each character's current background color</param>
            <returns>a new ConsoleString with the desired color changes</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.ToYellow(System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to yellow, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="bg">The new background color for all characters or null to preserve each character's current background color</param>
            <returns>a new ConsoleString with the desired color changes</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.ToWhite(System.Nullable{System.ConsoleColor})">
            <summary>
            Changes the foreground of this string to white, and optionally forces the background of all characters to the given color.
            </summary>
            <param name="bg">The new background color for all characters or null to preserve each character's current background color</param>
            <returns>a new ConsoleString with the desired color changes</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.GetEnumerator">
            <summary>
            Gets an enumerator for this string
            </summary>
            <returns>an enumerator for this string</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator for this string
            </summary>
            <returns>an enumerator for this string</returns>
        </member>
        <member name="T:PowerArgs.ConsoleStringX">
            <summary>
            Extensions that make it easy to work with ConsoleStrings
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleStringX.ToConsoleString(System.Collections.Generic.IEnumerable{PowerArgs.ConsoleCharacter})">
            <summary>
            Converts the given enumeration of console characters to a console string
            </summary>
            <param name="buffer">the characters to convert to a console string</param>
            <returns>the new console string</returns>
        </member>
        <member name="M:PowerArgs.ConsoleStringX.ToNormalString(System.Collections.Generic.IEnumerable{PowerArgs.ConsoleCharacter})">
            <summary>
            Converts the given enumeration of console characters to a normal string
            </summary>
            <param name="buffer">the characters to convert to a normal string</param>
            <returns>the new string</returns>
        </member>
        <member name="T:PowerArgs.ConsoleStringEqualityComparer">
            <summary>
            An equality comparer for ConsoleString objects
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleStringEqualityComparer.Default">
            <summary>
            The default equality comparer that will require styles to be equal and will simply call string.Equals for string equality
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleStringEqualityComparer.ValueComparer">
            <summary>
            Gets the string euquality comparer used for string evaluations
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleStringEqualityComparer.RequireStylesToBeEqual">
            <summary>
            Gets a boolean that indicates whether or not this comparer requires the foreground and background color to match in order to be equal
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleStringEqualityComparer.#ctor(System.Collections.Generic.IEqualityComparer{System.String},System.Boolean)">
            <summary>
            Creates a new console string equality comparer.
            </summary>
            <param name="valueComparer">the comparer to use to compare the characters in the string or null to use a default that will use the string.Equals method</param>
            <param name="requireStylesToBeEqual">If true, the comparer will require the two strings to have the same foreground and background colors for each character. If false only the characters will be compared.</param>
        </member>
        <member name="M:PowerArgs.ConsoleStringEqualityComparer.Equals(PowerArgs.ConsoleString,PowerArgs.ConsoleString)">
            <summary>
            Compares the two ConsoleString objects for equality
            </summary>
            <param name="x">the first string</param>
            <param name="y">the second string</param>
            <returns>true if equal, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ConsoleStringEqualityComparer.GetHashCode(PowerArgs.ConsoleString)">
            <summary>
            Gets the hash code for the given string
            </summary>
            <param name="obj">the string to hash</param>
            <returns>a hash code for the given string</returns>
        </member>
        <member name="M:PowerArgs.ConsoleStringEqualityComparer.Equals(System.String,System.String)">
            <summary>
            Compares the given strings for equality
            </summary>
            <param name="x">the first string</param>
            <param name="y">the second string</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleStringEqualityComparer.GetHashCode(System.String)">
            <summary>
            Gets the hash code for the given string
            </summary>
            <param name="obj">the string to hash</param>
            <returns>a hash code for the given string</returns>
        </member>
        <member name="T:PowerArgs.ConsoleTableBuilder">
            <summary>
            A class that makes it easy to build strings that look and feel like tables when displayed in a console
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleTableBuilder.FormatAsTable(System.Collections.Generic.List{PowerArgs.ConsoleString},System.Collections.Generic.List{System.Collections.Generic.List{PowerArgs.ConsoleString}},System.String,System.Collections.Generic.List{PowerArgs.ColumnOverflowBehavior},System.Int32)">
            <summary>
            Formats the given data as a string that looks and feels like a table when displayed in a console
            </summary>
            <param name="columnHeaders">The headers for the table</param>
            <param name="rows">The cell data for the table</param>
            <param name="rowPrefix">A prefix, usually an indentation, to append before each row, including the headers</param>
            <param name="columnOverflowBehaviors">Optionally provide hints as to how overflow should be handled.  By default, the longest value in a column determines the column width.  You can choose to truncate or to do a smart wrap.</param>
            <param name="gutter">How many empty spaces to place between columns</param>
            <returns>The table, as a console string</returns>
        </member>
        <member name="M:PowerArgs.ConsoleTableBuilder.FormatAsTable(System.Collections.IEnumerable,System.String)">
            <summary>
            Formats the given collection as a string that looks and feels like a table when displayed in a console.
            </summary>
            <param name="objects">The objects to format</param>
            <param name="format">A space delimited set of properties to use as column headers.  
            You can change the display string for a particular property by using the format 'PropertyName>DisplayName' where PropertyName is a property name and DisplayName is the text to display.  If you omit this parameter then the first object in the collection will be inspected and it's public properties will be used as columns.</param>
            <returns></returns>
        </member>
        <member name="T:PowerArgs.ColumnOverflowBehavior">
            <summary>
            An abstract class that lets you describe how to handle variable column widths when formatting a console table.  You should
            not derive from this class.  All supported child classes are defined in this assembly.
            </summary>
        </member>
        <member name="T:PowerArgs.GrowUnboundedOverflowBehavior">
            <summary>
            A class that indicates that the target column should be sized based on the longest value in the column, with no upper bound
            </summary>
        </member>
        <member name="T:PowerArgs.TruncateOverflowBehavior">
            <summary>
            A class that indicates that the target column should not exceed a max size, and should be truncated if it does
            </summary>
        </member>
        <member name="P:PowerArgs.TruncateOverflowBehavior.TruncationText">
            <summary>
            The truncation indicator, by default '...'
            </summary>
        </member>
        <member name="P:PowerArgs.TruncateOverflowBehavior.ColumnWidth">
            <summary>
            The width of the column.  Note that your text may be truncated even if it is smaller than this size because the
            truncation indicator, by default, takes 3 characters '...'
            </summary>
        </member>
        <member name="P:PowerArgs.TruncateOverflowBehavior.MaxWidthBeforeShowingTruncationText">
            <summary>
            The max length a value in this column can be without being truncated
            </summary>
        </member>
        <member name="M:PowerArgs.TruncateOverflowBehavior.#ctor">
            <summary>
            Creates a new truncation overflow behavior instance
            </summary>
        </member>
        <member name="T:PowerArgs.SmartWrapOverflowBehavior">
            <summary>
            A class that indicates that the target column should wrap if needed
            </summary>
        </member>
        <member name="P:PowerArgs.SmartWrapOverflowBehavior.MaxWidthBeforeWrapping">
            <summary>
            The max length a cell value can be before it needs to wrap
            </summary>
        </member>
        <member name="P:PowerArgs.SmartWrapOverflowBehavior.WordBreakLookBehind">
            <summary>
            How far back to look for a whitespace character so that wrapping can be done on a word
            </summary>
        </member>
        <member name="P:PowerArgs.SmartWrapOverflowBehavior.DefineMaxWidthBasedOnConsoleWidth">
            <summary>
            If set to true then the target column will have its width dynamically determined based on the width of the current console.  
            You can only set this to true for the last column in a table.
            </summary>
        </member>
        <member name="M:PowerArgs.SmartWrapOverflowBehavior.#ctor">
            <summary>
            Creates a new smart wrap behavior
            </summary>
        </member>
        <member name="T:PowerArgs.CycledTabCompletionManager">
            <summary>
            This helper class can be leveraged when implementing custom tab completion logic.  It knows how to cycle through multple
            candidates and support tabbing forward and shift/tabbing backwards.  You just pass values from the tab completion methods
            and then provide an evaluation function that knows how to get the list of possible matches.
            </summary>
        </member>
        <member name="P:PowerArgs.CycledTabCompletionManager.MinCharsBeforeCyclingBegins">
            <summary>
            If the value of soFar is a string that's less than this value then no completion will be returned.
            </summary>
        </member>
        <member name="T:PowerArgs.GroupedRegexArg">
            <summary>
            An abstract class that lets you create custom argument types that match a regular expression.  The 
            class also makes it easy to extract named groups from the regular expression for use by your application.
            </summary>
        </member>
        <member name="F:PowerArgs.GroupedRegexArg.exactMatch">
            <summary>
            The match that exactly matches the given regular expression
            </summary>
        </member>
        <member name="M:PowerArgs.GroupedRegexArg.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new grouped regular expression argument instance.
            </summary>
            <param name="regex">The regular expression to enforce</param>
            <param name="input">The user input that was provided</param>
            <param name="errorMessage">An error message to show in the case of a non match</param>
        </member>
        <member name="M:PowerArgs.GroupedRegexArg.Group(System.String,System.String)">
            <summary>
            A helper function you can use to group a particular regular expression.
            </summary>
            <param name="regex">Your regular expression that you would like to put in a group.</param>
            <param name="groupName">The name of the group that you can use to extract the group value later.</param>
            <returns></returns>
        </member>
        <member name="P:PowerArgs.GroupedRegexArg.Item(System.String)">
            <summary>
            Gets the value of the regex group from the exact match.
            </summary>
            <param name="groupName">The name of the group to lookup</param>
            <returns></returns>
        </member>
        <member name="P:PowerArgs.GroupedRegexArg.Item(System.Int32)">
            <summary>
            Gets the value of the regex group from the exact match.
            </summary>
            <param name="groupNumber">The index of the group to lookup</param>
            <returns></returns>
        </member>
        <member name="T:PowerArgs.ITabCompletionSource">
            <summary>
            An interface for a tab completion source
            </summary>
        </member>
        <member name="M:PowerArgs.ITabCompletionSource.TryComplete(PowerArgs.TabCompletionContext,System.String@)">
            <summary>
            PowerArgs will call this method if it has enhanced the command prompt and the user presses tab.  The 
            context object passed into the function will contain useful information about what the user has typed on the command line.
            If you find a completion then you should assign it to the completion variable and return true.
            </summary>
            <param name="context">An object containing useful information about what the user has typed on the command line</param>
            <param name="completion">The variable that you should assign the completed string to if you find a match.</param>
            <returns>True if you completed the string, false otherwise.</returns>
        </member>
        <member name="T:PowerArgs.TabCompletionContext">
            <summary>
            A class that contains useful information when performing custom tab completion logic
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletionContext.Shift">
            <summary>
            Gets whether or not the shift key was down when the tab key was pressed
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletionContext.PreviousToken">
            <summary>
            Gets the token that comes before the completion candidate on the command line
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletionContext.CommandLineText">
            <summary>
            Gets the full and current state of the command line text
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletionContext.Position">
            <summary>
            Gets the position of the cursor within the current command line
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletionContext.CompletionCandidate">
            <summary>
            Gets the token that is being considered for tab completion
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletionContext.TargetArgument">
            <summary>
            Gets the current command line argument that is being targeted based on the current state of the command line
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletionContext.TargetAction">
            <summary>
            Gets the current command line action that is being targeted based on the current state of the command line
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletionContext.Definition">
            <summary>
            Gets a reference to the command line arguments definition being processed
            </summary>
        </member>
        <member name="T:PowerArgs.IUsageTemplateProvider">
            <summary>
            An interface that defines how usage templates should be retrieved
            </summary>
        </member>
        <member name="M:PowerArgs.IUsageTemplateProvider.GetTemplate">
            <summary>
            Gets the usage template to render
            </summary>
            <returns>usage template to render</returns>
        </member>
        <member name="T:PowerArgs.DefaultConsoleUsageTemplateProvider">
            <summary>
            A usage template provider that returns the default console usage template
            </summary>
        </member>
        <member name="M:PowerArgs.DefaultConsoleUsageTemplateProvider.GetTemplate">
            <summary>
            gets the default console usage template
            </summary>
            <returns>the default console usage template</returns>
        </member>
        <member name="T:PowerArgs.DefaultBrowserUsageTemplateProvider">
            <summary>
            A usage template provider that returns the default browser usage template
            </summary>
        </member>
        <member name="M:PowerArgs.DefaultBrowserUsageTemplateProvider.GetTemplate">
            <summary>
            gets the default browser usage template
            </summary>
            <returns>the default browser usage template</returns>
        </member>
        <member name="T:PowerArgs.MultiTabCompletionSource">
            <summary>
            An aggregate tab completion source that cycles through it's inner sources looking for matches.
            </summary>
        </member>
        <member name="M:PowerArgs.MultiTabCompletionSource.#ctor(PowerArgs.ITabCompletionSource[])">
            <summary>
            Create a new MultiTabCompletionSource given an array of sources.
            </summary>
            <param name="sources">The sources to wrap</param>
        </member>
        <member name="M:PowerArgs.MultiTabCompletionSource.#ctor(System.Collections.Generic.IEnumerable{PowerArgs.ITabCompletionSource})">
            <summary>
            Create a new MultiTabCompletionSource given an IEnumerable of sources.
            </summary>
            <param name="sources">The sources to wrap</param>
        </member>
        <member name="M:PowerArgs.MultiTabCompletionSource.TryComplete(PowerArgs.TabCompletionContext,System.String@)">
            <summary>
            Iterates over the wrapped sources looking for a match
            </summary>
            <param name="shift">Indicates if shift was being pressed</param>
            <param name="soFar">The text token that the user has typed before pressing tab.</param>
            <param name="context"></param>
            <param name="completion">The variable that you should assign the completed string to if you find a match.</param>
            <returns></returns>
        </member>
        <member name="T:PowerArgs.ParseResult">
            <summary>
            The raw parse result that contains the dictionary of values that were parsed
            </summary>
        </member>
        <member name="P:PowerArgs.ParseResult.ExplicitParameters">
            <summary>
            Dictionary of values that were either in the format -key value or /key:value on
            the command line.
            </summary>
        </member>
        <member name="P:PowerArgs.ParseResult.ImplicitParameters">
            <summary>
            Dictionary of values that were implicitly specified by position where the key is the position (e.g. 0)
            and the value is the actual parameter value.
            
            Example command line:  Program.exe John Smith
            
            John would be an implicit parameter at position 0.
            Smith would be an implicit parameter at position 1.
            </summary>
        </member>
        <member name="P:PowerArgs.ParseResult.AdditionalExplicitParameters">
            <summary>
            This is only populated for programs that support multiple command line arguments mapping to a single logical argument.  For example, 
            you may have an argument called -files that you would want to be used like this: -files file1 file2 file3.
            In this case, this dictionary would contain an entry with key 'files' and values 'file2, file3'.  Note that file1 will be populated
            in ExplicitParameters for legacy reasons
            </summary>
        </member>
        <member name="T:PowerArgs.Deferred">
            <summary>
            The callee portion of the promise abstraction
            </summary>
        </member>
        <member name="P:PowerArgs.Deferred.Promise">
            <summary>
            The promise to defer
            </summary>
        </member>
        <member name="P:PowerArgs.Deferred.IsFulfilled">
            <summary>
            Returns true if the promise has been resolved
            </summary>
        </member>
        <member name="P:PowerArgs.Deferred.Exception">
            <summary>
            The exception associated with the deferred work, or null if there is none
            </summary>
        </member>
        <member name="P:PowerArgs.Deferred.Thens">
            <summary>
            Handlers to call after the deferred work is complete
            </summary>
        </member>
        <member name="P:PowerArgs.Deferred.Fails">
            <summary>
            Handlers to call if the deferred work fails
            </summary>
        </member>
        <member name="P:PowerArgs.Deferred.Finalies">
            <summary>
            Handlers to call after all other handlers
            </summary>
        </member>
        <member name="P:PowerArgs.Deferred.SyncObject">
            <summary>
            used as the lock key when synchronizing work
            </summary>
        </member>
        <member name="M:PowerArgs.Deferred.Create">
            <summary>
            Creates a deferred
            </summary>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.Deferred.Reject(System.Exception)">
            <summary>
            Rejects the deferred work given an exception that has the details
            </summary>
            <param name="ex">the details of the rejection</param>
        </member>
        <member name="M:PowerArgs.Deferred.Resolve">
            <summary>
            Mark the deferred work as completed and notifies all then handlers
            </summary>
        </member>
        <member name="T:PowerArgs.Promise">
            <summary>
            An abstract protocol for handling async method calls that is decoupled from the actual
            async nature of the operation
            </summary>
        </member>
        <member name="M:PowerArgs.Promise.Then(System.Action)">
            <summary>
            Registers an action to be called after the promise is resolved successfully
            </summary>
            <param name="a">the action to run after the promise is resolved</param>
            <returns>this promise</returns>
        </member>
        <member name="M:PowerArgs.Promise.Fail(System.Action{System.Exception})">
            <summary>
            Registers an action to run if this promise is rejected.
            </summary>
            <param name="a">the exception handler</param>
            <returns>this promise</returns>
        </member>
        <member name="M:PowerArgs.Promise.Finally(System.Action{PowerArgs.Promise})">
            <summary>
            Registers an action to run at the end of all handlers.
            </summary>
            <param name="a">the  handler</param>
            <returns>this promise</returns>
        </member>
        <member name="M:PowerArgs.Promise.Wait(System.Int32)">
            <summary>
            Blocks the current thread until the promise is resolved or rejected
            </summary>
        </member>
        <member name="T:PowerArgs.PromiseWaitException">
            <summary>
            An aggregate exception that is thrown from the Wait()
            method of a promise in the case where the promise fails.
            
            Inner aggregate exceptions will be unwrapped so that the elements within 
            this exception's InnerExceptions property will never contain aggregate exceptions.
            </summary>
        </member>
        <member name="T:PowerArgs.SecureStringArgument">
            <summary>
            A PowerArgs argument type that can be used to accept user input without that input appearing on the command line.
            It uses secure strings under the hood.
            </summary>
        </member>
        <member name="P:PowerArgs.SecureStringArgument.SecureString">
            <summary>
            The secure string value.  The first time your code accesses this property is when the user will be presented with
            the secure input prompt.
            </summary>
        </member>
        <member name="M:PowerArgs.SecureStringArgument.ConvertToNonsecureString">
            <summary>
            Converts the underlying secure string to a regular string.
            </summary>
            <returns>A normal string representation of the user's input.</returns>
        </member>
        <member name="T:PowerArgs.SimpleTabCompletionSource">
            <summary>
            A simple tab completion source implementation that looks for matches over a set of pre-determined strings.
            </summary>
        </member>
        <member name="P:PowerArgs.SimpleTabCompletionSource.MinCharsBeforeCyclingBegins">
            <summary>
            Require that the user type this number of characters before the source starts cycling through ambiguous matches.  The default is 3.
            </summary>
        </member>
        <member name="M:PowerArgs.SimpleTabCompletionSource.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new completion source given an enumeration of string candidates
            </summary>
            <param name="candidates"></param>
        </member>
        <member name="M:PowerArgs.SimpleTabCompletionSource.#ctor(System.Func{System.Collections.Generic.IEnumerable{System.String}})">
            <summary>
            Creates a simple tab completion source given a function used to evaluate the candidates.
            </summary>
            <param name="candidateFunction">The function used to evaluate the completions where the input is a string parameter that represents the incomplete token</param>
        </member>
        <member name="M:PowerArgs.SimpleTabCompletionSource.TryComplete(PowerArgs.TabCompletionContext,System.String@)">
            <summary>
            Iterates through the candidates to try to find a match.  If there are multiple possible matches it 
            supports cycling through tem as the user continually presses tab.
            </summary>
            <param name="shift">Indicates if shift was being pressed</param>
            <param name="soFar">The text token that the user has typed before pressing tab.</param>
            <param name="context"></param>
            <param name="completion">The variable that you should assign the completed string to if you find a match.</param>
            <returns>true if the tab completion was successful, false otherwise</returns>
        </member>
        <member name="T:PowerArgs.IUndoRedoAction">
            <summary>
            An interface for an undoable action
            </summary>
        </member>
        <member name="M:PowerArgs.IUndoRedoAction.Do">
            <summary>
            Do the action for the first time
            </summary>
        </member>
        <member name="M:PowerArgs.IUndoRedoAction.Undo">
            <summary>
            Undo the action
            </summary>
        </member>
        <member name="M:PowerArgs.IUndoRedoAction.Redo">
            <summary>
            Redo the action
            </summary>
        </member>
        <member name="T:PowerArgs.UndoRedoStack">
            <summary>
            A class that models the standard undo / redo pattern found in many applications
            </summary>
        </member>
        <member name="P:PowerArgs.UndoRedoStack.UndoElements">
            <summary>
            Gets the elements currently in the undo stack
            </summary>
        </member>
        <member name="M:PowerArgs.UndoRedoStack.#ctor">
            <summary>
            Initializes the undo redo stack
            </summary>
        </member>
        <member name="M:PowerArgs.UndoRedoStack.Do(PowerArgs.IUndoRedoAction)">
            <summary>
            Do the given action for the first time.  This method will call the Do() method on he action.
            </summary>
            <param name="action">The action to do.  The Do() method will be called</param>
        </member>
        <member name="M:PowerArgs.UndoRedoStack.Undo">
            <summary>
            Undoes the most recently done (or redone) action
            </summary>
            <returns>true if there was something to undo, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.UndoRedoStack.Redo">
            <summary>
            Redoes the las thing that was undone.
            </summary>
            <returns>true if there was something to redo, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.UndoRedoStack.Clear">
            <summary>
            Clears both the undo and redo stacks
            </summary>
        </member>
        <member name="T:PowerArgs.USPhoneNumber">
            <summary>
            An example of a custom type that uses regular expressions to extract values from the command line
            and implements an ArgReviver to transform the text input into a complex type.
            This class represents a US phone number.
            </summary>
        </member>
        <member name="P:PowerArgs.USPhoneNumber.AreaCode">
            <summary>
            The three digit area code of the phone number.
            </summary>
        </member>
        <member name="P:PowerArgs.USPhoneNumber.FirstDigits">
            <summary>
            The three digit first segment of the phone number
            </summary>
        </member>
        <member name="P:PowerArgs.USPhoneNumber.SecondDigits">
            <summary>
            The four digit second segment of the phone number.
            </summary>
        </member>
        <member name="M:PowerArgs.USPhoneNumber.#ctor(System.String)">
            <summary>
            Creates a phone number object from a string
            </summary>
            <param name="phoneNumber"></param>
        </member>
        <member name="M:PowerArgs.USPhoneNumber.ToString">
            <summary>
            Gets the default string representation of the phone number in the format '1-(aaa)-bbb-cccc'.
            </summary>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.USPhoneNumber.ToString(System.String)">
            <summary>
            Formats the phone number as a string.  
            </summary>
            <param name="format">Use '{aaa}' for the area code, use {bbb} for the first grouping, and use {cccc} for the second grouping.</param>
            <returns>A formatted phone number string</returns>
        </member>
        <member name="M:PowerArgs.USPhoneNumber.Revive(System.String,System.String)">
            <summary>
            Custom PowerArgs reviver that converts a string parameter into a custom phone number
            </summary>
            <param name="key">The name of the argument (not used)</param>
            <param name="val">The value specified on the command line</param>
            <returns>A USPhoneNumber object based on the user input</returns>
        </member>
        <member name="T:PowerArgs.SingleActionHook">
            <summary>
            Creates a hook from an action
            </summary>
        </member>
        <member name="P:PowerArgs.SingleActionHook.HookImpl">
            <summary>
            Gets the hook implementation that was passed to the constructor
            </summary>
        </member>
        <member name="P:PowerArgs.SingleActionHook.HookId">
            <summary>
            Gets the Id or name of the hook
            </summary>
        </member>
        <member name="M:PowerArgs.SingleActionHook.#ctor(System.String,System.Int32,System.Action{PowerArgs.ArgHook.HookContext})">
            <summary>
            Creates a new hook with the given name, priority, and implementation
            </summary>
            <param name="hookId">The id or name of the hook</param>
            <param name="priority">The priority of the hook (higher numbers execute first)</param>
            <param name="hookImpl">The hook implementation</param>
        </member>
        <member name="M:PowerArgs.SingleActionHook.AfterCancel(PowerArgs.ArgHook.HookContext)">
            <summary>
            Calls the underlying hook if it was specified in the constructor
            </summary>
            <param name="context">The processing context</param>
        </member>
        <member name="M:PowerArgs.SingleActionHook.AfterInvoke(PowerArgs.ArgHook.HookContext)">
            <summary>
            Calls the underlying hook if it was specified in the constructor
            </summary>
            <param name="context">The processing context</param>
        </member>
        <member name="M:PowerArgs.SingleActionHook.AfterPopulateProperties(PowerArgs.ArgHook.HookContext)">
            <summary>
            Calls the underlying hook if it was specified in the constructor
            </summary>
            <param name="context">The processing context</param>
        </member>
        <member name="M:PowerArgs.SingleActionHook.AfterPopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            Calls the underlying hook if it was specified in the constructor
            </summary>
            <param name="context">The processing context</param>
        </member>
        <member name="M:PowerArgs.SingleActionHook.BeforeInvoke(PowerArgs.ArgHook.HookContext)">
            <summary>
            Calls the underlying hook if it was specified in the constructor
            </summary>
            <param name="context">The processing context</param>
        </member>
        <member name="M:PowerArgs.SingleActionHook.BeforeParse(PowerArgs.ArgHook.HookContext)">
            <summary>
            Calls the underlying hook if it was specified in the constructor
            </summary>
            <param name="context">The processing context</param>
        </member>
        <member name="M:PowerArgs.SingleActionHook.BeforePopulateProperties(PowerArgs.ArgHook.HookContext)">
            <summary>
            Calls the underlying hook if it was specified in the constructor
            </summary>
            <param name="context">The processing context</param>
        </member>
        <member name="M:PowerArgs.SingleActionHook.BeforePopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            Calls the underlying hook if it was specified in the constructor
            </summary>
            <param name="context">The processing context</param>
        </member>
        <member name="M:PowerArgs.SingleActionHook.BeforePrepareUsage(PowerArgs.ArgHook.HookContext)">
            <summary>
            Calls the underlying hook if it was specified in the constructor
            </summary>
            <param name="context">The processing context</param>
        </member>
        <member name="M:PowerArgs.SingleActionHook.BeforeValidateDefinition(PowerArgs.ArgHook.HookContext)">
            <summary>
            Calls the underlying hook if it was specified in the constructor
            </summary>
            <param name="context">The processing context</param>
        </member>
        <member name="T:PowerArgs.ArgHook">
            <summary>
            An abstract class that you can implement if you want to hook into various parts of the
            parsing pipeline.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgHook.HookContext">
            <summary>
            Context that is passed to your hook.  Different parts of the context will be available
            depending on which part of the pipeline you're hooking into.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.HookContext.Current">
            <summary>
            Gets the context for the current parse operation happening on the current thread or
            null if no parse is happening on the current thread.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.HookContext.CurrentArgument">
            <summary>
            The current argument being operating on. 
            AfterPopulateProperties.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.HookContext.SpecifiedAction">
            <summary>
            Gets the action that was specified on the command line or null if no action was specified or if the definition exposes no actions.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgHook.HookContext.CmdLineArgs">
            <summary>
            The command line arguments that were passed to the Args class.  This is always available and you
            can modify it in the BeforeParse hook at your own risk.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgHook.HookContext.ArgumentValue">
            <summary>
            The string value that was specified for the current argument.  This will align with the value of ArgHook.CurrentArgument.
            
            This is not available during BeforePopulateProperties or
            AfterPopulateProperties.
            
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.HookContext.Args">
            <summary>
            This is the instance of your argument class.  The amount that it is populated will depend on how far along in the pipeline
            the parser is.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.HookContext.Definition">
            <summary>
            The definition that's being used throughout the parsing process
            </summary>
        </member>
        <member name="F:PowerArgs.ArgHook.HookContext.RevivedProperty">
            <summary>
            This is the value of the current property after it has been converted into its proper .NET type.  It is only available
            to the AfterPopulateProperty hook.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.HookContext.ParserData">
            <summary>
            The raw parser data.  This is not available to the BeforeParse hook.  It may be useful for you to look at, but you should rarely have to change the values.  
            Modify the content of this at your own risk.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgHook.HookContext.GetProperty``1(System.String)">
            <summary>
            Get a value from the context's property bag.
            </summary>
            <typeparam name="T">The type of value you are expecting</typeparam>
            <param name="key">The key for the property you want to get</param>
            <returns>The value or default(T) if no value was found.</returns>
        </member>
        <member name="M:PowerArgs.ArgHook.HookContext.SetProperty``1(System.String,``0)">
            <summary>
            Set a value in the context's property bag.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="key">The key for the property you want to set</param>
            <param name="value">The value of the property to set</param>
        </member>
        <member name="M:PowerArgs.ArgHook.HookContext.HasProperty(System.String)">
            <summary>
            Returns true if the context has a value for the given property.
            </summary>
            <param name="key">The key to check</param>
            <returns>true if the context has a value for the given property, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ArgHook.HookContext.ClearProperty(System.String)">
            <summary>
            Clear a value in the context's property bag.
            </summary>
            <param name="key">The key for the property you want to clear.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.HookContext.CancelAllProcessing">
            <summary>
            Stops all argument processing, hooks, and action invocation as soon as is feasable.  You
            can implement an ArgHook that receives an event when this is called.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.BeforeValidateDefinitionPriority">
            <summary>
            The priority of the BeforeValidateDefinition hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.BeforePrepareUsagePriority">
            <summary>
            The priority of the BeforePrepareUsage hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.BeforeParsePriority">
            <summary>
            The priority of the BeforeParse hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.BeforePopulatePropertiesPriority">
            <summary>
            The priority of the BeforePopulateProperties hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.BeforePopulatePropertyPriority">
            <summary>
            The priority of the BeforePopulateProperty hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.AfterPopulatePropertyPriority">
            <summary>
            The priority of the AfterPopulateProperty hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.AfterPopulatePropertiesPriority">
            <summary>
            The priority of the AfterPopulateProperties hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.BeforeInvokePriority">
            <summary>
            The priority of the BeforeInvoke hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.AfterInvokePriority">
            <summary>
            The priority of the AfterInvoke hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.AfterCancelPriority">
            <summary>
            The priority of the AfterCancel hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgHook.BeforeValidateDefinition(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called before the definition is validated for structural issues
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:PowerArgs.ArgHook.CreateBeforeValidateDefinitionHook(System.Action{PowerArgs.ArgHook.HookContext},System.Int32)">
            <summary>
            Creates a hook that targets the corresponding hook method given an implementation and a priority
            </summary>
            <param name="action">The hook implementation</param>
            <param name="priority">The hook priority (higher executes first)</param>
            <returns>The hook</returns>
        </member>
        <member name="M:PowerArgs.ArgHook.BeforePrepareUsage(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called before the template based usage system prepares the usage documentation
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:PowerArgs.ArgHook.CreateBeforePrepareUsageHook(System.Action{PowerArgs.ArgHook.HookContext},System.Int32)">
            <summary>
            Creates a hook that targets the corresponding hook method given an implementation and a priority
            </summary>
            <param name="action">The hook implementation</param>
            <param name="priority">The hook priority (higher executes first)</param>
            <returns>The hook</returns>
        </member>
        <member name="M:PowerArgs.ArgHook.BeforeParse(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called before the parser ever looks at the command line.  You can do some preprocessing of the 
            raw string arguments here.
            </summary>
            <param name="context">An object that has useful context.  See the documentation of each property for information about when those properties are populated.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.CreateBeforeParseHook(System.Action{PowerArgs.ArgHook.HookContext},System.Int32)">
            <summary>
            Creates a hook that targets the corresponding hook method given an implementation and a priority
            </summary>
            <param name="action">The hook implementation</param>
            <param name="priority">The hook priority (higher executes first)</param>
            <returns>The hook</returns>
        </member>
        <member name="M:PowerArgs.ArgHook.BeforePopulateProperties(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called before the arguments defined in a class are populated.  For actions (or sub commands) this hook will
            get called once for the main class and once for the specified action.
            </summary>
            <param name="context">An object that has useful context.  See the documentation of each property for information about when those properties are populated.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.CreateBeforePopulatePropertiesHook(System.Action{PowerArgs.ArgHook.HookContext},System.Int32)">
            <summary>
            Creates a hook that targets the corresponding hook method given an implementation and a priority
            </summary>
            <param name="action">The hook implementation</param>
            <param name="priority">The hook priority (higher executes first)</param>
            <returns>The hook</returns>
        </member>
        <member name="M:PowerArgs.ArgHook.BeforePopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called before an argument is transformed from a string into a proper type and validated.
            </summary>
            <param name="context">An object that has useful context.  See the documentation of each property for information about when those properties are populated.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.CreateBeforePopulatePropertyHook(System.Action{PowerArgs.ArgHook.HookContext},System.Int32)">
            <summary>
            Creates a hook that targets the corresponding hook method given an implementation and a priority
            </summary>
            <param name="action">The hook implementation</param>
            <param name="priority">The hook priority (higher executes first)</param>
            <returns>The hook</returns>
        </member>
        <member name="M:PowerArgs.ArgHook.AfterPopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called after an argument is transformed from a string into a proper type and validated.
            </summary>
            <param name="context">An object that has useful context.  See the documentation of each property for information about when those properties are populated.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.CreateAfterPopulatePropertyHook(System.Action{PowerArgs.ArgHook.HookContext},System.Int32)">
            <summary>
            Creates a hook that targets the corresponding hook method given an implementation and a priority
            </summary>
            <param name="action">The hook implementation</param>
            <param name="priority">The hook priority (higher executes first)</param>
            <returns>The hook</returns>
        </member>
        <member name="M:PowerArgs.ArgHook.AfterPopulateProperties(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called after the arguments defined in a class are populated.  For actions (or sub commands) this hook will
            get called once for the main class and once for the specified action.
            </summary>
            <param name="context">An object that has useful context.  See the documentation of each property for information about when those properties are populated.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.CreateAfterPopulatePropertiesHook(System.Action{PowerArgs.ArgHook.HookContext},System.Int32)">
            <summary>
            Creates a hook that targets the corresponding hook method given an implementation and a priority
            </summary>
            <param name="action">The hook implementation</param>
            <param name="priority">The hook priority (higher executes first)</param>
            <returns>The hook</returns>
        </member>
        <member name="M:PowerArgs.ArgHook.BeforeInvoke(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called after parsing is complete, but before any Action or Main method is invoked.
            </summary>
            <param name="context">An object that has useful context.  See the documentation of each property for information about when those properties are populated.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.CreateBeforeInvokeHook(System.Action{PowerArgs.ArgHook.HookContext},System.Int32)">
            <summary>
            Creates a hook that targets the corresponding hook method given an implementation and a priority
            </summary>
            <param name="action">The hook implementation</param>
            <param name="priority">The hook priority (higher executes first)</param>
            <returns>The hook</returns>
        </member>
        <member name="M:PowerArgs.ArgHook.AfterInvoke(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called after any Action or Main method is invoked.
            </summary>
            <param name="context">An object that has useful context.  See the documentation of each property for information about when those properties are populated.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.CreateAfterInvokeHook(System.Action{PowerArgs.ArgHook.HookContext},System.Int32)">
            <summary>
            Creates a hook that targets the corresponding hook method given an implementation and a priority
            </summary>
            <param name="action">The hook implementation</param>
            <param name="priority">The hook priority (higher executes first)</param>
            <returns>The hook</returns>
        </member>
        <member name="M:PowerArgs.ArgHook.AfterCancel(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called if CancelAllProcessing() is called on a HookContext object.
            </summary>
            <param name="context">An object that has useful context.  See the documentation of each property for information about when those properties are populated.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.CreateAfterCancelHook(System.Action{PowerArgs.ArgHook.HookContext},System.Int32)">
            <summary>
            Creates a hook that targets the corresponding hook method given an implementation and a priority
            </summary>
            <param name="action">The hook implementation</param>
            <param name="priority">The hook priority (higher executes first)</param>
            <returns>The hook</returns>
        </member>
        <member name="T:PowerArgs.DefaultValueAttribute">
            <summary>
            Use this attribute to set the default value for a parameter.  Note that this only
            works for simple types since only compile time constants can be passed to an attribute.
            </summary>
        </member>
        <member name="P:PowerArgs.DefaultValueAttribute.Value">
            <summary>
            The default value that was specified on the attribute.  Note that the value will get
            converted to a string and then fed into the parser to be revived.
            </summary>
        </member>
        <member name="M:PowerArgs.DefaultValueAttribute.#ctor(System.Object)">
            <summary>
            Creates a new DefaultValueAttribute with the given value.  Note that the value will get
            converted to a string and then fed into the parser to be revived.
            </summary>
            <param name="value">The default value for the property</param>
        </member>
        <member name="M:PowerArgs.DefaultValueAttribute.#ctor">
            <summary>
            Creates a new DefaultValueAttribute without value. Value can be specified in derived class.
            Note that the value will get converted to a string and then fed into the parser to be revived.
            </summary>
        </member>
        <member name="M:PowerArgs.DefaultValueAttribute.BeforePopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            Before the property is revived and validated, if the user didn't specify a value, 
            then substitue the default value.
            
            </summary>
            <param name="Context"></param>
        </member>
        <member name="T:PowerArgs.ArgDefaultValueAttribute">
            <summary>
            Use this attribute to set the default value for a parameter.  Note that this only
            works for simple types since only compile time constants can be passed to an attribute.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgDefaultValueAttribute.#ctor(System.Object)">
            <summary>
            Creates a new ArgDefaultValueAttribute with the given value.  Note that the value will get
            converted to a string and then fed into the parser to be revived.
            </summary>
            <param name="value">The default value for the property</param>
        </member>
        <member name="T:PowerArgs.HelpHook">
            <summary>
            A hook that lets you turn a boolean property into a command line switch that short circuits processing and displays help.
            </summary>
        </member>
        <member name="P:PowerArgs.HelpHook.UsageTemplateProviderType">
            <summary>
            A type that should implement IUsageTemplateProvider.  When specified the help hook will use the GenerateUsageFromTemplate function rather than the obsolete GenerateStyledUsage function.
            </summary>
        </member>
        <member name="P:PowerArgs.HelpHook.WriteHelp">
            <summary>
            If true (which it is by default) the hook will write the help after the target property is populated.  If false, processing will still stop, but
            the help will not be written (yoy will have to do it yourself).
            </summary>
        </member>
        <member name="E:PowerArgs.HelpHook.UsageWritten">
            <summary>
            An event that fires when the hook writes usage to the console
            </summary>
        </member>
        <member name="M:PowerArgs.HelpHook.#ctor">
            <summary>
            Creates a new help hook instance
            </summary>
        </member>
        <member name="M:PowerArgs.HelpHook.BeforePopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            Makes sure the target is a boolean
            </summary>
            <param name="context">Context passed by the parser</param>
        </member>
        <member name="M:PowerArgs.HelpHook.AfterPopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            This gets called after the target property is populated.  It cancels processing.
            </summary>
            <param name="context">Context passed by the parser</param>
        </member>
        <member name="M:PowerArgs.HelpHook.AfterCancel(PowerArgs.ArgHook.HookContext)">
            <summary>
            Writes the help as long as WriteHelp is true
            </summary>
            <param name="context">Context passed by the parser</param>
        </member>
        <member name="T:PowerArgs.PromptIfEmpty">
            <summary>
            A hook that can be put on an argument so that if a user specifies the argument with no value they will get prompted for that value with a rich prompt
            that supports tab completion and syntax highlighting.
            </summary>
        </member>
        <member name="P:PowerArgs.PromptIfEmpty.TabCompletionHandlerType">
            <summary>
            Gets or sets the type to be used for global tab completion.  The type must implement ITabCompletionHandler
            </summary>
        </member>
        <member name="P:PowerArgs.PromptIfEmpty.HighlighterConfiguratorType">
            <summary>
            Gets or sets the type to use inject custom syntax highlighting to the command prompt.  The type must implement IHighlighterConfigurator
            </summary>
        </member>
        <member name="P:PowerArgs.PromptIfEmpty.KeepAsking">
            <summary>
            If set to true the prompt will only run once on empty.  Program execution will continue if the value given to the prompt is empty
            </summary>
        </member>
        <member name="M:PowerArgs.PromptIfEmpty.BeforePopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            Prompts the user to enter a value for the given property in the case that the option was specified with no value
            </summary>
            <param name="context">the parser context</param>
        </member>
        <member name="T:PowerArgs.StickyArg">
            <summary>
            A useful arg hook that will store the last used value for an argument and repeat it the next time.
            </summary>
        </member>
        <member name="M:PowerArgs.StickyArg.#ctor">
            <summary>
            Marks a property as a sticky arg.  Use the default location to store sticky arguments (AppData/Roaming/PowerArgs/EXE_NAME.txt)
            </summary>
        </member>
        <member name="M:PowerArgs.StickyArg.#ctor(System.String)">
            <summary>
            Marks a property as a sticky arg.  Use the provided location to store sticky arguments (AppData/Roaming/PowerArgs/EXE_NAME.txt)
            </summary>
        </member>
        <member name="M:PowerArgs.StickyArg.BeforePopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            If the user didn't specify a value on the command line then the StickyArg will try to load the last used
            value.
            </summary>
            <param name="Context">Used to see if the property was specified.</param>
        </member>
        <member name="M:PowerArgs.StickyArg.AfterPopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            If the given property has a non null value then that value is persisted for the next use.
            </summary>
            <param name="Context">Used to see if the property was specified.</param>
        </member>
        <member name="M:PowerArgs.StickyArg.GetStickyArg(System.String)">
            <summary>
            Gets the value of the given sticky arg
            </summary>
            <param name="name">the argument key</param>
            <returns>the sticky value or null if there is not one</returns>
        </member>
        <member name="M:PowerArgs.StickyArg.SetStickyArg(System.String,System.String)">
            <summary>
            Sets the value of a sticky arg
            </summary>
            <param name="name">The identifier of the arg</param>
            <param name="value">the sticky value</param>
        </member>
        <member name="T:PowerArgs.IStickyArgPersistenceProvider">
            <summary>
            An interface used to implement custom saving and loading of persistent (sticky) args.
            </summary>
        </member>
        <member name="M:PowerArgs.IStickyArgPersistenceProvider.Save(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
            <summary>
            This method is called when it is time to save the sticky args.
            </summary>
            <param name="stickyArgs">The names and values of the arguments to save.</param>
            <param name="pathInfo">The string that was passed to the StickyArg attribue (usually a file path).</param>
        </member>
        <member name="M:PowerArgs.IStickyArgPersistenceProvider.Load(System.String)">
            <summary>
            This method is called when it is time to load the sticky args.
            </summary>
            <param name="pathInfo">The string that was passed to the StickyArg attribue (usually a file path).</param>
            <returns>The loaded sticky args.</returns>
        </member>
        <member name="T:PowerArgs.StickyArgPersistence">
            <summary>
            An attribute you can put on a type in order to override how StickyArg properties are saved and loaded.
            </summary>
        </member>
        <member name="P:PowerArgs.StickyArgPersistence.PersistenceProvider">
            <summary>
            Gets the provider that will be used to save and load sticky args.
            </summary>
        </member>
        <member name="M:PowerArgs.StickyArgPersistence.#ctor(System.Type)">
            <summary>
            Creates a new StickyArgPersistence attribute given the type of the persistence provider.
            </summary>
            <param name="persistenceProviderType">The type that implements IStickyArgPersistenceProvider and defines a default constructor.</param>
        </member>
        <member name="T:PowerArgs.ArgumentAwareTabCompletionAttribute">
            <summary>
            An attribute that can be placed on an argument property that adds argument aware tab completion for users who press the tab key while
            in the context of the targeted argument.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentAwareTabCompletionAttribute.CompletionSourceType">
            <summary>
            The tab completion source type that will be used to implement tab completion
            </summary>
        </member>
        <member name="M:PowerArgs.ArgumentAwareTabCompletionAttribute.#ctor(System.Type)">
            <summary>
            Creates a new ArgumentAwareTabCompletionAttribute given a completion source type
            </summary>
            <param name="completionSourceType"></param>
        </member>
        <member name="T:PowerArgs.TabCompletion">
            <summary>
            A hook that takes over the command line and provides tab completion for known strings when the user presses
            the tab key.
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletion.CompletionSourceType">
            <summary>
            Gets or sets the type to be used for global tab completion.  The type should implement ITabCompletionSource or ISmartTabCompletionSource
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletion.HighlighterConfiguratorType">
            <summary>
            Gets or sets the type to be used to dynamically configure syntax highlighting.  The type must implement IHighlighterConfigurator.
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletion.Indicator">
            <summary>
            When this indicator is the only argument the user specifies that triggers the hook to enhance the command prompt.  By default, the indicator is the empty string.
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletion.HistoryToSave">
            <summary>
            If this is > 0 then PowerArgs will save this many previous executions of the command line to your application data folder.
            Users can then access the history by pressing arrow up or down from the enhanced command prompt.
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletion.HistoryFileName">
            <summary>
            The location of the history file name (AppData/PowerArgs/EXE_NAME.TabCompletionHistory.txt
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletion.ExeName">
            <summary>
            The name of your program (leave null and PowerArgs will try to detect it automatically)
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletion.REPL">
            <summary>
            If true, then you must use Args.InvokeAction or Args.InvokeMain instead of Args.Parse.  Your user
            will get an interactive prompt that loops until they specify the REPLExitIndicator.
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletion.REPLExitIndicator">
            <summary>
            The string users can specify in order to exit the REPL (defaults to string.Empty)
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletion.REPLWelcomeMessage">
            <summary>
            The message to display to the user when the REPL starts.  The default is Type a command or '{{Indicator}}' to exit.
            You can customize this message and use {{Indicator}} for the placeholder for your exit indicator.
            </summary>
        </member>
        <member name="M:PowerArgs.TabCompletion.#ctor(System.String)">
            <summary>
            Creates a new tab completion hook.
            </summary>
            <param name="indicator">When this indicator is the only argument the user specifies that triggers the hook to enhance the command prompt.  By default, the indicator is the empty string.</param>
        </member>
        <member name="M:PowerArgs.TabCompletion.#ctor(System.Type,System.String)">
            <summary>
            Creates a new tab completion hook given a custom tab completion implementation.
            </summary>
            <param name="completionSource">A type that implements ITabCompletionSource such as SimpleTabCompletionSource</param>
            <param name="indicator">When this indicator is the only argument the user specifies that triggers the hook to enhance the command prompt.  By default, the indicator is the empty string.</param>
        </member>
        <member name="M:PowerArgs.TabCompletion.BeforeParse(PowerArgs.ArgHook.HookContext)">
            <summary>
            Before PowerArgs parses the args, this hook inspects the command line for the indicator and if found 
            takes over the command line and provides tab completion.
            </summary>
            <param name="context">The context used to inspect the command line arguments.</param>
        </member>
        <member name="M:PowerArgs.TabCompletion.ClearHistory">
            <summary>
            Clears all history saved on disk
            </summary>
        </member>
        <member name="T:PowerArgs.AllowUnexpectedArgs">
            <summary>
            Put this attribute on the class that defines your arguments to specify that PowerArgs
            should allow extra command line values that don't match any explicitly defined arguments.
            Note that this means that PowerArgs will not be able to tell the difference between an extra
            argument and a misspelled argument.  
            </summary>
        </member>
        <member name="T:PowerArgs.ArgActionMethod">
            <summary>
            Use this attribute to annotate methods that represent your program's actions.  
            </summary>
        </member>
        <member name="T:PowerArgs.ArgActionType">
            <summary>
            Use this attribute if your action implementation methods are defined in a type other than the 
            type being passed to Args.ParseAction() or Args.InvokeAction().  You can add multiple attributes
            of this type if you want to combine actions from multiple classes.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgActionType.ActionType">
            <summary>
            The type that implements your action methods.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgActionType.#ctor(System.Type)">
            <summary>
            Creates a new ArgActionType attribute given the type that contains the action implementation.
            </summary>
            <param name="t">The type that implements your action methods.</param>
        </member>
        <member name="T:PowerArgs.ArgActions">
            <summary>
            An attribute you can put on classes that contain arg action methods that can be imported into a program
            that uses an [ArgActionResolver] attribute.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgActionResolver">
            <summary>
            An attribute you can put on a program's main scaffold class in order to import external types that contain
            action methods.  By default, this resolver will search the program's entry assembly for types that contain the
            [ArgActions] attribute.  You can derive from this class and override the ResolveActionTypes method if you want to
            perform custom resolution of actions.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgActionResolver.ResolveActionTypes">
            <summary>
            Searches the program's entry assembly for types that contain an [ArgActions] attribute and returns those
            types so that PowerArgs can import them into the running program.  This method is marked as virtual so that
            classes that derive from ArgActionResolver can implement their own resolution strategy.
            </summary>
            <returns>matching types</returns>
        </member>
        <member name="T:PowerArgs.ArgCopyright">
            <summary>
            Use this attribute to describe a copyright string that can appear in the usage documentation
            </summary>
        </member>
        <member name="P:PowerArgs.ArgCopyright.Value">
            <summary>
            The copyright value
            </summary>
        </member>
        <member name="M:PowerArgs.ArgCopyright.#ctor(System.String)">
            <summary>
            Creates a new ArgCopyright attribute.
            </summary>
            <param name="value">The copyright value</param>
        </member>
        <member name="T:PowerArgs.ArgDescription">
            <summary>
            Use this attribute to describe your argument property.  This will show up in the auto generated
            usage documentation.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgDescription.Description">
            <summary>
            A brief description of your argument property.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgDescription.#ctor(System.String)">
            <summary>
            Creates a new ArgDescription attribute.
            </summary>
            <param name="description">A brief description of your argument property.</param>
        </member>
        <member name="T:PowerArgs.ArgExample">
            <summary>
            Use this attribute to provide an example of how to use your program.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgExample.HasTitle">
            <summary>
            Returns true if this example has a title, false otherwwise
            </summary>
        </member>
        <member name="P:PowerArgs.ArgExample.Title">
            <summary>
            An optional title for this example
            </summary>
        </member>
        <member name="P:PowerArgs.ArgExample.Example">
            <summary>
            The example command line.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgExample.Description">
            <summary>
            A brief description of what this example does.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgExample.#ctor(System.String,System.String)">
            <summary>
            Creates a new ArgExample class
            </summary>
            <param name="example">The example command line.</param>
            <param name="description">A brief description of what this example does.</param>
        </member>
        <member name="T:PowerArgs.ArgExceptionPolicy">
            <summary>
            Enum used to specify how user errors (ArgExceptions) should be handled by the parser.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgExceptionPolicy.DontHandleExceptions">
            <summary>
            The default, PowerArgs will throw these exceptions for your program to handle.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgExceptionPolicy.StandardExceptionHandling">
            <summary>
            PowerArgs will print the user friendly error message as well as the auto-generated usage documentation
            for the program.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgExceptionBehavior">
            <summary>
            Use this attrbiute to opt into standard error handling of user input errors.  
            </summary>
        </member>
        <member name="P:PowerArgs.ArgExceptionBehavior.Policy">
            <summary>
            The policy to use, defaults to DontHandleExceptions.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgExceptionBehavior.UsageTemplateProviderType">
            <summary>
            A type that should implement IUsageTemplateProvider.  When specified the help hook will use the GenerateUsageFromTemplate function rather than the obsolete GenerateStyledUsage function.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgExceptionBehavior.#ctor(PowerArgs.ArgExceptionPolicy)">
            <summary>
            Creates a new ArgExceptionBehavior attributes with the given policy.
            </summary>
            <param name="policy">The policy to use, defaults to DontHandleExceptions.</param>
        </member>
        <member name="T:PowerArgs.ArgIgnoreAttribute">
            <summary>
            Use this attribute if you want PowerArgs to ignore a property completely.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgIgnoreCase">
            <summary>
            Use this argument on your class, property, or action method to enforce case sensitivity.  By default,
            case is ignored.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgIgnoreCase.IgnoreCase">
            <summary>
            Flag to set whether or not case is ignored.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgIgnoreCase.#ctor(System.Boolean)">
            <summary>
            Create a new ArgIgnoreCase attribute.
            </summary>
            <param name="ignore">Whether or not to ignore case</param>
        </member>
        <member name="T:PowerArgs.ArgEnforceCase">
            <summary>
            Use this argument on your class or property to enforce case sensitivity.  By default,
            case is ignored.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgEnforceCase.#ctor">
            <summary>
            Create a new ArgEnforceCase attribute.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgPosition">
            <summary>
            Use this attribute if you want users to be able to specify an argument without specifying the name, 
            but rather by it's position on the command line.  All positioned arguments must come before any named arguments.
            Zero '0' represents the first position.  If you are using the Action framework then subcommands must start at
            position 1.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgPosition.Position">
            <summary>
            The expected position of this argument
            </summary>
        </member>
        <member name="M:PowerArgs.ArgPosition.#ctor(System.Int32)">
            <summary>
            Creates a new ArgPositionAttribute
            </summary>
            <param name="pos">The expected position of this argument</param>
        </member>
        <member name="T:PowerArgs.ArgProductName">
            <summary>
            Use this attribute to describe your proper program name (which might be longer than exeName). This string that will appear in the usage documentation
            </summary>
        </member>
        <member name="P:PowerArgs.ArgProductName.Value">
            <summary>
            The product name value
            </summary>
        </member>
        <member name="M:PowerArgs.ArgProductName.#ctor(System.String)">
            <summary>
            Creates a new ArgProductName attribute.
            </summary>
            <param name="value">The product name value</param>
        </member>
        <member name="T:PowerArgs.ArgProductVersion">
            <summary>
            Use this attribute to describe a version string that can appear in the usage documentation
            </summary>
        </member>
        <member name="P:PowerArgs.ArgProductVersion.Value">
            <summary>
            The copyright value
            </summary>
        </member>
        <member name="M:PowerArgs.ArgProductVersion.#ctor(System.String)">
            <summary>
            Creates a new ArgProductVersion attribute.
            </summary>
            <param name="value">The version value</param>
        </member>
        <member name="T:PowerArgs.ArgReviverAttribute">
            <summary>
            The attribute used when you want to create an arg reviver. You should put this on public static methods 
            that take 2 string parameters (the first represents the name of the property, the second represents the string value
            and the return type is the type that you are reviving (or converting) the string into.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgShortcutPolicy">
            <summary>
            An enum to represent argument shortcut policies
            </summary>
        </member>
        <member name="F:PowerArgs.ArgShortcutPolicy.Default">
            <summary>
            No special behavior.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgShortcutPolicy.NoShortcut">
            <summary>
            Pass this value to the ArgShortcut attribute's constructor to indicate that the given property
            does not support a shortcut.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgShortcutPolicy.ShortcutsOnly">
            <summary>
            This indicates that the .NET property named should not be used as an indicator.  Instead,
            only the values in the other ArgShortcut attributes should be used.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgShortcut">
            <summary>
            Use this attribute to override the shortcut that PowerArgs automatically assigns to each property.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgShortcut.Shortcut">
            <summary>
            The shortcut for the given property
            </summary>
        </member>
        <member name="P:PowerArgs.ArgShortcut.Policy">
            <summary>
            Get the ShortcutPolicy for this attribute.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgShortcut.#ctor(System.String)">
            <summary>
            Creates a new ArgShortcut attribute with a specified value.
            </summary>
            <param name="shortcut">The value of the new shortcut.</param>
        </member>
        <member name="M:PowerArgs.ArgShortcut.#ctor(PowerArgs.ArgShortcutPolicy)">
            <summary>
            Creates a new ArgShortcut using the given policy
            </summary>
            <param name="policy"></param>
        </member>
        <member name="T:PowerArgs.ArgContextualAssistant">
            <summary>
            An attribute that you can add to argument properties or parameters that lets you inject custom contextual assistant logic into the PowerArgs enhanced command line.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgContextualAssistant.ContextAssistProviderType">
            <summary>
            Gets the type to be used for contexual assistance.  It must implement IContextAssistProvider.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgContextualAssistant.#ctor(System.Type)">
            <summary>
            Initializes the metadata given the type that implements IContextAssistProvider.
            </summary>
            <param name="contextAssistProviderType">a type that implements IContextAssistProvider</param>
        </member>
        <member name="T:PowerArgs.NonInteractiveIndicator">
            <summary>
            An attribute that can be specified on a boolean argument to indicate a non interactive session.  
            When used, it sets IsNonInteractive on the current definition.
            </summary>
        </member>
        <member name="M:PowerArgs.NonInteractiveIndicator.#ctor">
            <summary>
            Creates a new NonInteractiveIndicator attribute
            </summary>
        </member>
        <member name="M:PowerArgs.NonInteractiveIndicator.BeforeParse(PowerArgs.ArgHook.HookContext)">
            <summary>
            If the current argument is a boolean and it is specified on the command line then
            this hook sets the IsNonInteractive flag on the current argument definition.
            </summary>
            <param name="context"></param>
        </member>
        <member name="T:PowerArgs.OmitFromUsageDocs">
            <summary>
            An attribute that, when placed on a property or action method, makes sure that property/action does not appear
            in the output created by the ArgUsage class (the class that auto generates usage documentation).
            </summary>
        </member>
        <member name="T:PowerArgs.IDocumentExpressionProvider">
            <summary>
            An object that can take a replacement key, a set of parameters, an optional body, and transform it into a document expression.
            </summary>
        </member>
        <member name="M:PowerArgs.IDocumentExpressionProvider.CreateExpression(PowerArgs.DocumentExpressionContext)">
            <summary>
            Transforms document expression context into a document expression
            </summary>
            <param name="context">Context about the expression being parsed</param>
            <returns>The formal expression that can be evaluated into text</returns>
        </member>
        <member name="T:PowerArgs.DocumentExpressionContext">
            <summary>
            An object that contains contextual information that is useful for expression providers
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentExpressionContext.OpenToken">
            <summary>
            The opening token of the replacement expression '{{'
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentExpressionContext.CloseToken">
            <summary>
            The closing topen of the replacement expression '!}}' or '!{{TAG}}'
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentExpressionContext.ReplacementKeyToken">
            <summary>
            The replacement key token.  Example: 'if' in {{ if Foo }}
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentExpressionContext.Parameters">
            <summary>
            The parameters of the replacement.  Example: ["Foo", "Bar"] in '{{ someTag Foo Bar !}}'
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentExpressionContext.Body">
            <summary>
            The body text between the tags.  Not populated if the tag is quick terminated.
            </summary>
        </member>
        <member name="T:PowerArgs.DynamicExpressionProviderAttribute">
            <summary>
            An attribute that can be added to a class that implements IDocumentExpressionProvider.  This attributes indicates that the provider can be
            dynamically registered.
            </summary>
        </member>
        <member name="P:PowerArgs.DynamicExpressionProviderAttribute.Key">
            <summary>
            The replacement key (e.g. 'each' in {{each foo in bar }}) to use when the given provider is registered
            </summary>
        </member>
        <member name="M:PowerArgs.DynamicExpressionProviderAttribute.#ctor(System.String)">
            <summary>
            Creates a new DynamicExpressionProviderAttribute given a key
            </summary>
            <param name="key"></param>
        </member>
        <member name="T:PowerArgs.DocumentExpressionParser">
            <summary>
            A class that can parse a collection of document tokens into a collection of expressions
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentExpressionParser.RegisteredReplacementExpressionProviderKeys">
            <summary>
            Gets a list of registered expression provider keys
            </summary>
        </member>
        <member name="M:PowerArgs.DocumentExpressionParser.#ctor">
            <summary>
            Creates a new document expression parser and registers the built in expression provider types.
            </summary>
        </member>
        <member name="M:PowerArgs.DocumentExpressionParser.RegisterDynamicReplacementExpressionProviders(System.Reflection.Assembly,System.Boolean)">
            <summary>
            Searches the given assembly for IDocumentExpressionProvider types that have the DynamicExpressionProviderAttribute attribute and registers those providers
            with this parser.  The type needs to have a default constructor.
            </summary>
            <param name="target">The assembly to search</param>
            <param name="allowOverrideExistingKeys">If true, providers with keys that are already exist with override the existing providers.  If false, an exception will be thrown if a conflict is found.</param>
        </member>
        <member name="M:PowerArgs.DocumentExpressionParser.RegisterReplacementExpressionProvider(System.String,PowerArgs.IDocumentExpressionProvider,System.Boolean)">
            <summary>
            Manually registers the given expression provider using the given key.  
            </summary>
            <param name="replacementKey">The unique key for the replacement provider (e.g. 'each' in {{each foo in bar}}</param>
            <param name="provider">The provider to register</param>
            <param name="allowOverrideExistingKeys">If true, allow this provider to replace an existing provider registered with the same key .  If false, an exception will be thrown if a conflict is found.</param>
        </member>
        <member name="M:PowerArgs.DocumentExpressionParser.UnregisterReplacementExpressionProvider(System.String)">
            <summary>
            Unregisters the expression provider with the given key
            </summary>
            <param name="replacementKey">The key of the provider to unregister</param>
        </member>
        <member name="M:PowerArgs.DocumentExpressionParser.Parse(System.Collections.Generic.IEnumerable{PowerArgs.DocumentToken})">
            <summary>
            Parses the given tokens into document expressions that can then be evaluated against a data context.
            </summary>
            <param name="tokens">The tokens to parse</param>
            <returns>a list of document expressions</returns>
        </member>
        <member name="T:PowerArgs.DocumentRenderException">
            <summary>
            An exception that is thrown while trying to render a templated document
            </summary>
        </member>
        <member name="T:PowerArgs.DocumentRenderException.NoTokenReason">
            <summary>
            A reason why a token was not provided when creating this exception
            </summary>
        </member>
        <member name="F:PowerArgs.DocumentRenderException.NoTokenReason.EndOfString">
            <summary>
            Indicates that there is no token specified because there was an unexpected end of string.
            </summary>
        </member>
        <member name="M:PowerArgs.DocumentRenderException.#ctor(System.String,PowerArgs.DocumentToken)">
            <summary>
            Creates an exception given a message and the offending token
            </summary>
            <param name="msg">The exception message</param>
            <param name="offendingToken">The offending token</param>
        </member>
        <member name="M:PowerArgs.DocumentRenderException.#ctor(System.String,PowerArgs.DocumentRenderException.NoTokenReason)">
            <summary>
            Creates an exception given a message and a reason why no token was provided
            </summary>
            <param name="msg">The exception message</param>
            <param name="reason">The reason why no token was provided</param>
        </member>
        <member name="T:PowerArgs.DocumentTemplateInfo">
            <summary>
            A class that describes a document template
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentTemplateInfo.Value">
            <summary>
            The template text value
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentTemplateInfo.SourceLocation">
            <summary>
            The template's source location.  This is usually a file location, but it does not have to be.
            </summary>
        </member>
        <member name="T:PowerArgs.DocumentRenderer">
            <summary>
            A class used to render template documents.
            </summary>
        </member>
        <member name="M:PowerArgs.DocumentRenderer.#ctor">
            <summary>
            Creates a new DocumentRenderer.
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentRenderer.ExpressionParser">
            <summary>
            Gets the underlying expression parser
            </summary>
        </member>
        <member name="M:PowerArgs.DocumentRenderer.Render(PowerArgs.DocumentTemplateInfo,System.Object)">
            <summary>
            Renders a document from a template, using a plain old .NET object as a data source.
            </summary>
            <param name="template">The template to use</param>
            <param name="data">The data source to use for template replacements</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.DocumentRenderer.Render(System.String,System.Object,System.String)">
            <summary>
            Renders a document from a template, using a plain old .NET object as a data source.
            </summary>
            <param name="template">The template to use</param>
            <param name="data">The data source to use for template replacements</param>
            <param name="sourceFileLocation">The source of the template, used when reporting back errors</param>
            <returns>The rendered document</returns>
        </member>
        <member name="M:PowerArgs.DocumentRenderer.RegisterTemplate(System.String,PowerArgs.DocumentTemplateInfo)">
            <summary>
            Register a named tamplate that can be accessed by other templates
            </summary>
            <param name="name">The unique name of the template</param>
            <param name="info">The template info</param>
        </member>
        <member name="M:PowerArgs.DocumentRenderer.UnregisterTemplate(System.String)">
            <summary>
            Unregister a named template.
            </summary>
            <param name="name">The name of the template to unregister</param>
        </member>
        <member name="T:PowerArgs.DocumentRendererContext">
            <summary>
            An object that tracks information about document rendering
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentRendererContext.LocalVariables">
            <summary>
            The current set of local variables that can be referenced by a template
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentRendererContext.RootDataObject">
            <summary>
            The root data object that is bound to the document template
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentRendererContext.DocumentRenderer">
            <summary>
            The object that is currently rendering a document
            </summary>
        </member>
        <member name="M:PowerArgs.DocumentRendererContext.#ctor(System.Object)">
            <summary>
            Creates a render context from a root data object
            </summary>
            <param name="rootDataObject">The root data object that will be bound to a template</param>
        </member>
        <member name="M:PowerArgs.DocumentRendererContext.RenderDynamicContent(System.String,PowerArgs.DocumentToken)">
            <summary>
            Dynamically renders the given template.
            </summary>
            <param name="dynamicTemplate">The template to render</param>
            <param name="nestedToken">The token in the original document that resulted in dynamic rendering</param>
            <returns>The rendered content</returns>
        </member>
        <member name="M:PowerArgs.DocumentRendererContext.RenderBody(System.Collections.Generic.IEnumerable{PowerArgs.DocumentToken})">
            <summary>
            Renders the given tokens, which are generally the body of a replacement expression.
            </summary>
            <param name="body">The tokens to render</param>
            <returns>the rendered content</returns>
        </member>
        <member name="M:PowerArgs.DocumentRendererContext.EvaluateExpression(System.String)">
            <summary>
            Evaluates the given expression and returns the result.  The expression can refer to a local variable (e.g. 'somevariable'), 
            a path starting from a localVariable (e.g. 'somevariable.SomeProperty.SomeOtherProperty'), or a path starting from the root
            data object (e.g. if the root was of type 'Person' you could say 'FirstName', assuming the Person type has a property called 'FirstName').
            </summary>
            <param name="expressionText">The expression text</param>
            <returns>The resolved value as a .NET object</returns>
        </member>
        <member name="T:PowerArgs.DocumentTokenType">
            <summary>
            An enum defining the types of tokens that can appear in a templated document
            </summary>
        </member>
        <member name="F:PowerArgs.DocumentTokenType.ReplacementKey">
            <summary>
            Indicates the Key of a replacement tag.  Example: 'each' in '{{each foo in bar}}'
            </summary>
        </member>
        <member name="F:PowerArgs.DocumentTokenType.ReplacementParameter">
            <summary>
            Indicates a parameter in a replacement tag.  Example: 'foo', 'in', and 'bar' in '{{each foo in bar}}'
            </summary>
        </member>
        <member name="F:PowerArgs.DocumentTokenType.PlainText">
            <summary>
            Text that is not transformed by the document renderer
            </summary>
        </member>
        <member name="F:PowerArgs.DocumentTokenType.BeginReplacementSegment">
            <summary>
            Indicates the beginning of a replacement tag '{{'.
            </summary>
        </member>
        <member name="F:PowerArgs.DocumentTokenType.EndReplacementSegment">
            <summary>
            Indicates the end of a replacement segment '}}'
            </summary>
        </member>
        <member name="F:PowerArgs.DocumentTokenType.BeginTerminateReplacementSegment">
            <summary>
            Indicates the beginning of a termination segment '!{{'
            </summary>
        </member>
        <member name="F:PowerArgs.DocumentTokenType.QuickTerminateReplacementSegment">
            <summary>
            Indicates that a replacement segment has no body and this is the end of the segment '!}}'
            </summary>
        </member>
        <member name="T:PowerArgs.DocumentToken">
            <summary>
            A class that represents a token in a templated document
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentToken.TokenType">
            <summary>
            The type of this token
            </summary>
        </member>
        <member name="M:PowerArgs.DocumentToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new document token
            </summary>
            <param name="initialValue">The initial value of the token</param>
            <param name="startIndex">the zero based character index of this token in a document template</param>
            <param name="line">The line number of this token in a document template (starts at 1)</param>
            <param name="col">The column number of this token in a document template (starts at 1)</param>
        </member>
        <member name="M:PowerArgs.DocumentToken.GetTokenTypeValue(PowerArgs.DocumentTokenType)">
            <summary>
            Gets the constant string value of a given token type.  This method will throw an exception if the
            type provided does not map to a constant string value.
            </summary>
            <param name="type">The type to lookup</param>
            <returns>The literal string value expected of a token of the given type</returns>
        </member>
        <member name="M:PowerArgs.DocumentToken.TryGetTokenTypeValue(PowerArgs.DocumentTokenType,System.String@)">
            <summary>
            Tries to get the constant string value of a given token type.  This method will return false for types that don't
            map to a constant string value.
            </summary>
            <param name="type">The type to lookup</param>
            <param name="val">The literal string value expected of a token of the given type</param>
            <returns>true if 'val' was populated, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.DocumentToken.TryParseDocumentTokenType(System.String,PowerArgs.DocumentTokenType@)">
            <summary>
            Tries to parse a literal string value to a well known document token type.
            </summary>
            <param name="stringVal">The value to try to parse</param>
            <param name="type">The reference to populate if parsing is successful</param>
            <returns>True if the string could be successfully mapped to a DocumentTokenType, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.DocumentToken.Tokenize(System.String,System.String)">
            <summary>
            Tokenizes the given text into a list of DocumentToken objects.
            </summary>
            <param name="text">The text to tokenize</param>
            <param name="sourceLocation">A string describing the source of the text.  This could be a text file path or some other identifier.</param>
            <returns>A list of tokens</returns>
        </member>
        <member name="T:PowerArgs.EachExpression">
            <summary>
            An expression used to expand a portion of a document template for each element in a collection
            </summary>
        </member>
        <member name="P:PowerArgs.EachExpression.IterationVariableNameToken">
            <summary>
            Gets the token in the document that represents the iteration variable name (e.g. 'element' in {{each element in collection}})
            </summary>
        </member>
        <member name="P:PowerArgs.EachExpression.CollectionVariableExpressionToken">
            <summary>
            Gets the token in the document that represents the collection evaluation expression (e.g. 'collection' in {{each element in collection}})
            </summary>
        </member>
        <member name="P:PowerArgs.EachExpression.Body">
            <summary>
            Gets the body of the each expression.  This body will be evaluated once fore each element in the collection.
            </summary>
        </member>
        <member name="M:PowerArgs.EachExpression.#ctor(PowerArgs.DocumentToken,PowerArgs.DocumentToken,System.Collections.Generic.IEnumerable{PowerArgs.DocumentToken})">
            <summary>
            Creates a new each expression given an iteration variable name, a collection expression, and a body.
            </summary>
            <param name="iterationVariable">The name to assign to ther variable representing the current element in the template</param>
            <param name="collectionExpression">The expression used to determine the collection to enumerate</param>
            <param name="body">The body of the each loop</param>
        </member>
        <member name="M:PowerArgs.EachExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            Evaluates the each loop
            </summary>
            <param name="context">The context that contains information about the document being rendered</param>
            <returns>The rendered contents of the each loop</returns>
        </member>
        <member name="T:PowerArgs.EachExpressionProvider">
            <summary>
            A class that can take in document replacement info and convert it into a document expression that represents an each loop.
            </summary>
        </member>
        <member name="M:PowerArgs.EachExpressionProvider.CreateExpression(PowerArgs.DocumentExpressionContext)">
            <summary>
            Takes in document replacement info and converts it into a document expression that represents an each loop.
            </summary>
            <param name="context">Context about the expression being parsed</param>
            <returns>The parsed each expression</returns>
        </member>
        <member name="T:PowerArgs.EvalExpression">
            <summary>
            The core expression that knows how to evaluate C# object expressions like property navigation, including indexed properties.
            </summary>
        </member>
        <member name="P:PowerArgs.EvalExpression.EvalToken">
            <summary>
            Gets the evaluation token that will be evaluated against a data context
            </summary>
        </member>
        <member name="P:PowerArgs.EvalExpression.ForegroundColorToken">
            <summary>
            The optional foreground color token that can be used to customize the color of the resulting value
            </summary>
        </member>
        <member name="P:PowerArgs.EvalExpression.BackgroundColorToken">
            <summary>
            The optional background color token that can be used to customize the color of the resulting value
            </summary>
        </member>
        <member name="P:PowerArgs.EvalExpression.FG">
            <summary>
            Gets the ConsoleColor that matches the provided foreground color token, if it was provided.
            </summary>
        </member>
        <member name="P:PowerArgs.EvalExpression.BG">
            <summary>
            Gets the ConsoleColor that matches the provided background color token, if it was provided.
            </summary>
        </member>
        <member name="M:PowerArgs.EvalExpression.#ctor(PowerArgs.DocumentToken)">
            <summary>
            Creates an eval expression given a token that represents the expression to evaluate
            </summary>
            <param name="evalToken">The token containing the expression to evaluate</param>
        </member>
        <member name="M:PowerArgs.EvalExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            Evaluates the evaluation expression against a data context, optionally setting the console color if the expression contains those parameters
            </summary>
            <param name="context">The datta context to evaluate against</param>
            <returns>The result of the evaluation as a ConsoleString</returns>
        </member>
        <member name="T:PowerArgs.EvalExpressionProvider">
            <summary>
            The provider that can create an eval expression from template replacement info
            </summary>
        </member>
        <member name="M:PowerArgs.EvalExpressionProvider.CreateExpression(PowerArgs.DocumentExpressionContext)">
            <summary>
            Creates an eval expression given template replacement info
            </summary>
            <param name="context">The context that contains information about the document being rendered</param>
            <returns></returns>
        </member>
        <member name="T:PowerArgs.IDocumentExpression">
            <summary>
            An interface that defines a signature for evaluating an expression against a data context to render a ConsoleString.
            </summary>
        </member>
        <member name="M:PowerArgs.IDocumentExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            The expression should use it's metadata to evaluate itself against the given data context.
            </summary>
            <param name="context">The data context</param>
            <returns>The evaluated ConsoleString.</returns>
        </member>
        <member name="T:PowerArgs.IfExpression">
            <summary>
            An expression that allows a portion of a document template to be rendered only if some condition is true
            </summary>
        </member>
        <member name="P:PowerArgs.IfExpression.IfExpressionToken">
            <summary>
            The token representing the conditional expression.  
            </summary>
        </member>
        <member name="P:PowerArgs.IfExpression.Body">
            <summary>
            The contents of the expression to render only if the condition is true
            </summary>
        </member>
        <member name="M:PowerArgs.IfExpression.#ctor(PowerArgs.DocumentToken,System.Collections.Generic.IEnumerable{PowerArgs.DocumentToken})">
            <summary>
            Creates a new if expression given a conditional token and a body
            </summary>
            <param name="ifExpressionToken">The token containing the conditional expression</param>
            <param name="body">The body of the document to render only if the condition evaluates to true</param>
        </member>
        <member name="M:PowerArgs.IfExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            Evaluates the conditional expression against the given data context, rendering the body only if it is true.
            </summary>
            <param name="context">The data context to use when evaluating the conditional expression</param>
            <returns>The rendered body if the conditional was true, an empty string otherwise</returns>
        </member>
        <member name="T:PowerArgs.IfNotExpression">
            <summary>
            An expression that allows a portion of a document template to be rendered only if some condition is not true
            </summary>
        </member>
        <member name="M:PowerArgs.IfNotExpression.#ctor(PowerArgs.DocumentToken,System.Collections.Generic.IEnumerable{PowerArgs.DocumentToken})">
            <summary>
            Creates a new ifnot expression given a conditional token and a body
            </summary>
            <param name="ifExpressionToken">The token containing the conditional expression</param>
            <param name="body">The body of the document to render only if the condition evaluates to false</param>
        </member>
        <member name="M:PowerArgs.IfNotExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            Evaluates the conditional expression against the given data context, rendering the body only if it is false.
            </summary>
            <param name="context">The data context to use when evaluating the conditional expression</param>
            <returns>The rendered body if the conditional was false, an empty string otherwise</returns>
        </member>
        <member name="T:PowerArgs.IfExpressionProvider">
            <summary>
            An expression provider that can provide either an If expresison or an IfNot expression.
            </summary>
        </member>
        <member name="M:PowerArgs.IfExpressionProvider.#ctor(System.Boolean)">
            <summary>
            Creates a new provider, indicating whether or not this provider should provide if or ifnot expressions.
            </summary>
            <param name="not">If true, this provider will provide if expressions, otherwise it will provide ifnot expressions</param>
        </member>
        <member name="M:PowerArgs.IfExpressionProvider.CreateExpression(PowerArgs.DocumentExpressionContext)">
            <summary>
            Creates either an if or an ifnot expression, based on its configuration, using the given document info.
            </summary>
            <param name="context">The context that contains information about the document being rendered</param>
            <returns>The expression, either an if or an ifnot expression</returns>
        </member>
        <member name="T:PowerArgs.ConsoleColorStackElement">
            <summary>
            An element that can be used to track the state of the renderer's colors as expressions are being evaluated
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleColorStackElement.FG">
            <summary>
            An optional foreground color value
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleColorStackElement.BG">
            <summary>
            An optional background color value
            </summary>
        </member>
        <member name="T:PowerArgs.LocalVariableSet">
            <summary>
            A class that lets the document renderer track local variable state as expressions are being evaluated
            </summary>
        </member>
        <member name="M:PowerArgs.LocalVariableSet.#ctor">
            <summary>
            Creates a new local variable set
            </summary>
        </member>
        <member name="P:PowerArgs.LocalVariableSet.CurrentForegroundColor">
            <summary>
            Gets the current foreground color that is in scope or null if it is not currently defined
            </summary>
        </member>
        <member name="P:PowerArgs.LocalVariableSet.CurrentBackgroundColor">
            <summary>
            Gets the current background color that is in scope or null if it is not currently defined
            </summary>
        </member>
        <member name="M:PowerArgs.LocalVariableSet.PushConsoleColors(System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Sets the current console color variables to the given values, pushing the existing values onto a stack
            </summary>
            <param name="fg">The optional foreground color to set</param>
            <param name="bg">The optional background color to set</param>
        </member>
        <member name="M:PowerArgs.LocalVariableSet.PopConsoleColors">
            <summary>
            Pops the latest console colors off of the stack and sets them as the current colors to use.
            </summary>
        </member>
        <member name="M:PowerArgs.LocalVariableSet.Add(PowerArgs.DocumentToken,System.Object)">
            <summary>
            Adds a new local variable.  This will throw if there's already a variable defined with the given identifier
            </summary>
            <param name="variableToken">The token containing the identifier of the variable name</param>
            <param name="value">The initial value of the local variable</param>
        </member>
        <member name="M:PowerArgs.LocalVariableSet.Force(System.String,System.Object)">
            <summary>
            Forefully sets the value of a local value, regardless of whether or not that variable is already defined.
            </summary>
            <param name="variableName">The name of the variable</param>
            <param name="value">The value of the variable</param>
        </member>
        <member name="M:PowerArgs.LocalVariableSet.Remove(PowerArgs.DocumentToken)">
            <summary>
            Removes a local variable.  This will throw if there is no variable with the given name
            </summary>
            <param name="variableToken">The token containing the identifier of the variable to remove</param>
        </member>
        <member name="M:PowerArgs.LocalVariableSet.ForceClear(System.String)">
            <summary>
            Tries to remove a variable, and does not throw if the variable is not defined.
            </summary>
            <param name="variableName">The name of the variable to clear</param>
        </member>
        <member name="M:PowerArgs.LocalVariableSet.IsDefined(System.String)">
            <summary>
            Determines if the given variable is defined
            </summary>
            <param name="variableName">The name to check</param>
            <returns>True if the variable is defined, false otherwise</returns>
        </member>
        <member name="P:PowerArgs.LocalVariableSet.Item(System.String)">
            <summary>
            Gets the value of a local variable given an identifier
            </summary>
            <param name="variableName">the name of the variable to lookup</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.LocalVariableSet.TryParseLocalVariable(System.String,System.Object@,System.String@)">
            <summary>
            Tries to parse a local variable from an expression.  If successful the expression is evaluated then the local variable is returned via an out variable.  
            If there was more to the expression, a property navigation for example, then that is also passed to the caller via an out variable.
            </summary>
            <param name="expression">The expression that may refer to a local variable</param>
            <param name="result">The local variable that is set if a local variable was matched</param>
            <param name="restOfExpression">The rest of the expression that came after the local variable identifier</param>
            <returns>True if a local variable was parsed, false otherwise</returns>
        </member>
        <member name="T:PowerArgs.ObjectPathTokenType">
            <summary>
            An enum used to add type metadata to object path expression tokens
            </summary>
        </member>
        <member name="F:PowerArgs.ObjectPathTokenType.IndexerOpen">
            <summary>
            Indicates the start of an index navigation for objects like arrays, lists, and dictionaries.  '['
            </summary>
        </member>
        <member name="F:PowerArgs.ObjectPathTokenType.IndexerClose">
            <summary>
            Indicates the end of an index navigation for objects like arrays, lists, and dictionaries. ']'
            </summary>
        </member>
        <member name="F:PowerArgs.ObjectPathTokenType.NavigationElement">
            <summary>
            Indicates a property navigation for an object.
            </summary>
        </member>
        <member name="F:PowerArgs.ObjectPathTokenType.Identifier">
            <summary>
            Indicates a property identifier
            </summary>
        </member>
        <member name="F:PowerArgs.ObjectPathTokenType.Whitespace">
            <summary>
            Indicates whitespace
            </summary>
        </member>
        <member name="F:PowerArgs.ObjectPathTokenType.StringLiteral">
            <summary>
            Indicates a string literal inside of double quotes
            </summary>
        </member>
        <member name="T:PowerArgs.ObjectPathToken">
            <summary>
            A token that is a part of an object path expression string
            </summary>
        </member>
        <member name="P:PowerArgs.ObjectPathToken.TokenType">
            <summary>
            Gets the type of token
            </summary>
        </member>
        <member name="M:PowerArgs.ObjectPathToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates an object path token
            </summary>
            <param name="initialValue">The initial value of the token</param>
            <param name="startIndex">The start index of the token in the source string</param>
            <param name="line">The line number that this token is on</param>
            <param name="col">The column within the line that this token is on</param>
        </member>
        <member name="M:PowerArgs.ObjectPathToken.TokenFactoryImpl(PowerArgs.Token,System.Collections.Generic.List{PowerArgs.ObjectPathToken})">
            <summary>
            A method that can determine which type of token the given value is
            </summary>
            <param name="token">The token to classify</param>
            <param name="previous">Previously classified tokens in the source string</param>
            <returns>The classified token</returns>
        </member>
        <member name="T:PowerArgs.ObjectPathExpression">
            <summary>
            An object that represents navigation into an object properties or indexed elements
            </summary>
        </member>
        <member name="P:PowerArgs.ObjectPathExpression.Elements">
            <summary>
            The path elements for this expression
            </summary>
        </member>
        <member name="M:PowerArgs.ObjectPathExpression.#ctor(System.Collections.Generic.IEnumerable{PowerArgs.IObjectPathElement})">
            <summary>
            Create a path expression given a collection of path elements
            </summary>
            <param name="elements">The path elements</param>
        </member>
        <member name="M:PowerArgs.ObjectPathExpression.Parse(System.String)">
            <summary>
            Parses an object path expression from a string.
            </summary>
            <param name="expression">The expression text to parse</param>
            <returns>The parsed expression</returns>
        </member>
        <member name="M:PowerArgs.ObjectPathExpression.Evaluate(System.Object)">
            <summary>
            Evaluates the expression and returns the value
            </summary>
            <param name="root">the object to evaluate against</param>
            <returns>The result of the evaluation</returns>
        </member>
        <member name="M:PowerArgs.ObjectPathExpression.EvaluateAndTraceInfo(System.Object)">
            <summary>
            Evaluates the expression, returning the object that corresponds to each element in the path.
            </summary>
            <param name="root">the object to evaluate against</param>
            <returns>A list of object where each object corresponds to an element in the path</returns>
        </member>
        <member name="M:PowerArgs.ObjectPathExpression.EvaluateAndTrace(System.Object)">
            <summary>
            Evaluates the expression, returning the object that corresponds to each element in the path.
            </summary>
            <param name="root">the object to evaluate against</param>
            <returns>A list of object where each object corresponds to an element in the path</returns>
        </member>
        <member name="T:PowerArgs.IObjectPathElement">
            <summary>
            An object that represents a path element
            </summary>
        </member>
        <member name="T:PowerArgs.PropertyPathElement">
            <summary>
            A path element that represents an object's property
            </summary>
        </member>
        <member name="P:PowerArgs.PropertyPathElement.PropertyName">
            <summary>
            Gets the name of the property
            </summary>
        </member>
        <member name="M:PowerArgs.PropertyPathElement.#ctor(System.String)">
            <summary>
            Creates a property path element given a property name
            </summary>
            <param name="propertyName">the name of the property</param>
        </member>
        <member name="M:PowerArgs.PropertyPathElement.ToString">
            <summary>
            Returns the property name
            </summary>
            <returns>the property name</returns>
        </member>
        <member name="T:PowerArgs.IndexerPathElement">
            <summary>
            A path element that represents an index navigation
            </summary>
        </member>
        <member name="P:PowerArgs.IndexerPathElement.Index">
            <summary>
            The indexer value, either a literal string or an integer
            </summary>
        </member>
        <member name="M:PowerArgs.IndexerPathElement.#ctor(System.Object)">
            <summary>
            Creates an indexer element given an indexer value
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:PowerArgs.IndexerPathElement.FindMatchingProperty(System.Object)">
            <summary>
            Finds the matching property info that represents an indexer property (do not use for strings or arrays).
            </summary>
            <param name="target">The object to search</param>
            <returns>The matching property</returns>
        </member>
        <member name="M:PowerArgs.IndexerPathElement.ToString">
            <summary>
            returns '[' + the index value + ']'
            </summary>
            <returns>'[' + the index value + ']'</returns>
        </member>
        <member name="T:PowerArgs.PlainTextDocumentExpression">
            <summary>
            A document expression that represents plain text with no replacements or custom logic
            </summary>
        </member>
        <member name="F:PowerArgs.PlainTextDocumentExpression.tokens">
            <summary>
            The plain text tokens
            </summary>
        </member>
        <member name="M:PowerArgs.PlainTextDocumentExpression.#ctor(System.Collections.Generic.List{PowerArgs.DocumentToken})">
            <summary>
            Creates a plain text document expression given a list of tokens
            </summary>
            <param name="tokens">A list of plain text tokens to render without any special handling</param>
        </member>
        <member name="M:PowerArgs.PlainTextDocumentExpression.#ctor(PowerArgs.DocumentToken)">
            <summary>
            Creates a plain text document expression given a single plain text token
            </summary>
            <param name="singleToken">A single plain text token to render without any special handling</param>
        </member>
        <member name="M:PowerArgs.PlainTextDocumentExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            Renders the tokens in the expression, using the ambient foreground and background colors if they are set.
            </summary>
            <param name="context">The data context to use for evaluation</param>
            <returns>The rendered plain text</returns>
        </member>
        <member name="T:PowerArgs.TableExpression">
            <summary>
            A document expression that can be used to render a table that is specifically formatted to display
            in a console window.
            </summary>
        </member>
        <member name="P:PowerArgs.TableExpression.EvalToken">
            <summary>
            The token representing the expression to evaluate.  The expression is expected to resolve to
            an IEnumerable.
            </summary>
        </member>
        <member name="P:PowerArgs.TableExpression.Columns">
            <summary>
            The tokens that represent the columns to display.  Each value is expected to be a property name.  Optionally, you can
            override the display name by appending '>NewDisplayName' to the value.  For example, if there was a property called 'TheName'
            and you wanted it to display as 'Name' then the value of the column token would be 'TheName>Name'.
            </summary>
        </member>
        <member name="P:PowerArgs.TableExpression.ShowPossibleValuesForArguments">
            <summary>
            PowerArgs specific property - Set to false if using outside of Powerargs - If true then properties that are enums 
            will have their values inserted into the table.
            </summary>
        </member>
        <member name="P:PowerArgs.TableExpression.ShowDefaultValuesForArguments">
            <summary>
            PowerArgs specific property - Set to false if using outside of Powerargs - If true then the properties that have a default 
            value will have that inserted into the table
            </summary>
        </member>
        <member name="M:PowerArgs.TableExpression.#ctor(PowerArgs.DocumentToken,System.Collections.Generic.List{PowerArgs.DocumentToken},PowerArgs.DocumentExpressionContext)">
            <summary>
            Creates a new table expression given a collection evaluation expression and a list of column tokens
            </summary>
            <param name="evalToken">A token containing an expression that should evaluate to an IEnumerable</param>
            <param name="columns">A list of tokens containing the names of columns to display in the table</param>
            <param name="context">Context that is used to determine the indentation of the table within the document</param>
        </member>
        <member name="M:PowerArgs.TableExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            Renders the table given a data context
            </summary>
            <param name="context">the data context</param>
            <returns>the console friendly table, as a ConsoleString</returns>
        </member>
        <member name="T:PowerArgs.TableExpressionProvider">
            <summary>
            A provider that can create a table expression given a replacement token and parameters.
            </summary>
        </member>
        <member name="M:PowerArgs.TableExpressionProvider.CreateExpression(PowerArgs.DocumentExpressionContext)">
            <summary>
            Creates a table expression from the given document info.
            </summary>
            <param name="context">The context that contains information about the document being rendered</param>
            <returns>The created document expression</returns>
        </member>
        <member name="T:PowerArgs.TemplateExpression">
            <summary>
            A document expression that can render a named template
            </summary>
        </member>
        <member name="P:PowerArgs.TemplateExpression.IdToken">
            <summary>
            A token containing the id of the template to render
            </summary>
        </member>
        <member name="P:PowerArgs.TemplateExpression.EvalToken">
            <summary>
            A token containing an expression to be evaluated.  The result of the evaluation
            will be used as the root data object to be bound to the named template.
            </summary>
        </member>
        <member name="M:PowerArgs.TemplateExpression.#ctor(PowerArgs.DocumentToken,PowerArgs.DocumentToken)">
            <summary>
            Creates a new template expression given an id token and a data evaluation token.
            </summary>
            <param name="idToken">A token containing the id of the template to render</param>
            <param name="evalToken">A token containing an expression to be evaluated.  The result of the evaluation will be
            used as the root data object to be bound to the named template.</param>
        </member>
        <member name="M:PowerArgs.TemplateExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            Finds the matching template from the data context, evaluates the data expression, then renders
            the template against the data.  The rendered document is inserted into the parent document.
            </summary>
            <param name="context">The data context used to find the named template and to evaluate the data expression</param>
            <returns>The rendered child document to be inserted into the parent document</returns>
        </member>
        <member name="T:PowerArgs.TemplateExpressionProvider">
            <summary>
            A provider that can create a template expression from a replacement token and parameters.
            </summary>
        </member>
        <member name="M:PowerArgs.TemplateExpressionProvider.CreateExpression(PowerArgs.DocumentExpressionContext)">
            <summary>
            Creates a template expression given a replacement token and parameters.
            </summary>
            <param name="context">Context about the expression being parsed</param>
            <returns>a template expression</returns>
        </member>
        <member name="T:PowerArgs.TokenizerException">
            <summary>
            An exception that will be thrown if there was an error while tokenizing a string.
            </summary>
        </member>
        <member name="M:PowerArgs.TokenizerException.#ctor(System.String)">
            <summary>
            Creates a new tokenizer exception given a message
            </summary>
            <param name="message">The exception message</param>
        </member>
        <member name="T:PowerArgs.Token">
            <summary>
            A base token class that represents a substring from a document.  The location in the source
            document is tracked along with the substring so that code that processes the token can indicate
            where problems are to the user who supplied the document if needed.
            </summary>
        </member>
        <member name="P:PowerArgs.Token.Value">
            <summary>
            Gets the value of the token
            </summary>
        </member>
        <member name="P:PowerArgs.Token.StartIndex">
            <summary>
            Gets the zero based start index of this token in the document
            </summary>
        </member>
        <member name="P:PowerArgs.Token.SourceFileLocation">
            <summary>
            Gets a string that represents the source file of this document.  It does not need to be a file name, but it usually is.
            </summary>
        </member>
        <member name="P:PowerArgs.Token.EndIndex">
            <summary>
            Gets the end index of the token in the document
            </summary>
        </member>
        <member name="P:PowerArgs.Token.Line">
            <summary>
            Gets the 1 based line number of the token in the document
            </summary>
        </member>
        <member name="P:PowerArgs.Token.Column">
            <summary>
            Gets the 1 based index of the token within it's line
            </summary>
        </member>
        <member name="P:PowerArgs.Token.Position">
            <summary>
            Gets a string that represents the position of this token in the source document. 
            </summary>
        </member>
        <member name="M:PowerArgs.Token.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a token given an initial value, a start index, a line number, and a column number
            </summary>
            <param name="initialValue">The initial value of a token.  You can append to the token later</param>
            <param name="startIndex">the zero based start index of this token in the document</param>
            <param name="line">the 1 based line number of the token in the document</param>
            <param name="col">the 1 based index of the token within it's line</param>
        </member>
        <member name="M:PowerArgs.Token.ToString">
            <summary>
            Gets a string representation of the token, along with position info
            </summary>
            <returns>a string representation of the token, along with position info</returns>
        </member>
        <member name="M:PowerArgs.Token.As``1">
            <summary>
            Creates a new instance of the strongly typed token and copies all of the base token's properties to the new value
            </summary>
            <typeparam name="T">The type of the derived token.</typeparam>
            <returns>The strongly typed token</returns>
        </member>
        <member name="T:PowerArgs.WhitespaceBehavior">
            <summary>
            An enum describing the different ways the tokenizer can handle whitespace
            </summary>
        </member>
        <member name="F:PowerArgs.WhitespaceBehavior.DelimitAndInclude">
            <summary>
            Treats whitespace as a delimiter and includes the whitespace tokens in the output list of tokens
            </summary>
        </member>
        <member name="F:PowerArgs.WhitespaceBehavior.DelimitAndExclude">
            <summary>
            Treats whitespace as a delimiter, but excludes the whitespace tokens from the output list of tokens
            </summary>
        </member>
        <member name="F:PowerArgs.WhitespaceBehavior.Include">
            <summary>
            Includes whitespace in the output and does not treat it as a delimiter
            </summary>
        </member>
        <member name="T:PowerArgs.DoubleQuoteBehavior">
            <summary>
            An enum describing the different ways the tokenizer can handle double quotes
            </summary>
        </member>
        <member name="F:PowerArgs.DoubleQuoteBehavior.NoSpecialHandling">
            <summary>
            No special handling.  Double quotes will be treated like any normal character.  You can include the double quote in the delimiters list.
            </summary>
        </member>
        <member name="F:PowerArgs.DoubleQuoteBehavior.IncludeQuotedTokensAsStringLiterals">
            <summary>
            Treat values within double quotes as string literals.
            </summary>
        </member>
        <member name="T:PowerArgs.Tokenizer`1">
            <summary>
            A general purpose string tokenizer
            </summary>
            <typeparam name="T">The type of tokens that this tokenizer should output</typeparam>
        </member>
        <member name="P:PowerArgs.Tokenizer`1.Delimiters">
            <summary>
            strings to treat as delimiters.  Delimiters with longer lengths will take preference over
            those with shorter lengths.  For example if you add delimiters '{{' and '{' and the document
            contains '{{Hello' then you'll get 2 tokens, first '{{', then 'hello'
            </summary>
        </member>
        <member name="P:PowerArgs.Tokenizer`1.TokenFactory">
            <summary>
            A function that given a plain token can transform it into the strongly typed token
            </summary>
        </member>
        <member name="P:PowerArgs.Tokenizer`1.WhitespaceBehavior">
            <summary>
            Gets or sets the option that describes how whitespace should be treated.
            </summary>
        </member>
        <member name="P:PowerArgs.Tokenizer`1.DoubleQuoteBehavior">
            <summary>
            Gets or sets the option that describes how double quotes should be treated.
            </summary>
        </member>
        <member name="P:PowerArgs.Tokenizer`1.EscapeSequenceIndicator">
            <summary>
            An escape sequence identifier.  By default it is '\'
            </summary>
        </member>
        <member name="P:PowerArgs.Tokenizer`1.SourceFileLocation">
            <summary>
            A string that describes the source location for the given document
            </summary>
        </member>
        <member name="M:PowerArgs.Tokenizer`1.#ctor">
            <summary>
            Creates a new tokenizer
            </summary>
        </member>
        <member name="M:PowerArgs.Tokenizer`1.Tokenize(System.String)">
            <summary>
            Tokenizes the given string into a list of tokens
            </summary>
            <param name="input">The string to tokenize</param>
            <returns>The list of tokens</returns>
        </member>
        <member name="T:PowerArgs.TokenReader`1">
            <summary>
            A class that makes it easy to read through a list of tokens
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:PowerArgs.TokenReader`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a token reader given a list of tokens
            </summary>
            <param name="tokens">The list of tokens to read through</param>
        </member>
        <member name="M:PowerArgs.TokenReader`1.Advance(System.Boolean)">
            <summary>
            Advances the reader to the next token
            </summary>
            <param name="skipWhitespace">If true, the reader will skip past whitespace tokens when reading</param>
            <returns>the next token in the list</returns>
        </member>
        <member name="M:PowerArgs.TokenReader`1.Expect(System.String,System.Boolean,System.StringComparison)">
            <summary>
            Advances the reader and asserts that there is a value and that it matches the expected value.  If the assertion
            fails then a FormatException is thrown.
            </summary>
            <param name="skipWhiteSpace">determines if whitespace tokens are skipped</param>
            <param name="expectedValue">the token value to expect</param>
            <param name="comparison">how to compare the strings</param>
            <returns>the token which matches the expected value</returns>
        </member>
        <member name="M:PowerArgs.TokenReader`1.Peek(System.Boolean)">
            <summary>
            Gets the next token in the list without actually advancing the reader
            </summary>
            <param name="skipWhitespace">If true, the reader will skip past whitespace tokens when reading</param>
            <returns>The next token in the list</returns>
        </member>
        <member name="M:PowerArgs.TokenReader`1.TryAdvance(`0@,System.Boolean)">
            <summary>
            Advances the reader to the next token if one exists.
            </summary>
            <param name="ret">The out variable to store the token if it was found</param>
            <param name="skipWhitespace">If true, the reader will skip past whitespace tokens when reading</param>
            <returns>True if the reader advanced, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.TokenReader`1.CanAdvance(System.Boolean)">
            <summary>
            Determines if the reader can advance
            </summary>
            <param name="skipWhitespace">If true, the reader will skip past whitespace tokens when reading</param>
            <returns>True if there is another token to read, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.TokenReader`1.TryPeek(`0@,System.Int32@,System.Int32,System.Boolean)">
            <summary>
            Reads the next token without advancing if one is available.
            </summary>
            <param name="ret">The out variable to store the token if it was found</param>
            <param name="lastPeekIndex">The out variable to store the index of the peeked token in the token list</param>
            <param name="lookAhead">How far to peek ahead, by default 1</param>
            <param name="skipWhitespace">If true, the reader will skip past whitespace tokens when reading</param>
            <returns>True if the reader peeked at a value, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.TokenReader`1.ToString">
            <summary>
            Gets all the tokens in the list concatenated into a single string, including whitespace
            </summary>
            <returns>all the tokens in the list concatenated into a single string, including whitespace</returns>
        </member>
        <member name="M:PowerArgs.TokenReader`1.ToString(System.Boolean)">
            <summary>
            Gets all the tokens in the list concatenated into a single string, optionally excluding whitespace
            </summary>
            <param name="skipWhitespace">If true, whitespace tokens will not be included in the output.  Tokens that have
            whitespace and non whitespace characters will always be included</param>
            <returns>all the tokens in the list concatenated into a single string, with whitespace tokens optionally excluded</returns>
        </member>
        <member name="T:PowerArgs.VarExpression">
            <summary>
            An expression that indicates the beginning of a local variable's scope
            </summary>
        </member>
        <member name="P:PowerArgs.VarExpression.NameToken">
            <summary>
            A token containing the name of the local variable to initialize
            </summary>
        </member>
        <member name="P:PowerArgs.VarExpression.ValueToken">
            <summary>
            A token containing an expression that should resolve to the initial value of the variable
            </summary>
        </member>
        <member name="M:PowerArgs.VarExpression.#ctor(PowerArgs.DocumentToken,PowerArgs.DocumentToken)">
            <summary>
            Creates a new variable expression given a name and value expression
            </summary>
            <param name="name">A token containing the name of the local variable to initialize</param>
            <param name="value">A token containing an expression that should resolve to the initial value of the variable</param>
        </member>
        <member name="M:PowerArgs.VarExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            Always results in an empty string, but initializes the local value in the data context
            </summary>
            <param name="context">The data context used to store the newly initialized variable</param>
            <returns>an empty string</returns>
        </member>
        <member name="T:PowerArgs.ClearVarExpression">
            <summary>
            An expression that indicates the end of a local variable's scope
            </summary>
        </member>
        <member name="P:PowerArgs.ClearVarExpression.NameToken">
            <summary>
            A token containing the name of the variable whose scope is ending
            </summary>
        </member>
        <member name="M:PowerArgs.ClearVarExpression.#ctor(PowerArgs.DocumentToken)">
            <summary>
            Creates a new clear variable expression given a variable name
            </summary>
            <param name="name">A token containing the name of the variable whose scope is ending</param>
        </member>
        <member name="M:PowerArgs.ClearVarExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            Removes the named variable from the context's local variable set
            </summary>
            <param name="context">the context that should contain the local variable to remove</param>
            <returns>an empty string</returns>
        </member>
        <member name="T:PowerArgs.VarExpressionProvider">
            <summary>
            A provider that can create a variable expression
            </summary>
        </member>
        <member name="M:PowerArgs.VarExpressionProvider.CreateExpression(PowerArgs.DocumentExpressionContext)">
            <summary>
            Creates a variable expression given replacement info
            </summary>
            <param name="context">The context that contains information about the document being rendered</param>
            <returns>A variable expression</returns>
        </member>
        <member name="T:PowerArgs.ClearVarExpressionProvider">
            <summary>
            A provider that can create an expression to clear a local variable
            </summary>
        </member>
        <member name="M:PowerArgs.ClearVarExpressionProvider.CreateExpression(PowerArgs.DocumentExpressionContext)">
            <summary>
            Creates a clear variable expression given replacement info
            </summary>
            <param name="context">The context that contains information about the document being rendered</param>
            <returns>a clear variable expression</returns>
        </member>
        <member name="T:PowerArgs.ArgCantBeCombinedWith">
            <summary>
            Argument metadata that lets you declare that a particular argument is not allowed if one or more other arguments are specified by the user.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgCantBeCombinedWith.ExpressionText">
            <summary>
            The expression text that was passed into the constructor.  This can either be an alias argument or a boolean expression of arguments (e.g. Argument1 | Argument2). Valid operators are
            and '&amp;', or '|', and not '!'.  Grouping with parentheses is also supported.  Example: "(Argument1 &amp; Argumrnt2) | Argument3".
            </summary>
        </member>
        <member name="M:PowerArgs.ArgCantBeCombinedWith.#ctor(System.String)">
            <summary>
            Creates a new ArgCantBeCombinedWith hook given an expression. This can either be an alias argument or a boolean expression of arguments (e.g. Argument1 | Argument2). Valid operators are
            and '&amp;', or '|', and not '!'.  Grouping with parentheses is also supported.  Example: "(Argument1 &amp; Argumrnt2) | Argument3".
            If the expression evaluates to true after all arguments have been populated then an UnexpectedArgumentException is thrown.
            </summary>
            <param name="expression">This can either be an alias argument or a boolean expression of arguments (e.g. Argument1 | Argument2). Valid operators are
            and '&amp;', or '|', and not '!'.  Grouping with parentheses is also supported.  Example: "(Argument1 &amp; Argumrnt2) | Argument3".</param>
        </member>
        <member name="M:PowerArgs.ArgCantBeCombinedWith.IsCurrentArgumentAllowed(PowerArgs.ArgHook.HookContext)">
            <summary>
            Determines if the current argument is allowed to be populated based on which other arguments are present and based on the expression passed to the constructor.
            </summary>
            <param name="context">The current PowerArgs processing context</param>
            <returns>True if this argument can be specified, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ArgCantBeCombinedWith.AfterPopulateProperties(PowerArgs.ArgHook.HookContext)">
            <summary>
            Checks to see if the current argument is allowed to have a value based on which other arguments are present and based on the expression
            passed to the constructor.  If it's not allowed and has been specified then an UnexpectedArgException is thrown.
            </summary>
            <param name="context">The current PowerArgs processing context</param>
        </member>
        <member name="T:PowerArgs.ArgExistingDirectory">
            <summary>
            Validates that if the user specifies a value for a property that the value represents a directory that exists
            as determined by System.IO.Directory.Exists(directory).
            </summary>
        </member>
        <member name="M:PowerArgs.ArgExistingDirectory.Validate(System.String,System.String@)">
            <summary>
            Validates that the given directory exists and cleans up the argument so that the application has access
            to the full path.
            </summary>
            <param name="name">the name of the property being populated.  This validator doesn't do anything with it.</param>
            <param name="arg">The value specified on the command line</param>
        </member>
        <member name="T:PowerArgs.ArgExistingFile">
            <summary>
            Validates that if the user specifies a value for a property that the value represents a file that exists
            as determined by System.IO.File.Exists(file).
            </summary>
        </member>
        <member name="M:PowerArgs.ArgExistingFile.Validate(System.String,System.String@)">
            <summary>
            Validates that the given file exists and cleans up the argument so that the application has access
            to the full path.
            </summary>
            <param name="name">the name of the property being populated.  This validator doesn't do anything with it.</param>
            <param name="arg">The value specified on the command line</param>
        </member>
        <member name="T:PowerArgs.ArgRange">
            <summary>
            Validates that the value is a number between the min and max (both inclusive) specified
            </summary>
        </member>
        <member name="P:PowerArgs.ArgRange.MaxIsExclusive">
            <summary>
            Set to true if your max is exclusive.  This value is false by default.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgRange.#ctor(System.Double,System.Double)">
            <summary>
             Creates a new ArgRange validator.
            </summary>
            <param name="min">The minimum value (inclusive)</param>
            <param name="max">The maximum value (inclusive by default, set MaxIsExclusive to true to override)</param>
        </member>
        <member name="M:PowerArgs.ArgRange.Validate(System.String,System.String@)">
            <summary>
            Validates that the value is a number between the min and max (both inclusive) specifie
            </summary>
            <param name="name">the name of the property being populated.  This validator doesn't do anything with it.</param>
            <param name="arg">The value specified on the command line</param>
        </member>
        <member name="T:PowerArgs.ArgRegex">
            <summary>
            Performs regular expression validation on a property.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgRegex.regex">
            <summary>
            The regular expression to match
            </summary>
        </member>
        <member name="F:PowerArgs.ArgRegex.errorMessage">
            <summary>
            A prefix for the error message to show in the case of a match.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgRegex.exactMatch">
            <summary>
            The exact match that was found.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgRegex.#ctor(System.String,System.String)">
            <summary>
            Creates a new ArgRegex validator.
            </summary>
            <param name="regex">The regular expression that requires an exact match to be valid</param>
            <param name="errorMessage">A prefix for the error message to show in the case of a match.</param>
        </member>
        <member name="M:PowerArgs.ArgRegex.Validate(System.String,System.String@)">
            <summary>
            Validates that the given arg exactly matches the regular expression provided.
            </summary>
            <param name="name">the name of the property being populated.  This validator doesn't do anything with it.</param>
            <param name="arg">The value specified on the command line.</param>
        </member>
        <member name="T:PowerArgs.ArgRequired">
            <summary>
            Validates that the user actually provided a value for the given property on the command line.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgRequired.ImplementsValidateAlways">
            <summary>
            Determines whether or not the validator should run even if the user doesn't specify a value on the command line.
            This value is always true for this validator.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgRequired.If">
            <summary>
            A valid command line alias or boolean expression of aliases (and/or/not supported as and '&amp;', or '|', and not '!').
            When specified the target argument is only required if the referenced argument(s) were specified on the command line.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgRequired.IfNot">
            <summary>
            A valid command line alias or boolean expression of aliases (and/or/not supported as and '&amp;', or '|', and not '!').
            When specified the target argument is only required if the referenced argument(s) were not specified on the command line.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgRequired.IsConditionallyRequired">
            <summary>
            Determines if this metadata represents an argument conditionionally required.  This will be true if you've set the If or the IfNot property.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgRequired.TabCompletionHandlerType">
            <summary>
            Gets or sets the type to be used for tab completion when prompting for a missing, required argument.  The type must implement ITabCompletionHandler
            </summary>
        </member>
        <member name="P:PowerArgs.ArgRequired.HighlighterConfiguratorType">
            <summary>
            Gets or sets the type to use inject custom syntax highlighting when prompting for a missing, required argument.  The type must implement IHighlighterConfigurator
            </summary>
        </member>
        <member name="M:PowerArgs.ArgRequired.#ctor">
            <summary>
            Creates a new ArgRequired attribute.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgRequired.PromptIfMissing">
            <summary>
            If you set this to true and the user didn't specify a value then the command line will prompt the user for the value.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgRequired.ValidateAlways(PowerArgs.CommandLineArgument,System.String@)">
            <summary>
            Validates that the user actually specified a value and optionally prompts them when it is missing.
            </summary>
            <param name="argument">The argument being populated.  This validator doesn't do anything with it.</param>
            <param name="arg">The value specified on the command line or null if it wasn't specified</param>
        </member>
        <member name="P:PowerArgs.ArgRequiredConditionalHook.TabCompletionHandlerType">
            <summary>
            Gets or sets the type to be used for tab completion when prompting for a missing, required argument.  The type must implement ITabCompletionHandler
            </summary>
        </member>
        <member name="P:PowerArgs.ArgRequiredConditionalHook.HighlighterConfiguratorType">
            <summary>
            Gets or sets the type to use inject custom syntax highlighting when prompting for a missing, required argument.  The type must implement IHighlighterConfigurator
            </summary>
        </member>
        <member name="T:PowerArgs.ArgValidator">
            <summary>
            An abstract class that all validators should extend to validate user input from the command line.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgValidator.Priority">
            <summary>
            Determines the order in which validators are executed.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgValidator.ImplementsValidateAlways">
            <summary>
            If implemented in a derived class then ValidateAlways will be called for each property,
            even if that property wasn't specified by the user on the command line.  In this case the value
            will always be null.  This is useful for implementing validators such as [ArgRequired].
            
            By default, the Validate(string,ref string) method is called unless a validator opts into ValidateAlways
            </summary>
        </member>
        <member name="M:PowerArgs.ArgValidator.Validate(System.String,System.String@)">
            <summary>
            Most validators should just override this method. It ONLY gets called if the user specified the 
            given argument on the command line, meaning you will never get a null for 'arg'.
            
            If you want your validator to run even if the user did not specify the argument on the command line
            (for example if you were building something like [ArgRequired] then you should do 3 things.
            
            1 - Override the boolean ImplementsValidateAlways property so that it returns true
            2 - Override the ValidateAlways() method instead
            3 - Don't override the Validate() method since it will no longer be called
            
            </summary>
            <param name="name"></param>
            <param name="arg">The value specified on the command line.  If the user specified the property name, but not a value then arg will equal string.Empty.  The value will never be null.</param>
        </member>
        <member name="M:PowerArgs.ArgValidator.ValidateAlways(PowerArgs.CommandLineArgument,System.String@)">
             <summary>
             Always validates the given argument, even if it was not specified by the user (arg will be null in this case).
             If you override this method then you should also override ImplementsValidateAlways so it returns true.
            </summary>
             <param name="argument">The argument that the attribute was placed on.</param>
             <param name="arg">The value specified on the command line or null if the user didn't actually specify a value for the argument.  If the user specified the argument name, but not a value then arg will equal string.Empty</param>
        </member>
    </members>
</doc>
